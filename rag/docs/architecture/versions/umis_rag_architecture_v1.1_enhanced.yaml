# ========================================
# UMIS Advanced RAG Architecture v1.1 Enhanced
# ========================================
# 
# ëª©ì : UMIS v6.2 ì² í•™ì„ ì™„ì „íˆ ë°˜ì˜í•œ Multi-Layer RAG
# ì² í•™: "ê°€ì„¤ê³¼ íŒë‹¨ì—ëŠ” ê·¼ê±°ì™€ ê²€ì¦ì´ í•„ìš”í•˜ë‹¤"
# í•µì‹¬: Stewartì˜ 2ê°€ì§€ ê°ì‹œ + ì ì§„ì  ì§€ëŠ¥ + í”¼ë“œë°± ë£¨í”„
#
# v1.0 ëŒ€ë¹„ ë³€ê²½:
# - ğŸ†• ìˆœí™˜ íŒ¨í„´ ê°ì§€ ì‹œìŠ¤í…œ (Stewart í•µì‹¬!)
# - ğŸ†• ëª©í‘œ ì •ë ¬ë„ ëª¨ë‹ˆí„°ë§ (Stewart í•µì‹¬!)
# - ğŸ†• ëª…í™•ë„ ì§„í™” ì¶”ì  (Adaptive Intelligence)
# - ğŸ†• ìƒíƒœ ê¸°ê³„ í†µí•© (UMIS í”„ë¡œì„¸ìŠ¤)
# - ğŸ†• ìì—°ìŠ¤ëŸ¬ìš´ ì§€ì› vs ì˜ë¬´ ê²€ì¦ êµ¬ë¶„
# - ğŸ”„ Stewart Meta-RAG ê°•í™”
#
# ========================================

_meta:
  version: "1.1_enhanced"
  created: "2025-11-01"
  umis_version: "6.2"
  umis_reference: "umis_guidelines_v6.2.yaml"
  architecture_type: "State-Aware Graph-Vector Hybrid RAG with Adaptive Intelligence"
  core_principle: "ê°€ì„¤ê³¼ íŒë‹¨ì—ëŠ” ê·¼ê±°ì™€ ê²€ì¦ì´ í•„ìš”í•˜ë‹¤"
  
  key_enhancements:
    - "ìˆœí™˜ íŒ¨í„´ ìë™ ê°ì§€ (3íšŒ ì„ê³„ê°’)"
    - "ëª©í‘œ ì •ë ¬ë„ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ (60% ê¸°ì¤€)"
    - "ëª…í™•ë„ ê¸°ë°˜ ì ì‘í˜• RAG ì „ëµ"
    - "ìƒíƒœ ê¸°ê³„ í†µí•© (7-state workflow)"
    - "ì¼ìƒ ì§€ì› vs ì˜ë¬´ ê²€ì¦ ì´ì¤‘ êµ¬ì¡°"

# ========================================
# UMIS Core Principles Integration
# @section: core_principles
# ========================================

umis_core_principles:
  _description: "RAG ì‹œìŠ¤í…œì— ë°˜ë“œì‹œ ë°˜ì˜í•´ì•¼ í•  UMIS ì›ì¹™"
  
  principle_1_evidence_based:
    name: "ê°€ì„¤ê³¼ íŒë‹¨ì—ëŠ” ê·¼ê±°ì™€ ê²€ì¦ì´ í•„ìš”í•˜ë‹¤"
    
    rag_implementation:
      every_hypothesis:
        - must_reference: "Albert ê´€ì°° (OBSERVED_BY)"
        - must_apply: "íŒ¨í„´ (BASED_ON)"
        - must_cite: "ì‚¬ë¡€ (REFERENCES)"
        - must_validate: "Bill ê³„ì‚° (REQUIRES_VALIDATION)"
        - must_verify: "Rachel ì¶œì²˜ (SOURCED_FROM)"
      
      graph_enforcement:
        query: |
          MATCH (h:SteveHypothesis {id: $hypothesis_id})
          OPTIONAL MATCH (h)-[:OBSERVED_BY]->(albert)
          OPTIONAL MATCH (h)-[:BASED_ON]->(pattern)
          OPTIONAL MATCH (h)-[:REFERENCES]->(case)
          OPTIONAL MATCH (h)-[:REQUIRES_VALIDATION]->(bill)
          OPTIONAL MATCH (bill)-[:SOURCED_FROM]->(data)-[:VERIFIED_BY]->(rachel)
          
          WITH h,
               count(albert) as has_albert,
               count(pattern) as has_pattern,
               count(case) as has_case,
               count(bill) as has_bill,
               count(rachel) as has_rachel
          
          WHERE has_albert = 0 OR has_pattern = 0 OR 
                has_case = 0 OR has_bill = 0 OR has_rachel = 0
          
          RETURN h.id as incomplete_hypothesis,
                 CASE WHEN has_albert = 0 THEN 'Albert ê´€ì°°' END as missing_albert,
                 CASE WHEN has_pattern = 0 THEN 'íŒ¨í„´' END as missing_pattern,
                 CASE WHEN has_case = 0 THEN 'ì‚¬ë¡€' END as missing_case,
                 CASE WHEN has_bill = 0 THEN 'Bill ê³„ì‚°' END as missing_bill,
                 CASE WHEN has_rachel = 0 THEN 'Rachel ê²€ì¦' END as missing_rachel
        
        stewart_action: "Gap ì§€ì  ë° ë³´ì™„ ìš”ì²­"
  
  principle_2_adaptive_intelligence:
    name: "ë¶ˆí™•ì‹¤ì„± ìˆ˜ìš© ë° ì ì§„ì  ì§„í™”"
    
    clarity_evolution:
      start: "20-30% (Discovery)"
      middle: "50-70% (Analysis)"
      end: "80-95% (Execution)"
      
      rag_adaptation:
        low_clarity:
          mode: "exploration"
          chunking: "large (pattern, macro)"
          diversity: "high"
          top_k: 15-20
        
        high_clarity:
          mode: "precision"
          chunking: "small (case, metric)"
          diversity: "low"
          top_k: 3-5
  
  principle_3_autonomous_guidance:
    name: "Stewartì˜ ëŠ¥ë™ì  ê°ì‹œ ë° ê°œì…"
    
    monitoring_targets:
      - circular_motion: "3íšŒ ë°˜ë³µ ê°ì§€"
      - goal_alignment: "60% ìœ ì§€"
      - clarity_progress: "ì •ì²´ ê°ì§€"
      - 10x_opportunity: "í° ê¸°íšŒ ë°œê²¬"
    
    intervention_protocol:
      level_1_nudge: "ê°€ë²¼ìš´ ì•Œë¦¼ (2íšŒ ë°˜ë³µ)"
      level_2_review: "ê²€í†  ì„¸ì…˜ (3íšŒ ë°˜ë³µ, ì •ë ¬ < 60%)"
      level_3_pivot: "ì „ë©´ ì¬ê²€í†  (10x ê¸°íšŒ)"

# ========================================
# Layer 1: Vector RAG (ê¸°ì¡´ ìœ ì§€)
# ========================================

layer_1_vector_rag:
  # ... (ê¸°ì¡´ ë‚´ìš© ìœ ì§€)
  
  enhancements:
    - "ëª…í™•ë„ ê¸°ë°˜ adaptive chunking"
    - "ìƒíƒœë³„ retrieval ì „ëµ"
    - "ëª©í‘œ ì •ë ¬ë„ ì¸¡ì • í†µí•©"

# ========================================
# Layer 2: Knowledge Graph (í™•ì¥)
# ========================================

layer_2_knowledge_graph:
  # ... (ê¸°ì¡´ ë‚´ìš© ìœ ì§€)
  
  additional_node_types:
    
    project_state_nodes:
      label: "ProjectState"
      _umis_integration: "ìƒíƒœ ê¸°ê³„ í‘œí˜„"
      
      properties:
        - state_name: "['discovery', 'structure_analysis', ...]"
        - clarity_score: "float (0-100)"
        - goal_alignment: "float (0-100)"
        - active_agents: "JSON array"
        - quality_gate_passed: "boolean"
      
      state_sequence:
        - project_start: "clarity: 25%"
        - discovery: "clarity: 40%"
        - structure_analysis: "clarity: 60%"
        - opportunity_discovery: "clarity: 75%"
        - quantification: "clarity: 85%"
        - synthesis: "clarity: 90%"
        - decision: "clarity: 95%"
    
    circular_pattern_nodes:
      label: "CircularPattern"
      _umis_integration: "ìˆœí™˜ ê°ì§€ ë° ì¶”ì "
      
      properties:
        - pattern_id: "ìˆœí™˜ íŒ¨í„´ ID"
        - topic: "ë°˜ë³µ ì£¼ì œ"
        - agents_involved: "JSON array"
        - repetition_count: "int"
        - time_consumed: "duration"
        - stewart_intervened: "boolean"
        - resolution: "í•´ê²° ë°©ë²•"
    
    goal_alignment_nodes:
      label: "GoalAlignment"
      _umis_integration: "ëª©í‘œ ì •ë ¬ë„ ì¶”ì "
      
      properties:
        - query_id: "ì¿¼ë¦¬ ID"
        - alignment_score: "float (0-100)"
        - goal_vector: "í”„ë¡œì íŠ¸ ëª©í‘œ ë²¡í„°"
        - query_vector: "ì¿¼ë¦¬ ë²¡í„°"
        - deviation_reason: "ì´íƒˆ ì´ìœ  (if < 60%)"
  
  additional_relationships:
    
    state_transition:
      type: "TRANSITIONS_TO"
      direction: "ProjectState -> ProjectState"
      properties:
        - trigger: "ì „í™˜ ì¡°ê±´"
        - quality_gate: "í†µê³¼ ì¡°ê±´"
        - outputs: "ì‚°ì¶œë¬¼"
      
      examples:
        - from: "structure_analysis"
          to: "opportunity_discovery"
          trigger: "Albert ê²°ë¡  ì™„ë£Œ"
          quality_gate: "Bill + Rachel + Stewart ê²€ì¦ í†µê³¼"
          
          graph_check: |
            MATCH (s1:ProjectState {name: 'structure_analysis'})
                  -[t:TRANSITIONS_TO]->(s2:ProjectState {name: 'opportunity_discovery'})
            MATCH (a:AlbertConclusion)-[:VERIFIED_BY]->(v:Verification)
            WHERE v.validators = ['bill', 'rachel', 'stewart']
              AND v.all_passed = true
            RETURN count(*) > 0 as can_transition
    
    circular_detection:
      type: "REPEATS_WITH"
      direction: "Query -> Query"
      properties:
        - topic_similarity: "float (LLM íŒë‹¨)"
        - time_gap: "duration"
        - agents_same: "boolean"
      
      detection: |
        MATCH (q1:Query)-[r:REPEATS_WITH]->(q2:Query)-[r2:REPEATS_WITH]->(q3:Query)
        WHERE r.topic_similarity > 0.85
          AND r2.topic_similarity > 0.85
        RETURN q1, q2, q3, 
               [q1.topic, q2.topic, q3.topic] as circular_pattern
    
    goal_deviation:
      type: "DEVIATES_FROM"
      direction: "Query -> ProjectGoal"
      properties:
        - alignment_score: "float (0-100)"
        - deviation_reason: "ì´íƒˆ ì´ìœ "
      
      alert: |
        MATCH (q:Query)-[d:DEVIATES_FROM]->(g:ProjectGoal)
        WHERE d.alignment_score < 60
        RETURN q.text as deviating_query,
               d.alignment_score as score,
               d.deviation_reason as reason

# ========================================
# Layer 3: Meta-Learning (ëŒ€í­ ê°•í™”!)
# ========================================

layer_3_meta_learning:
  
  # ... (ê¸°ì¡´ ë‚´ìš© ìœ ì§€)
  
  stewart_enhanced_monitoring:
    _description: "UMIS v6.2 Stewart ì—­í•  ì™„ì „ êµ¬í˜„"
    
    monitoring_systems:
      
      system_1_circular_detection:
        _umis_critical: true
        _priority: "P0"
        
        implementation:
          query_history_db:
            table: "query_history"
            schema:
              - query_id: "TEXT PRIMARY KEY"
              - agent: "TEXT"
              - query_text: "TEXT"
              - topic: "TEXT (LLM ì¶”ì¶œ)"
              - target_agent: "TEXT"
              - timestamp: "TIMESTAMP"
              - outcome: "TEXT"
          
          detection_algorithm:
            trigger: "ë§¤ ì¿¼ë¦¬ í›„ ì‹¤í–‰"
            
            steps:
              - step_1: "LLMìœ¼ë¡œ ì¿¼ë¦¬ ì£¼ì œ ì¶”ì¶œ"
              - step_2: "ìµœê·¼ 10ê°œ ì¿¼ë¦¬ topic ë¹„êµ"
              - step_3: "3ê°œ ì—°ì† ìœ ì‚¬ ì£¼ì œ (>0.85) ê°ì§€"
              - step_4: "ìˆœí™˜ íŒ¨í„´ í™•ì¸"
              - step_5: "Graphì— CircularPattern ë…¸ë“œ ìƒì„±"
            
            llm_topic_extraction:
              prompt: |
                Query: "{query_text}"
                Agent: {agent}
                
                ì´ ì¿¼ë¦¬ì˜ í•µì‹¬ ì£¼ì œë¥¼ 5ë‹¨ì–´ ì´ë‚´ë¡œ ì¶”ì¶œí•˜ì„¸ìš”.
                
                ì˜ˆì‹œ:
                  Query: "í”Œë«í¼ ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸ì˜ ê²€ì¦ ë°©ë²•"
                  Topic: "í”Œë«í¼ ê²€ì¦"
              
              cache: true  # ë¹„ìš© ì ˆê°
            
            similarity_check:
              method: "vector similarity"
              threshold: 0.85
              
              example:
                topic_1: "ì‹œì¥ ì •ì˜"
                topic_2: "íƒ€ê²Ÿ ì‹œì¥ ì„¤ì •"
                topic_3: "ì‹œì¥ ê²½ê³„ í™•ì¸"
                
                similarity(1, 2): 0.92 âœ…
                similarity(2, 3): 0.88 âœ…
                
                â†’ ìˆœí™˜ íŒ¨í„´! ğŸ”„
          
          intervention_logic:
            repetition_2:
              action: "log_only"
              stewart_mode: "monitoring"
            
            repetition_3:
              action: "nudge"
              message: |
                ğŸ’¡ "{topic}"ì— ëŒ€í•´ ë°˜ë³µ ë…¼ì˜ ì¤‘ì…ë‹ˆë‹¤.
                ë‹¤ë¥¸ ê°ë„ë¡œ ì ‘ê·¼í•´ë³´ì‹œê² ì–´ìš”?
            
            repetition_4:
              action: "escalate"
              message: |
                ğŸ”„ ìˆœí™˜ íŒ¨í„´ ê°ì§€
                
                ì£¼ì œ: {topic}
                agent: {agent_a} â†” {agent_b}
                ë°˜ë³µ: {count}íšŒ
                ì†Œìš”: {time}
                ì§„ì „: {progress}%
                
                ê¶Œê³ :
                  1. í˜„ì¬ ê°€ì •/ì œì•½ ì¬ê²€í† 
                  2. Owner ì˜ì‚¬ê²°ì • ìš”ì²­
                  3. ì „í˜€ ë‹¤ë¥¸ ì ‘ê·¼ë²• ì‹œë„
              
              owner_escalation: true
              force_decision: true
      
      system_2_goal_alignment:
        _umis_critical: true
        _priority: "P0"
        
        implementation:
          goal_embedding:
            when: "[PROJECT_START]"
            
            process:
              - extract: "í”„ë¡œì íŠ¸ ëª©í‘œ í…ìŠ¤íŠ¸"
              - embed: "text-embedding-3-large"
              - store: "project_metadata DB"
              - persist: "í”„ë¡œì íŠ¸ ì „ì²´ ë™ì•ˆ ìœ ì§€"
            
            example:
              project_goal: "í”¼ì•„ë…¸ êµ¬ë… ì„œë¹„ìŠ¤ì˜ ì‹œì¥ ê¸°íšŒ í‰ê°€"
              goal_vector: "[0.234, -0.567, ..., 0.891]"  # 3072 dim
          
          alignment_measurement:
            for_each_query:
              - query_vector: "í˜„ì¬ ì¿¼ë¦¬ ì„ë² ë”©"
              - calculate: "cosine_similarity(query_vector, goal_vector)"
              - alignment_score: "similarity Ã— 100"  # 0-100%
              - store: "query_history"
            
            example:
              goal: "í”¼ì•„ë…¸ êµ¬ë… ì„œë¹„ìŠ¤"
              
              query_1: "í”¼ì•„ë…¸ êµ¬ë… ëª¨ë¸ ê²€ì¦"
              alignment: 94% âœ…
              
              query_2: "ë°”ì´ì˜¬ë¦° ì‹œì¥ êµ¬ì¡°"
              alignment: 52% âš ï¸
              
              query_3: "í˜„ì•…ê¸° ì œì¡°ì‚¬ ë¶„ì„"
              alignment: 38% ğŸ”´ (ì´íƒˆ!)
          
          continuous_monitoring:
            window: "ìµœê·¼ 5ê°œ ì¿¼ë¦¬"
            metric: "í‰ê·  alignment"
            threshold: 60
            
            alert_condition:
              trigger: "avg_alignment < 60%"
              
              stewart_intervention:
                level: "review"
                message: |
                  ğŸ¯ ëª©í‘œ ì •ë ¬ë„ ê²½ê³ 
                  
                  í˜„ì¬ í‰ê· : {avg_alignment}% (ê¸°ì¤€: 60%)
                  
                  ì´íƒˆ ì¿¼ë¦¬:
                    - "{query_2}" (52%)
                    - "{query_3}" (38%)
                  
                  ì›ë˜ ëª©í‘œ: "{project_goal}"
                  
                  ê¶Œê³ :
                    1. ëª©í‘œ ì¬í™•ì¸ í•„ìš”
                    2. í˜„ì¬ ì‘ì—…ì˜ ëª©í‘œ ê¸°ì—¬ë„ í‰ê°€
                    3. ìš°ì„ ìˆœìœ„ ì¬ì¡°ì •
                
                pause_execution: true
                require_owner_decision: true
      
      system_3_clarity_evolution:
        _umis_adaptive: true
        _priority: "P1"
        
        implementation:
          clarity_dimensions:
            - target_market: "íƒ€ê²Ÿ ì‹œì¥ ëª…í™•ë„"
            - value_proposition: "ê°€ì¹˜ ì œì•ˆ ëª…í™•ë„"
            - business_model: "ì‚¬ì—… ëª¨ë¸ ëª…í™•ë„"
            - execution_path: "ì‹¤í–‰ ê²½ë¡œ ëª…í™•ë„"
          
          measurement:
            method: "LLM í‰ê°€"
            
            prompt_per_dimension: |
              Dimension: {dimension_name}
              
              Project Goal: {goal}
              Current State: {accumulated_findings}
              
              ì´ ì°¨ì›ì˜ ëª…í™•ë„ë¥¼ 0-100%ë¡œ í‰ê°€í•˜ì„¸ìš”.
              
              0-30%: ë§¤ìš° ë¶ˆëª…í™•, ë§ì€ íƒìƒ‰ í•„ìš”
              30-60%: ìœ¤ê³½ ë³´ì„, ë¶„ì„ í•„ìš”
              60-85%: ëª…í™•í•¨, ê²€ì¦ í•„ìš”
              85-100%: ë§¤ìš° ëª…í™•, ì‹¤í–‰ ê°€ëŠ¥
            
            overall: "4ê°œ ì°¨ì› í‰ê· "
          
          adaptive_rag_strategy:
            clarity_20_40:
              name: "Exploration Mode"
              
              rag_config:
                chunking_level:
                  albert: "macro"
                  steve: "pattern"
                  bill: "report"
                
                top_k: 15-20
                diversity: "maximum (MMR)"
                query_breadth: "broad"
                
                agent_behavior:
                  albert: "ë„“ì€ ì‹œì¥ ìŠ¤ìº”"
                  steve: "ë‹¤ì–‘í•œ íŒ¨í„´ íƒìƒ‰"
                  bill: "ê°œëµ ê·œëª¨ ì¶”ì •"
              
              example:
                clarity: 35%
                steve_query: "ìŒì•… ê´€ë ¨ ì‚¬ì—… ê¸°íšŒ"  # ë„“ìŒ!
                results: 7ê°œ íŒ¨í„´ (ë‹¤ì–‘)
                purpose: "ê°€ëŠ¥ì„± íƒìƒ‰, ë°©í–¥ ì°¾ê¸°"
            
            clarity_40_70:
              name: "Analysis Mode"
              
              rag_config:
                chunking_level:
                  albert: "meso"
                  steve: "section"
                  bill: "calculation"
                
                top_k: 5-8
                diversity: "balanced"
                query_breadth: "focused"
              
              example:
                clarity: 55%
                steve_query: "ìŒì•… êµ¬ë… ì„œë¹„ìŠ¤ íŒ¨í„´"  # êµ¬ì²´
                results: subscription_model ì¤‘ì‹¬
                purpose: "íŒ¨í„´ ê²€ì¦, ì‚¬ë¡€ í•™ìŠµ"
            
            clarity_70_95:
              name: "Execution Mode"
              
              rag_config:
                chunking_level:
                  albert: "micro"
                  steve: "case"
                  bill: "metric"
                
                top_k: 3-5
                diversity: "low (ìœ ì‚¬ë„ ìš°ì„ )"
                query_breadth: "precise"
              
              example:
                clarity: 88%
                steve_query: "Spotify í•œêµ­ ì‹œì¥ í”„ë¦¬ë¯¸ì—„ ì „í™˜ìœ¨"  # ì •ë°€!
                results: ì •í™•í•œ ë©”íŠ¸ë¦­ 1-2ê°œ
                purpose: "ì‹¤í–‰ ê³„íš ìˆ˜ë¦½"
          
          stewart_clarity_monitoring:
            track_progress:
              frequency: "ë§¤ checkpoint"
              expected_growth: "+15-25% per phase"
              
              alert_conditions:
                stagnation:
                  trigger: "3ê°œ ì¿¼ë¦¬ ë™ì•ˆ clarity ë³€í™” < 5%"
                  message: "ëª…í™•ë„ ì •ì²´. ë‹¤ë¥¸ ì ‘ê·¼ í•„ìš”"
                
                regression:
                  trigger: "clarity ê°ì†Œ"
                  message: "ëª…í™•ë„ í›„í‡´. ë°©í–¥ ì¬ê²€í† "
                
                overconfidence:
                  trigger: "1íšŒ ì¿¼ë¦¬ë¡œ +40%"
                  message: "ê¸‰ê²©í•œ ìƒìŠ¹. ê³¼ì‹  ìœ„í—˜"

# ========================================
# State Machine Integration
# @section: state_machine
# ========================================

state_machine_integration:
  _umis_reference: "information_flow_state_machine"
  _description: "UMIS 7-state workflowë¥¼ RAGì— í†µí•©"
  
  states_rag_mapping:
    
    state_1_discovery:
      umis_definition:
        active_agents: "all_parallel"
        duration: "2ì‹œê°„ (fast) / 1-3ì¼ (full)"
        purpose: "ë°©í–¥ì„± íƒìƒ‰ ë° ìˆ˜ë ´"
      
      rag_strategy:
        mode: "broad_exploration"
        
        all_agents_parallel:
          albert:
            queries: ["ì‹œì¥ êµ¬ì¡° íŒ¨í„´", "ê²½ìŸ ì—­í•™", "íŠ¸ë Œë“œ"]
            chunking: "macro"
            top_k: 15
          
          steve:
            queries: ["ê¸°íšŒ íŒ¨í„´ ìŠ¤ìº”", "ê°€ëŠ¥í•œ ëª¨ë¸ë“¤"]
            chunking: "pattern"
            top_k: 15
          
          bill:
            queries: ["ì‹œì¥ ê·œëª¨ ë²”ìœ„", "ì„±ì¥ë¥  íŒ¨í„´"]
            chunking: "report"
            top_k: 10
          
          rachel:
            queries: ["ì£¼ìš” ë°ì´í„° ì†ŒìŠ¤", "í†µê³„ ì¶œì²˜"]
            chunking: "source"
            top_k: 10
        
        convergence_checkpoint:
          after: "4-6ì‹œê°„"
          
          stewart_synthesis:
            - collect: "5ê°œ agent ë°œê²¬ì‚¬í•­"
            - vector_cluster: "ìœ ì‚¬ ë°œê²¬ ê·¸ë£¹í™”"
            - graph_connect: "ë°œê²¬ ê°„ ê´€ê³„ íŒŒì•…"
            - synthesize: "ê³µí†µ ë°©í–¥ì„± ë„ì¶œ"
          
          output: "ëª…í™•ë„ 40% â†’ 60% ë‹¬ì„±"
      
      quality_gate:
        criteria: "ë°©í–¥ì„± ìˆ˜ë ´"
        measurement: "5ê°œ agent ë°œê²¬ì˜ alignment > 70%"
        
        graph_check: |
          MATCH (a1:AlbertDiscovery), (s:SteveDiscovery), 
                (b:BillDiscovery)
          WITH [a1.direction, s.direction, b.direction] as directions
          RETURN avg(similarity(directions)) as convergence
          
          # convergence > 0.7 â†’ PASS
    
    state_2_structure_analysis:
      umis_definition:
        active_agents: ["albert"]
        support_available: ["bill", "rachel"]
        mandatory_validation: ["bill", "rachel", "stewart"]
      
      rag_strategy:
        mode: "focused_analysis"
        
        albert_lead:
          queries: "êµ¬ì¡° ìš”ì†Œë³„ ì •ë°€ ë¶„ì„"
          chunking: "meso"
          top_k: 5
          depth: "deep"
        
        bill_rachel_support:
          mode: "on_demand"
          
          collaboration_pattern:
            albert_working:
              task: "ê°€ì¹˜ì‚¬ìŠ¬ ë¶„ì„ ì¤‘"
              question: "Bill, ê° ë‹¨ê³„ ë§ˆì§„ìœ¨ì€?"
              
              rag_trigger:
                bill_search:
                  query: "ê°€ì¹˜ì‚¬ìŠ¬ ë§ˆì§„ìœ¨"
                  filter: "bill_view_type='quantitative'"
                  immediate: true
          
        mandatory_validation_checkpoint:
          trigger: "Albert ìµœì¢… ê²°ë¡  ì œì‹œ"
          
          validation_sequence:
            - bill_search:
                query: "Albert ê²°ë¡ ì˜ ì •ëŸ‰ ê·¼ê±°"
                graph: "(AlbertConclusion)-[:REQUIRES_VALIDATION]->(BillData)"
            
            - rachel_search:
                query: "Bill ë°ì´í„°ì˜ ì¶œì²˜"
                graph: "(BillData)-[:SOURCED_FROM]->(Source)-[:VERIFIED_BY]->(Rachel)"
            
            - stewart_search:
                index: "validation_rules"
                query: "Albert êµ¬ì¡° ë¶„ì„ í•„ìˆ˜ ê·œì¹™"
                check: "ëª¨ë“  ê·œì¹™ ë§Œì¡±?"
          
          pass_criteria: "3ëª… ëª¨ë‘ í†µê³¼"
          fail_action: "Albert ì¬ì‘ì—…"
      
      quality_gate:
        criteria: "3ëª… ê²€ì¦ í†µê³¼"
        
        graph_check: |
          MATCH (a:AlbertConclusion {id: $conclusion_id})
                -[:VERIFIED_BY]->(v1:BillValidation {passed: true}),
                (a)-[:VERIFIED_BY]->(v2:RachelValidation {passed: true}),
                (a)-[:VERIFIED_BY]->(v3:StewartValidation {passed: true})
          RETURN count(*) = 1 as checkpoint_passed
    
    state_3_opportunity_discovery:
      # ... Steve ì¤‘ì‹¬ (ê¸°ì¡´ ìœ ì‚¬)
      
      mandatory_validation_checkpoint:
        validators: ["albert", "bill", "rachel"]
        
        albert_reality_check:
          query: "Steve ê°€ì„¤ì´ ì‹œì¥ êµ¬ì¡°ìƒ ì‹¤í˜„ ê°€ëŠ¥í•œê°€?"
          
          rag_search:
            - albert_index: "structural constraints"
            - check: "Steve ê°€ì„¤ vs êµ¬ì¡°ì  ì œì•½"
          
          graph_check: |
            MATCH (s:SteveHypothesis)-[:ASSUMES]->(assumption)
            MATCH (a:AlbertConclusion)-[:IDENTIFIES]->(constraint)
            WHERE assumption CONFLICTS WITH constraint
            RETURN assumption, constraint as reality_gap
          
          fail_example: |
            Steve: "AI ì»¤í”¼ êµ¬ë… ì„œë¹„ìŠ¤"
            Albert: "ë§¤ì¥ ë°©ë¬¸ ê²½í—˜ì´ í•µì‹¬ ê°€ì¹˜"
            â†’ Conflict! Reality Check ì‹¤íŒ¨
    
    state_4_to_7:
      # quantification, synthesis, decision
      # (ë™ì¼ íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„)

# ========================================
# Collaboration Dual Structure
# @section: collaboration_modes
# ========================================

collaboration_dual_structure:
  _umis_principle: "ìì—°ìŠ¤ëŸ¬ìš´ ì¼ìƒ ì§€ì› + ì—„ê²©í•œ ì˜ë¬´ ê²€ì¦"
  
  mode_1_daily_support:
    _type: "optional"
    _trigger: "ììœ ë¡­ê²Œ (ì–¸ì œë“ )"
    _protocol: "ê°„ë‹¨ (ë³µì¡í•œ ì ˆì°¨ ì—†ìŒ)"
    
    implementation:
      natural_questions:
        examples:
          - "Bill, ì´ ì‹œì¥ ê·œëª¨ëŠ”?"
          - "Rachel, ë” ë‚˜ì€ ë°ì´í„° ìˆì–´?"
          - "Albert, ì´ êµ¬ì¡° ë§ì•„?"
        
        rag_execution:
          - no_formality: true
          - direct_search: "ì¦‰ì‹œ ê²€ìƒ‰"
          - quick_response: "ê°„ë‹¨í•œ ë‹µë³€"
          - no_validation: "ê²€ì¦ ì ˆì°¨ ì—†ìŒ"
        
        code_pattern: |
          # Albert ì‘ì—… ì¤‘
          albert_question = "Bill, í”Œë«í¼ ìˆ˜ìˆ˜ë£Œ ìˆ˜ìµì„±ì€?"
          
          # Bill retriever ì¦‰ì‹œ ì‹¤í–‰
          bill_answer = bill_retriever.search(
            query="í”Œë«í¼ ìˆ˜ìˆ˜ë£Œ ìˆ˜ìµì„±",
            filter={"bill_view_type": "calculation"},
            k=1
          )
          
          # Albertì—ê²Œ ë°”ë¡œ ë°˜í™˜ (ê°„ë‹¨!)
          return bill_answer[0].page_content
    
    frequent_patterns:
      albert_bill:
        when: "êµ¬ì¡° ë¶„ì„ ì¤‘ ì •ëŸ‰ ë°ì´í„° í•„ìš”"
        frequency: "ë†’ìŒ"
        formality: "ë‚®ìŒ"
      
      steve_bill:
        when: "ê¸°íšŒ ë°œêµ´ ì¤‘ ìˆ˜ìµì„± ê²€ì¦"
        frequency: "ë§¤ìš° ë†’ìŒ"
        formality: "ë‚®ìŒ"
      
      steve_rachel:
        when: "ê°€ì„¤ ê°œë°œ ì¤‘ ê·¼ê±° í™•ë³´"
        frequency: "ë†’ìŒ"
        formality: "ë‚®ìŒ"
  
  mode_2_mandatory_validation:
    _type: "required"
    _trigger: "4ê°œ ì²´í¬í¬ì¸íŠ¸ì—ì„œë§Œ"
    _protocol: "ì—„ê²© (ì „ì²´ ê²€ì¦ ì²´ì¸)"
    
    implementation:
      checkpoint_triggered:
        - checkpoint_1: "Albert êµ¬ì¡° ë¶„ì„ ì™„ë£Œ"
        - checkpoint_2: "Steve ê°€ì„¤ ìƒì„± ì™„ë£Œ"
        - checkpoint_3: "Bill SAM ê³„ì‚° ì™„ë£Œ"
        - checkpoint_4: "Owner ìµœì¢… ì˜ì‚¬ê²°ì •"
      
      validation_process:
        automatic_trigger:
          - detect: "agent.complete_deliverable()"
          - initiate: "Stewart ìë™ ê²€ì¦ ì‹œì‘"
          - notify: "í•„ìˆ˜ validatorsì—ê²Œ ì•Œë¦¼"
        
        parallel_validation:
          - all_validators: "ë™ì‹œ ê²€ì¦"
          - each_uses: "ìê¸° RAG index"
          - results: "Graphì— ì €ì¥"
        
        aggregation:
          - collect: "ëª¨ë“  validation ê²°ê³¼"
          - graph_check: "ì™„ê²°ì„± í™•ì¸"
          - final_decision: "í†µê³¼/ì‹¤íŒ¨"
        
        code_pattern: |
          # Albert ì™„ë£Œ ê°ì§€
          @albert.on_complete
          def trigger_checkpoint_1():
            # Stewart ìë™ ì‹œì‘
            stewart.initiate_validation(
              deliverable="albert_conclusion",
              validators=["bill", "rachel", "stewart"]
            )
            
            # ë³‘ë ¬ ê²€ì¦
            results = parallel_validate(
              bill=bill_validator.check(albert_conclusion),
              rachel=rachel_validator.check(albert_conclusion),
              stewart=stewart_validator.check(albert_conclusion)
            )
            
            # Graph ì €ì¥
            graph.create_validation_chain(results)
            
            # í†µê³¼ ì—¬ë¶€
            if all(r.passed for r in results.values()):
              transition_to("opportunity_discovery")
            else:
              request_revision(albert_conclusion, results)

# ========================================
# Additional UMIS-Specific Features
# @section: umis_features
# ========================================

umis_specific_enhancements:
  
  feature_1_10x_opportunity_detection:
    _umis_reference: "superior_opportunity í”¼ë²— íŠ¸ë¦¬ê±°"
    
    implementation:
      value_comparison:
        when: "Steveê°€ ìƒˆ ê¸°íšŒ ë°œê²¬"
        
        process:
          - current_opportunity: "í”„ë¡œì íŠ¸ ëª©í‘œ ì‹œì¥"
          - new_opportunity: "Steve ë°œê²¬ ì‹œì¥"
          
          - bill_calculation:
              current_tam: "Bill ê²€ìƒ‰"
              new_tam: "Bill ê²€ìƒ‰"
              ratio: "new / current"
          
          - threshold_check: "ratio >= 10"
        
        stewart_intervention:
          trigger: "ìë™ (10x ê°ì§€ ì‹œ)"
          level: "pivot"
          
          message: |
            ğŸ’¡ ì£¼ìš” ê¸°íšŒ ë°œê²¬ ì•Œë¦¼!
            
            í˜„ì¬ ëª©í‘œ: {current} (TAM: {current_tam})
            ìƒˆ ë°œê²¬: {new} (TAM: {new_tam})
            
            ê°€ì¹˜ ë¹„ìœ¨: {ratio}x (10ë°° ì´ìƒ!)
            
            í”¼ë²— ê²€í†  ê¶Œì¥:
              1. ê¸°ì¡´ íˆ¬ì vs ê¸°íšŒë¹„ìš©
              2. ìƒˆ ê¸°íšŒ ì‹¤í˜„ ê°€ëŠ¥ì„±
              3. íŒ€ ì—­ëŸ‰ ì í•©ì„±
            
            Owner ì˜ì‚¬ê²°ì • í•„ìš”!
          
          owner_escalation: true
          pause_current_work: true
      
      graph_tracking:
        create: "(CurrentGoal)-[:COMPARED_WITH {ratio: 12}]->(NewOpportunity)"
        decision: "(Owner)-[:DECIDES {choice: 'pivot'}]->(NewOpportunity)"
  
  feature_2_rachel_definition_validation:
    _umis_principle: "ë¶ˆëª…í™•í•œ ì •ì˜ëŠ” ì‚¬ìš© ê¸ˆì§€"
    
    implementation:
      definition_gap_analysis:
        when: "Billì´ ë°ì´í„° ì‚¬ìš© ì „"
        
        mandatory_check:
          - bill_query: "í•™ìŠµì ìˆ˜ ë°ì´í„°"
          - rachel_search: "í•™ìŠµì ì •ì˜"
          
          - definition_found:
              - "í•™ìŠµì = ì—° 1íšŒ ì´ìƒ ìˆ˜ì—…"
              - "í•™ìŠµì = ì£¼ 1íšŒ ì´ìƒ"
              - "í•™ìŠµì = ë“±ë¡ì"
              
              gap_analysis: |
                ì •ì˜ ë¶ˆì¼ì¹˜ ë°œê²¬!
                
                ìš°ë¦¬ ëª©ì : "ì ì¬ êµ¬ë… ê³ ê°"
                â†’ ì •ì˜ í•„ìš”: "ì£¼ 1íšŒ ì´ìƒ"
                
                ì •ë¶€ í†µê³„ ì •ì˜: "ì—° 1íšŒ ì´ìƒ"
                â†’ Gap: 3ë°° ì°¨ì´ ê°€ëŠ¥
                
                ì¡°ì¹˜: ì •ì˜ ì¡°ì • ë° íˆ¬ëª… ê³µê°œ
          
          - stop_calculation: "ì •ì˜ ëª…í™•í•´ì§ˆ ë•Œê¹Œì§€ Bill ì¤‘ë‹¨"
          - rachel_clarify: "ì •ì˜ í™•ì •"
          - resume: "Bill ê³„ì‚° ì¬ê°œ"
      
      transparency:
        all_adjustments:
          - record: "ì¡°ì • ë‚´ìš© ê¸°ë¡"
          - trace: "Graphì— ì €ì¥"
          - report: "source_registry.yamlì— ëª…ì‹œ"
        
        graph: |
          (Data {value: "750ë§Œ"})-[:ORIGINAL_DEFINITION]->(Def1 {text: "ì—°1íšŒ"})
          (Data)-[:ADJUSTED_TO]->(Def2 {text: "ì£¼1íšŒ", adjusted_value: "250ë§Œ"})
          (Adjustment)-[:REASON]->(Purpose {text: "ì ì¬ êµ¬ë… ê³ ê°"})
          (Adjustment)-[:TRANSPARENT_IN]->(SourceRegistry)
  
  feature_3_deliverable_standards:
    _umis_reference: "umis_deliverable_standards_v6.2.yaml"
    
    rachel_source_registry:
      auto_generation:
        trigger: "í”„ë¡œì íŠ¸ ì¢…ë£Œ ì‹œ"
        
        graph_query: |
          MATCH (data:Data)-[:SOURCED_FROM]->(src:Source)
                -[:VERIFIED_BY]->(rachel:RachelVerification)
          RETURN DISTINCT 
                 src.id as SRC_ID,
                 src.type as source_type,
                 src.url as url,
                 src.reliability as reliability,
                 collect(data.field) as used_in
          ORDER BY src.id
        
        output: "source_registry.yaml ìë™ ìƒì„±"
    
    bill_estimation_tracking:
      auto_documentation:
        when: "Billì´ ì¶”ì • ì‚¬ìš©"
        
        create_chunk:
          chunk_id: "{EST_ID}_documentation"
          content: |
            [EST_001] í”¼ì•„ë…¸ í•™ì› ë¹„ì¤‘ 30%
            
            [1] ì¶”ì • í•„ìš” ì´ìœ 
            [2] ì‚¬ìš© ë°ì´í„° (SRC_ID)
            [3] ì¶”ì • ë…¼ë¦¬ (ë‹¨ê³„ë³„)
            [4] ì‹ ë¢°ë„ í‰ê°€
            [5] ê²€ì¦ ë°©ë²•
            [6] ëŒ€ì²´ ì ‘ê·¼ë²•
            [7] ì‚¬ìš© ìœ„ì¹˜
          
          metadata:
            agent_view: "bill"
            bill_view_type: "calculation"
            bill_est_id: "EST_001"
        
        graph_link: |
          (BillCalculation)-[:USES_ESTIMATION {est_id: 'EST_001'}]->(EstimationDoc)
          (EstimationDoc)-[:DOCUMENTS]->(Logic)
          (EstimationDoc)-[:REFERENCES]->(Source)

# ========================================
# Implementation Priority
# @section: priorities
# ========================================

implementation_priorities:
  
  p0_critical:
    _must_have: "UMIS ë³¸ì§ˆ êµ¬í˜„ ë¶ˆê°€ëŠ¥"
    
    items:
      - name: "ìˆœí™˜ íŒ¨í„´ ê°ì§€"
        reason: "Stewart í•µì‹¬ ì—­í• "
        without: "ë¬´í•œ ë£¨í”„ ìœ„í—˜"
        effort: "3ì¼"
      
      - name: "ëª©í‘œ ì •ë ¬ë„ ëª¨ë‹ˆí„°ë§"
        reason: "ëª©í‘œ ì§€í–¥ ë³´ì¥"
        without: "ì‘ì—… ì´íƒˆ ë°©ì§€ ë¶ˆê°€"
        effort: "2ì¼"
      
      - name: "ê²€ì¦ ì²´ì¸ Graph"
        reason: "ê·¼ê±° ì¶”ì  í•„ìˆ˜"
        without: "ê²€ì¦ ë¶ˆê°€ëŠ¥"
        effort: "5ì¼"
  
  p1_important:
    _should_have: "UMIS í’ˆì§ˆì— ì¤‘ìš”"
    
    items:
      - name: "ëª…í™•ë„ ì§„í™” ì¶”ì "
        reason: "Adaptive Intelligence"
        without: "ì ì‘ ë¶ˆê°€"
        effort: "3ì¼"
      
      - name: "ìƒíƒœ ê¸°ê³„ í†µí•©"
        reason: "ì²´ê³„ì  í”„ë¡œì„¸ìŠ¤"
        without: "ë¹„íš¨ìœ¨"
        effort: "4ì¼"
      
      - name: "ì˜ë¬´ ê²€ì¦ ìë™í™”"
        reason: "4ê°œ ì²´í¬í¬ì¸íŠ¸"
        without: "ìˆ˜ë™ ê²€ì¦"
        effort: "3ì¼"
  
  p2_nice_to_have:
    _could_have: "í–¥í›„ í™•ì¥"
    
    items:
      - name: "10x ê¸°íšŒ ìë™ ê°ì§€"
        effort: "2ì¼"
      
      - name: "Rachel ì°½ì˜ì  ì†Œì‹±"
        effort: "3ì¼"
      
      - name: "ê°•í™”í•™ìŠµ ìµœì í™”"
        effort: "5ì¼"

# ========================================
# Revised Roadmap
# @section: revised_roadmap
# ========================================

revised_development_roadmap:
  
  week_1_knowledge_graph_core:
    focus: "Graph ê¸°ë³¸ + ìˆœí™˜/ëª©í‘œ ê°ì§€"
    
    day_1_2:
      - "Neo4j ì„¤ì •"
      - "ê¸°ë³¸ ë…¸ë“œ/ê´€ê³„ ìŠ¤í‚¤ë§ˆ"
      - "ìˆœí™˜ ê°ì§€ query_history DB"
      - "ëª©í‘œ ì •ë ¬ë„ ì¸¡ì • êµ¬í˜„"
    
    day_3_4:
      - "íŒ¨í„´ ê´€ê³„ 30ê°œ ì •ì˜"
      - "ê²€ì¦ ì²´ì¸ ê´€ê³„"
      - "ìˆœí™˜ ê°ì§€ ì•Œê³ ë¦¬ì¦˜"
    
    day_5_6:
      - "Hybrid ê²€ìƒ‰ ì—”ì§„"
      - "ëª©í‘œ ì •ë ¬ë„ ëª¨ë‹ˆí„°ë§"
      - "Stewart ê°œì… ë¡œì§"
    
    day_7:
      - "í†µí•© í…ŒìŠ¤íŠ¸"
      - "ìˆœí™˜ ì‹œë‚˜ë¦¬ì˜¤ ê²€ì¦"
    
    deliverables:
      - umis_rag/graph/knowledge_graph.py
      - umis_rag/graph/circular_detector.py  # ğŸ†•
      - umis_rag/graph/goal_alignment.py     # ğŸ†•
  
  week_2_stewart_meta_rag:
    focus: "ê²€ì¦ ìë™í™” + ìƒíƒœ ê¸°ê³„"
    
    day_1_3:
      - "ê²€ì¦ ê·œì¹™ index"
      - "í’ˆì§ˆ íŒ¨í„´ index"
      - "3ë‹¨ê³„ ê²€ì¦ ì—”ì§„"
      - "ìƒíƒœ ê¸°ê³„ í†µí•©"  # ğŸ†•
    
    day_4_5:
      - "ì˜ë¬´ ê²€ì¦ ìë™í™”"  # ğŸ†•
      - "4ê°œ ì²´í¬í¬ì¸íŠ¸ êµ¬í˜„"
      - "Graph ì™„ê²°ì„± ê²€ì¦"
    
    day_6_7:
      - "Stewart ì¢…í•© í…ŒìŠ¤íŠ¸"
      - "ê²€ì¦ ì‹œë‚˜ë¦¬ì˜¤ ì „ì²´"
  
  week_3_adaptive_learning:
    focus: "ëª…í™•ë„ ì ì‘ + í”¼ë“œë°± í•™ìŠµ"
    
    day_1_2:
      - "ëª…í™•ë„ ì¸¡ì • ì‹œìŠ¤í…œ"  # ğŸ†•
      - "ì ì‘í˜• RAG ì „ëµ"   # ğŸ†•
      - "Query refinement"
    
    day_3_4:
      - "Weighted retrieval"
      - "í”¼ë“œë°± DB"
      - "í•™ìŠµ í†µí•©"
    
    day_5_7:
      - "ì „ì²´ í†µí•©"
      - "ì„±ëŠ¥ ìµœì í™”"
      - "ë¬¸ì„œí™”"

# ========================================
# Success Criteria (UMIS-Aligned)
# @section: success_criteria
# ========================================

umis_aligned_success_criteria:
  
  criterion_1_evidence_chain:
    name: "ëª¨ë“  ê°€ì„¤ì— ì™„ì „í•œ ê·¼ê±° ì²´ì¸"
    
    measurement: |
      MATCH path = (h:SteveHypothesis)-[:BASED_ON|REQUIRES_VALIDATION*1..10]->(src:Source)
      WHERE ALL(n in nodes(path) WHERE n.validated = true)
      RETURN count(h) as complete_hypotheses,
             count(h) * 1.0 / total_hypotheses as completeness_ratio
    
    target: "100%"
    critical: true
  
  criterion_2_circular_prevention:
    name: "ìˆœí™˜ íŒ¨í„´ ì¡°ê¸° ê°ì§€ ë° í•´ê²°"
    
    measurement:
      - detection_rate: "3íšŒ ë°˜ë³µ ì‹œ 100% ê°ì§€"
      - resolution_time: "< 1ì‹œê°„"
      - recurrence: "ê°™ì€ ì£¼ì œ ì¬ë°œ < 5%"
    
    target: "detection 100%, resolution < 1h"
    critical: true
  
  criterion_3_goal_alignment:
    name: "ëª©í‘œ ì •ë ¬ë„ ì§€ì† ìœ ì§€"
    
    measurement:
      - avg_alignment: "í”„ë¡œì íŠ¸ ì „ì²´ í‰ê·  > 70%"
      - deviation_duration: "< 60% ì§€ì† ì‹œê°„ < 2ì‹œê°„"
      - correction_success: "ì •ë ¬ë„ íšŒë³µìœ¨ > 90%"
    
    target: "í‰ê·  70%, ì´íƒˆ < 2h"
    critical: true
  
  criterion_4_clarity_progression:
    name: "ëª…í™•ë„ ì ì§„ì  í–¥ìƒ"
    
    measurement:
      - start: "20-30%"
      - per_phase_growth: "+15-25%"
      - final: "> 85%"
      - regression_count: "< 1íšŒ"
    
    target: "20% â†’ 85%, no regression"
    important: true
  
  criterion_5_validation_automation:
    name: "ì²´í¬í¬ì¸íŠ¸ ìë™í™”"
    
    measurement:
      - manual_intervention: "< 10%"
      - validation_time: "< 5ë¶„"
      - accuracy: "> 95% vs ì‚¬ëŒ íŒë‹¨"
    
    target: "90% ìë™í™”, 95% ì •í™•ë„"
    important: true

# ========================================
# END OF ENHANCED ARCHITECTURE
# ========================================

