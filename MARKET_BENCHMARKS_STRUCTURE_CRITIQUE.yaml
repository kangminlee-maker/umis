# market_benchmarks 메타데이터 구조 비판
# Guestimation 용도에 적합한가?

meta:
  version: "1.0"
  date: "2025-11-07"
  purpose: "market_benchmarks 구조 분석 및 개선 제안"

---

# ═══════════════════════════════════════════════════════
# PART 1: 현재 구조 분석
# ═══════════════════════════════════════════════════════

current_structure:
  
  실제_데이터_예시:
    
    benchmark_id: "BMK_SAAS_001"
    metric: "Monthly Churn Rate (B2B SaaS)"
    category: "retention"
    
    validation_status: "Verified"
    verified_date: "2025-11-04"
    
    external_sources:
      - name: "ProfitWell"
        value: "3-8%"  ← 값 1
        note: "B2B SaaS 평균"
      - name: "Recurly"
        value: "3.5%"  ← 값 2
    
    confidence: "High (A)"
    
    benchmarks:
      excellent: "< 1%"
      good: "1-2%"
      acceptable: "2-5%"
      poor: "> 5%"
    
    industry_average: "3.2%"  ← 값 3
    top_quartile: "< 1.5%"
    
    company_examples:
      - company: "Salesforce"
        value: "0.9%"  ← 값 4
      - company: "Adobe"
        value: "1.2%"  ← 값 5
    
    factors:
      reduces_churn: [...]
      increases_churn: [...]
    
    source: [...]
  
  문제점:
    
    1_값이_여러_곳에_흩어짐:
      
      가능한_값들:
        - external_sources[0].value: "3-8%"
        - external_sources[1].value: "3.5%"
        - industry_average: "3.2%"
        - company_examples[0].value: "0.9%"
        - company_examples[1].value: "1.2%"
      
      질문: "어느 것이 '값'인가?"
      
      답변: 불명확! ❌
      
      문제:
        - 용도에 따라 다름
        - Guestimation은 "대표값" 필요
        - 하지만 명시 안 됨
    
    2_추출_로직_복잡:
      
      현재_구현:
        1. global_benchmark.median 시도
        2. value 필드 시도
        3. content 정규식 파싱
        
        모두_실패_가능!
      
      필요한_것:
        "이_벤치마크의_대표값은_X"
        
        단순_명확!
    
    3_용도_불일치:
      
      Quantifier_용도:
        - SAM 계산 시 참고
        - 풍부한 맥락 필요
        - 등급별 기준 (excellent, good, ...)
        - 영향 요인
        
        → 분석용, 맥락 중요
      
      Guestimation_용도:
        - 빠른 값 추출
        - 대표값 1개만 필요
        - 맥락 최소
        
        → 검색용, 속도 중요
      
      충돌! ❌

---

# ═══════════════════════════════════════════════════════
# PART 2: 설계 평가
# ═══════════════════════════════════════════════════════

design_evaluation:
  
  장점:
    
    ✅ 풍부한_정보:
      - 여러 출처
      - 등급 기준
      - 회사 사례
      - 영향 요인
      
      가치: Quantifier 분석에 최적
    
    ✅ 추적성:
      - 출처 명시
      - 검증 상태
      - 날짜
      
      가치: 신뢰도 판단
    
    ✅ 맥락:
      - 등급별 해석
      - 영향 요인
      
      가치: 이해도 향상
  
  단점:
    
    ❌ 값_추출_어려움:
      - 여러 곳에 흩어짐
      - "대표값"이 뭔지 불명확
      - 파싱 로직 복잡
      
      영향: Guestimation 활용 어려움
    
    ❌ 형식_불일치:
      - "3-8%" (범위)
      - "3.5%" (값)
      - "< 1%" (부등호)
      
      파싱: 케이스별 다름
    
    ❌ 용도_혼재:
      - 분석용 (Quantifier)
      - 검색용 (Guestimation)
      
      최적화: 어느 쪽도 아님

---

# ═══════════════════════════════════════════════════════
# PART 3: 개선 방안
# ═══════════════════════════════════════════════════════

improvement_options:
  
  옵션_1_필드_추가:
    
    제안: "representative_value 필드 추가"
    
    개선된_구조:
      benchmark_id: "BMK_SAAS_001"
      metric: "Monthly Churn Rate"
      
      # 기존 필드들...
      external_sources: [...]
      industry_average: "3.2%"
      company_examples: [...]
      
      # 신규 필드 ⭐
      representative_value:
        value: 0.032  # 소수 (3.2%)
        unit: "ratio"
        confidence: 0.80
        reasoning: "industry_average 기준"
        
        alternatives:
          median: 0.035
          mean: 0.040
          range: [0.03, 0.08]
    
    장점:
      ✅ 명확한 대표값
      ✅ 파싱 불필요
      ✅ 추출 간단
    
    단점:
      ❌ YAML 수정 필요
      ❌ 기존 100개 모두 업데이트
      ❌ 작업량 많음
  
  옵션_2_Projection_활용:
    
    제안: "guestimation view projection"
    
    원리:
      Canonical (market_benchmarks):
        - 현재 구조 그대로 (풍부함 유지)
        - Quantifier 용도
      
      Projected (guestimation view):
        - 단순화된 구조
        - 대표값만 추출
        - Guestimation 용도
    
    Projection_Rule:
      field_rules:
        market_benchmarks:
          agent_view: [quantifier, guestimation]
          
          guestimation_projection:
            extract:
              - field: "industry_average"
                → guestimation_value
              
              - field: "external_sources[0].value"
                → guestimation_range
              
              - field: "metric"
                → guestimation_metric
            
            normalize:
              - "3-8%" → value: 0.055, range: [0.03, 0.08]
              - "3.5%" → value: 0.035
    
    결과_projected_metadata:
      agent_view: "guestimation"
      
      guestimation_metric: "churn_rate"
      guestimation_value: 0.032
      guestimation_range: [0.03, 0.08]
      guestimation_unit: "ratio"
      guestimation_confidence: 0.80
    
    장점:
      ✅ YAML 수정 불필요
      ✅ 자동 변환
      ✅ 양쪽 용도 모두 최적
      ✅ 아키텍처 일관성
    
    단점:
      ❌ Projection 로직 필요
      ❌ 구현 복잡도 증가
  
  옵션_3_파싱_로직_고도화:
    
    제안: "현재 구조 유지, 파싱만 개선"
    
    스마트_파싱:
      우선순위:
        1. industry_average (가장 대표적)
        2. external_sources[0].value (첫 번째 출처)
        3. global_benchmark.median (있으면)
        4. company_examples 평균
      
      정규화:
        "3-8%" → 0.055 (중앙값)
        "3.5%" → 0.035
        "< 1%" → 0.01 (상한의 절반)
        "> 5%" → 0.06 (하한 + 20%)
    
    장점:
      ✅ YAML 수정 불필요
      ✅ 구현 간단
    
    단점:
      ❌ 여전히 복잡
      ❌ 휴리스틱 (불완전)
      ❌ 에러 가능성

---

# ═══════════════════════════════════════════════════════
# PART 4: 근본적 질문
# ═══════════════════════════════════════════════════════

fundamental_questions:
  
  질문_1_목적의_차이:
    
    Quantifier:
      목적: "SAM 계산, 깊은 분석"
      필요: "풍부한 맥락, 등급 기준, 사례"
      사용: "LLM이 이해하고 분석"
    
    Guestimation:
      목적: "빠른 값 추출"
      필요: "단순 명확, 대표값 하나"
      사용: "즉시 사용 가능한 숫자"
    
    결론:
      용도가_다름:
        - 같은 데이터를 공유하는 게 맞나?
        - 아니면 각자 최적화?
  
  질문_2_데이터_vs_메타데이터:
    
    현재:
      모든_정보가_메타데이터:
        - external_sources
        - company_examples
        - factors
        
        → page_content는 거의 비어있음
    
    문제:
      메타데이터_검색:
        - ChromaDB는 content 임베딩 검색
        - metadata는 필터링용
        
        풍부한_정보가_content에_없음:
          → 검색 품질 ↓?
    
    대안:
      page_content_채우기:
        content: |
          SaaS Monthly Churn Rate
          
          산업 평균: 3.2%
          우수 기준: < 1%
          
          출처: ProfitWell 3-8%, Recurly 3.5%
          
          사례: Salesforce 0.9%, Adobe 1.2%
          
          영향 요인: 온보딩 강화 시 감소
        
        → 검색 품질 ↑
        → 하지만 구조화 ↓

---

# ═══════════════════════════════════════════════════════
# PART 5: 권장 개선안
# ═══════════════════════════════════════════════════════

recommended_improvements:
  
  단기_해결:
    
    옵션_3_파싱_고도화:
      
      이유:
        - YAML 수정 없음
        - 빠른 적용
        - 현실적
      
      구현:
        def _extract_value_from_metadata(metadata, content):
          # 우선순위 명확히
          
          # 1순위: industry_average (가장 대표적)
          if 'industry_average' in metadata:
            return parse(metadata['industry_average'])
          
          # 2순위: global_benchmark.median
          if 'global_benchmark' in metadata:
            if 'median' in metadata['global_benchmark']:
              return parse(metadata['global_benchmark']['median'])
          
          # 3순위: external_sources[0].value
          if 'external_sources' in metadata:
            if len(metadata['external_sources']) > 0:
              return parse(metadata['external_sources'][0]['value'])
          
          # 4순위: company_examples 평균
          if 'company_examples' in metadata:
            values = [parse(ex['value']) for ex in metadata['company_examples']]
            return mean(values)
          
          # 5순위: content 정규식
          return parse_from_content(content)
      
      효과:
        - 대부분 케이스 커버
        - 명확한 우선순위
        - 합리적 fallback
  
  장기_해결:
    
    옵션_2_Projection:
      
      이유:
        - 아키텍처 일관성
        - 용도별 최적화
        - 자동화
      
      단계:
        1. Canonical 유지 (market_benchmarks)
        2. Projection Rule 정의
        3. Projected View 생성 (guestimation)
      
      Projection_Rule:
        market_benchmarks_projection:
          target_agent: "guestimation"
          
          extract_logic:
            value:
              priority:
                - "industry_average"
                - "global_benchmark.median"
                - "external_sources[0].value"
              
              normalize: true  # "3.2%" → 0.032
            
            range:
              from: "external_sources[0].value" if range형태
              normalize: true
            
            confidence:
              from: "confidence" field
              mapping:
                "High (A)": 0.85
                "Medium": 0.70
                "Low": 0.50
      
      효과:
        - 자동 변환
        - guestimation view는 단순
        - 검색 최적화
      
      시점: "학습 시스템 구현 시 함께"

---

# ═══════════════════════════════════════════════════════
# PART 6: 최종 권장
# ═══════════════════════════════════════════════════════

final_recommendation:
  
  현재_MVP:
    
    선택: "옵션_3 (파싱 고도화)" ✅
    
    이유:
      - 즉시 작동 (이미 구현됨)
      - YAML 수정 없음
      - 현실적
    
    구현:
      _extract_value_from_metadata:
        - 우선순위 명확화
        - industry_average 우선
        - fallback 체인
    
    시간: 30분
  
  향후_개선:
    
    선택: "옵션_2 (Projection)"
    
    시점: "학습 시스템 구현 시"
    
    이유:
      - 아키텍처 일관성
      - Canonical-Projected 활용
      - 자동화
      - 용도별 최적화
    
    구현:
      1. config/projection_rules.yaml 확장
      2. market_benchmarks → guestimation view
      3. 자동 정규화
    
    시간: 1일
  
  구조_개선_제안:
    
    미래_버전:
      
      market_benchmarks_v2:
        
        benchmark_id: "BMK_SAAS_001"
        metric: "churn_rate"
        
        # 신규: Guestimation 전용 필드 ⭐
        quick_reference:
          value: 0.032  # 정규화된 숫자
          range: [0.03, 0.08]
          unit: "ratio"
          confidence: 0.80
          source: "industry_average"
        
        # 기존: Quantifier 풍부한 정보
        detailed_analysis:
          external_sources: [...]
          company_examples: [...]
          benchmarks: [...]
          factors: [...]
      
      효과:
        - 양쪽 용도 모두 최적
        - 값 추출 간단
        - 맥락 유지
      
      트레이드오프:
        - 구조 복잡도 증가
        - 하지만 명확성 ↑

---

# ═══════════════════════════════════════════════════════
# PART 7: 평가
# ═══════════════════════════════════════════════════════

evaluation:
  
  현재_구조_평가:
    
    Quantifier_관점: 10/10
      - 풍부함 ✅
      - 맥락 ✅
      - 추적성 ✅
    
    Guestimation_관점: 5/10
      - 값 추출 어려움 ❌
      - 파싱 복잡 ❌
      - 불명확 ❌
    
    종합: 7/10
      - 한 쪽에 최적화
      - 다른 쪽은 타협
  
  개선_후_예상:
    
    옵션_1_필드_추가:
      Quantifier: 10/10 (변화 없음)
      Guestimation: 9/10 (크게 개선)
      종합: 9.5/10
      
      하지만: YAML 수정 필요
    
    옵션_2_Projection:
      Quantifier: 10/10
      Guestimation: 10/10 (완벽)
      종합: 10/10
      
      하지만: 구현 필요
    
    옵션_3_파싱:
      Quantifier: 10/10
      Guestimation: 7/10 (약간 개선)
      종합: 8.5/10
      
      장점: 즉시 가능
  
  결론:
    
    현재_MVP: 옵션_3 ✅
      - 작동은 함
      - 완벽하진 않음
      - 허용 가능
    
    향후: 옵션_2 (Projection)
      - 학습 시스템과 함께
      - 아키텍처 일관성
      - 완벽한 해결

---

# ═══════════════════════════════════════════════════════
# END - 구조 비판 완료
# ═══════════════════════════════════════════════════════

