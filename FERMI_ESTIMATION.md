# Guestimation Framework

**버전**: 1.0  
**작성일**: 2025-11-04  
**적용**: UMIS 전체 (모든 Agent)

---

## 📘 정의

**Guestimation**: 기초적인 지식과 논리적 추론만으로 짧은 시간 안에 대략적인 근사치를 추정하는 방법

## 🎯 핵심 철학

> "정확하지 않아도 괜찮다. 하지만 근거 없이 추정하면 안 된다."

### 언제 사용하나?

- ✅ 직접 데이터가 없을 때
- ✅ 정확한 값을 알 수 없을 때
- ✅ 짧은 시간 내 판단이 필요할 때

### 언제 사용하지 말아야 하나?

- ❌ 직접 데이터가 있을 때
- ❌ 정확한 값이 필수일 때
- ❌ 추정 불가능할 때 (억지로 추정하지 말것)

---

## 🔧 세 가지 추정 방법

### 방법 1: Benchmark-based (벤치마크 기반)

**접근**: 유사 사례를 찾아서 적용

```yaml
프로세스:
  1. RAG/외부에서 유사 벤치마크 검색
  2. 비교 가능성 검증 (4대 기준)
  3. 채택된 벤치마크 기반 추론

적용 사례:
  - 전환율 (유사 서비스 참고)
  - Churn Rate (업계 평균)
  - 시장 점유율

장점: 실제 데이터 기반, 신뢰도 높음
단점: 유사 사례 없으면 불가능
```

### 방법 2: Decomposition-based (분해 기반) ⭐ 신규!

**접근**: 문제를 작은 단위로 분해하여 계산

```yaml
프로세스:
  1. 목표를 구성 요소로 분해
  2. 각 요소를 상식/경험으로 추정
  3. 재조립하여 전체 계산

적용 사례:
  - 여행 지출 = 인원 × (교통비 + 식비 + 숙박비)
  - 시장 규모 = 고객 수 × 구매 빈도 × 객단가

장점: 벤치마크 없어도 가능, 논리 명확
단점: 각 요소 추정 필요

핵심:
  - First Principles (근본 원리)
  - 상식 + 경험 활용
  - 논리적 분해 구조
```

### 방법 3: Constraint-based (제약조건 기반) ⭐ 신규!

**접근**: 물리적/시간적 제약조건으로 역산

```yaml
프로세스:
  1. 공급 제약 식별 (시간, 용량, 물리적 한계)
  2. 수요 = 공급 가정 (균형 상태)
  3. 제약조건으로 역산

적용 사례:
  - 자장면 배달량 = 중국집 × 요리사 × 시간 × 속도
  - 택시 시장 = 택시 대수 × 운행 시간 × 요금
  - 극장 매출 = 상영관 × 좌석 × 상영 횟수 × 가격

장점: 물리적 근거 명확, 검증 가능
단점: 제약조건 파악 필요

핵심:
  - Supply-Demand 균형
  - 시간 × 용량 계산
  - 물리적 한계 활용
```

### 방법 선택 가이드

```
1. 유사 사례가 있는가?
   YES → Benchmark-based
   NO → 다음 단계

2. 문제를 분해할 수 있는가?
   YES → Decomposition-based
   NO → 다음 단계

3. 공급 제약조건이 명확한가?
   YES → Constraint-based
   NO → 조합 사용

복합 사용:
  - Decomposition으로 분해
  - 일부 요소는 Benchmark
  - 일부 요소는 Constraint
```

---

## 🔑 두 가지 핵심 요소

### 1. 기초적인 지식 (Foundation Knowledge)

#### 1.1 프로젝트 데이터
- 주어진 모든 숫자들
- 확정된 사실들
- 검증된 데이터

#### 1.2 보편적 상식
- 대한민국 인구: 5,000만 (상식)
- 서울 인구: 1,000만 (상식)
- 고속버스 요금: 1.5~2만원 (상식)
- 식사 한 끼: 1만원 (일반적 경험)
- 수명: 80세 (상식)

#### 1.3 경험적 지식
- 테이블당 인원: 3명 (경험)
- 음식점 테이블: 10개 (경험)
- 식사 시간: 30분 (경험)
- 중국집 요리사: 2명 (경험)
- 자장면 제조: 10분/4그릇 (경험)

#### 1.4 보편적 경험 (RAG)
- 업계 벤치마크
- 유사 사례
- 패턴/데이터

> **중요**: RAG는 1.4의 일부일 뿐! 1.2, 1.3도 똑같이 중요함

### 2. 논리적 추론 (Logical Reasoning)

#### 논리의 연결
- A → B → C 형태의 단계별 추론
- 각 단계의 근거 명확화

#### 합리적 가정
- "A와 B가 유사하다면..."
- "보수적으로 가정하면..."

#### 변수 제거
- 영향이 작은 변수 무시
- 상쇄되는 요소 제거

#### Boundary 설정
- 상한(Upper Bound): 아무리 높아도 이 이상은 불가능
- 하한(Lower Bound): 아무리 낮아도 이 이하는 불가능
- 현실적 범위: 실제로는 이 범위 내에 있을 것

---

## 📝 8단계 프로세스

### Step 1: 문제 명확화
```
- 추정해야 할 것: [무엇을 알고 싶은가?]
- 사용 목적: [왜 필요한가?]
- 필요 정확도: [±X% 이내면 충분한가?]
```

### Step 2: 기초 지식 수집 (RAG 활용)
```
프로젝트 데이터:
  - 확정된 숫자 1: [값]
  - 확정된 숫자 2: [값]

보편적 경험 (RAG 검색):
  - 후보 1: [데이터] ← RAG
  - 후보 2: [데이터] ← RAG
  - 후보 3: [데이터] ← RAG

⚠️ 주의: RAG에 있다고 모두 쓸 수 있는 것은 아님!
```

### Step 2.5: 비교 가능성 검증 ⭐ 필수!
```
각 후보 데이터에 대해:

후보 1: [데이터]
  ✓ 제품/서비스 속성: [동일/유사/다름]
  ✓ 소비 주체: [동일/유사/다름]
  ✓ 가격대: [동일/유사/다름]
  ✓ 구매 맥락: [동일/유사/다름]
  → 판단: [채택/기각]
  → 이유: [구체적 근거]

⚠️ 기각 기준:
  - 소비 주체 다름 (B2C vs B2B)
  - 제품 속성 다름 (물리적 vs 디지털)
  - 필수재 vs 선택재
  - 가격대 10배 이상 차이

✅ 채택 기준:
  - 4개 중 3개 이상 유사
  - 핵심 속성 일치
```

### Step 3: 추론 경로 설계
```
논리 흐름:
  1. A를 알고 있다
  2. A와 B의 관계는 [경험적으로] X이다
  3. 따라서 B ≈ A × X
```

### Step 4: 변수 단순화
```
무시 가능한 변수:
  - 변수 X: 영향 < 5% → 무시
```

### Step 5: Boundary 체크
```
상한: [절대 불가능한 최대값]
하한: [절대 불가능한 최소값]
현실 범위: [유사 사례들의 범위]
우리 추정: [Value] → 범위 내 ✓
```

### Step 6: 검증
```
Cross-check:
  - 다른 방법으로 계산하면?
  - 유사 사례와 비교하면?

Sensitivity:
  - 핵심 가정이 ±20% 변하면?
```

### Step 7: 대안 검토
```
시도했지만 실패한 방법:
  - 대안 1: [방법] → [결과]
  - 대안 2: [방법] → [결과]

현재 방법 선택 이유:
  - 가용 데이터로 최선
  - 시간 내 실행 가능
  - 검증 가능
```

### Step 8: 신뢰도 평가
```
Confidence Level:
  - High: 유사 데이터 많음, 논리 견고
  - Medium: 일부 가정 필요, 논리 타당
  - Low: 많은 가정, 데이터 부족

Error Range:
  - High → ±10%
  - Medium → ±20%
  - Low → ±30~50%
```

---

## 💡 실전 예시

### ✅ 예시 1: Benchmark-based (피아노 구독 전환율)

**방법**: 유사 사례 찾기

```yaml
Step 1 문제:
  추정 대상: 피아노 렌탈/구독 서비스 전환율
  사용 목적: Bottom-Up SAM 계산
  필요 정확도: ±20%

Step 2 기초 지식 수집:
  프로젝트 데이터:
    - 타겟: 피아노 구매 고려 고객
    - 가격: 월 50,000원
    - 제품: 물리적 악기
  
  RAG 검색 결과:
    후보 1: 정수기 구독률 25%
    후보 2: 공기청정기 렌탈률 18%
    후보 3: 음악 앱 구독률 30%
    후보 4: SaaS B2B 전환율 2-5%

Step 2.5 비교 가능성 검증: ⭐
  후보 2: 공기청정기 18%
    제품 유형: 물리적 ✓
    소비 주체: B2C ✓
    가격대: 3-5만원 ✓
    구매 맥락: 선택재 ✓
    → 판단: 채택 ✅ (4/4)
  
  후보 3: 음악 앱 30%
    제품 유형: 디지털 ✗
    → 판단: 기각 ❌
  
  최종: 공기청정기 18% 채택

Step 3 추론:
  피아노 ≈ 공기청정기 → 약간 보수적 → 15%

결론: 15% (±20%)
```

### ✅ 예시 2: Decomposition-based (휴일 여행 지출)

**방법**: 문제 분해 (벤치마크 없음!)

```yaml
Step 1 문제:
  추정 대상: 휴일 하루 증가 시 여행 지출 증가액

Step 2 문제 분해: ⭐
  총 지출 = 인원 × 1인당 지출
  1인당 지출 = 교통비 + 식비 + 숙박비

Step 3 각 요소 추정 (상식/경험):
  인원:
    - 인구: 5,000만 (상식)
    - 비율: 1/20 = 5% (가정)
    - 인원: 250만

  교통비:
    - 버스 편도: 1.5~2만원 (상식)
    - 왕복: 3.5만원

  식비:
    - 2끼 × 1만원 = 2만원 (경험)

  숙박비:
    - 1박: 4.5만원 (경험)

  1인당: 10만원

Step 4 재조립:
  250만 × 10만 = 2,500억원

Step 5 검증:
  Boundary: 500억 ~ 5,000억 → 2,500억 ✓
  
특징:
  ✅ 벤치마크 불필요
  ✅ 순수 논리 분해
  ✅ First Principles
```

### ✅ 예시 3: Constraint-based (자장면 배달량)

**방법**: 제약조건 역산 (가장 정교!)

```yaml
Step 1 문제:
  추정 대상: 2021년 서울 중국집 하루 자장면 배달량

Step 2 제약조건 식별:
  제약 1: 중국집 개수
  제약 2: 요리사 제조 용량
  제약 3: 운영 시간

Step 3 중국집 개수 역산: ⭐
  경제활동인구: 500만
  
  수요 = 공급 가정:
    - 점심 2시간, 식사 30분 → 4회전
    - 30분당 125만명 소화 필요
  
  필요 음식점:
    - 테이블당 3명, 음식점당 10테이블
    - 125만 / 30 = 약 4만개
  
  중국집:
    - 5개 종류로 균등 분배
    - 4만 / 5 = 8,000개

Step 4 제조 용량:
  요리사 2명 × 시간별 제조:
    - Peak (4h): 10분/4그릇 → 96그릇
    - Normal (3h): 10분/1그릇 → 18그릇
  
  중국집당: 66그릇/일

Step 5 외부 요인:
  COVID19: 배달 80%

Step 6 최종:
  8,000 × 66 × 80% = 42만 그릇

Step 7 검증:
  1,000만 인구 / 42만 = 24명 중 1명 ✓

특징:
  ✅ Supply 제약 역산
  ✅ 물리적 계산
  ✅ 시간 × 용량
```

### ❌ 나쁜 예시: RAG 맹신

```yaml
Step 2 RAG 검색:
  - "기타" 구독: 12% (guitar 오해)
  - 음악 앱: 18% (디지털 vs 물리적)
  - SaaS: 2-5% (B2B vs B2C)

Step 2.5 비교 가능성 검증: 누락! ⚠️

Step 3 추론:
  평균: (12% + 18%) / 2 = 15%

문제:
  ❌ 비교 불가능한 데이터 사용
  ❌ 논리 없이 평균
  ❌ 우연히 답 비슷할 뿐
```

---

## 🎓 핵심 원칙

### 원칙 1: 비교 가능성이 전제조건

```
⚠️ RAG에 있다고 모두 쓸 수 있는 것은 아님
⚠️ 키워드 매칭 ≠ 맥락 이해
⚠️ "데이터가 있다" ≠ "사용해야 한다"

✅ 비교 가능성 4대 기준:
  1. 제품/서비스 속성 (물리적/디지털)
  2. 소비 주체 (B2C/B2B)
  3. 가격대 (±3배 이내)
  4. 구매 맥락 (필수재/선택재)

→ 4개 중 3개 이상 유사해야 비교 가능
```

### 원칙 2: 논리 > 데이터

```
❌ "RAG에서 3개 찾았으니 평균"
✅ "A는 비교 가능, B는 불가. A 기반 추론"

→ 논리적으로 타당하면 데이터 1개도 충분
→ 논리 없으면 데이터 100개도 무의미
```

### 원칙 3: 명시적 기각

```
기각한 데이터도 문서화:
  - 후보 X: [데이터]
  - 기각 이유: [구체적 근거]

→ 왜 안 썼는지 설명 필요
→ 투명성과 재현 가능성 확보
```

### 원칙 4: 보수적 추정

```
불확실하면 낮게:
  - 시장 규모: 보수적
  - 전환율: 보수적
  - 성장률: 보수적

→ 과대 추정 < 과소 추정
→ "최소한 이 정도는 된다"
```

---

## ✅ 품질 기준

### Good Guestimation
- ✅ 비교 가능성 검증 완료 ⭐ (가장 중요!)
- ✅ 기각한 데이터도 명시
- ✅ 논리적 연결 명확
- ✅ 각 단계 근거 있음
- ✅ Boundary 체크 완료
- ✅ 대안 방법 고려함
- ✅ 검증 가능

### Bad Guestimation
- ❌ 비교 가능성 검증 없음 ⚠️ (치명적!)
- ❌ RAG 데이터 무조건 사용
- ❌ 키워드 매칭만으로 채택
- ❌ "그냥 20%로 가정"
- ❌ 근거 없는 평균
- ❌ 논리 비약
- ❌ Boundary 무시
- ❌ 검증 불가능

---

## 🔧 UMIS에서 사용법

### Agent별 활용

#### Quantifier (Bill)
- Market Sizing 추정
- 전환율, AOV, Frequency 추정
- 시장 필터 비율

#### Explorer (Steve)
- 기회 크기 추정
- TAM/SAM 대략 계산
- 트렌드 영향도

#### Validator (Rachel)
- 데이터 신뢰도 평가
- Error Range 계산
- Confidence Level 판단

#### Observer (Albert)
- 시장 구조 비율
- Value Chain 분배
- 경쟁 강도

### RAG 활용 (비판적 사고 필수)

```python
# ❌ 나쁜 예: RAG 결과를 그대로 사용
query = "음악 구독 전환율"
results = search_benchmarks(query)
value = average(results)  # 비교 불가능한 것 포함!

# ✅ 좋은 예: 비교 가능성 검증 후 사용
query = "제품 구독 서비스 전환율"
candidates = search_benchmarks(query)

# 1. 비교 가능성 검증
filtered = []
for candidate in candidates:
    if is_comparable(target, candidate):
        filtered.append(candidate)
        print(f"✅ 채택: {candidate.name}")
    else:
        print(f"❌ 기각: {candidate.name} - {이유}")

# 2. 채택된 데이터로 추론
if filtered:
    estimation = build_reasoning(filtered)
else:
    print("⚠️ RAG에 적절한 데이터 없음 → 대안 방법")
```

### 비교 가능성 체크 함수 (향후 구현)

```python
def is_comparable(target, candidate):
    """
    비교 가능성 4대 기준 체크
    
    Returns:
        bool: 4개 중 3개 이상 유사하면 True
    """
    score = 0
    
    # 1. 제품 속성
    if target.product_type == candidate.product_type:
        score += 1
    
    # 2. 소비 주체
    if target.consumer_type == candidate.consumer_type:
        score += 1
    
    # 3. 가격대 (±3배)
    if abs(target.price - candidate.price) < target.price * 3:
        score += 1
    
    # 4. 구매 맥락
    if target.is_essential == candidate.is_essential:
        score += 1
    
    return score >= 3  # 3개 이상 유사
```

---

## 📚 추가 자료

- **Tool Registry**: `config/tool_registry.yaml` → `tool:universal:guestimation`
- **System RAG**: Key로 검색 가능
- **예제**: `scripts/test_market_sizing_v7_2.py`

---

## 🎓 핵심 원칙

1. **투명성**: 모든 추정 과정을 문서화
2. **검증 가능성**: 다른 사람이 재현 가능
3. **합리성**: 누구나 동의할 수 있는 논리
4. **보수성**: 불확실하면 보수적으로
5. **경계 인식**: 한계를 명확히 인지

---

**작성**: UMIS Team  
**버전**: 1.0 (2025-11-04)  
**다음 업데이트**: RAG 자동화 추가 예정

