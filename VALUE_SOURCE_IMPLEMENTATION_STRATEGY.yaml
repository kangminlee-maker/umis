# Value Source 구현 전략
# LLM, 웹, RAG를 어떻게 추가할 것인가?

meta:
  version: "1.0"
  date: "2025-11-07"
  purpose: "현실적이고 점진적인 Value Source 구현 전략"

---

# ═══════════════════════════════════════════════════════
# PART 1: 현재 상황
# ═══════════════════════════════════════════════════════

current_status:
  
  구현됨:
    - 확정 데이터 (project_data) ✅
    - 통계 패턴 (Soft에서 값 추출) ✅
  
  TODO:
    - LLM 추정 ⏳
    - 웹 검색 ⏳
    - RAG 벤치마크 ⏳
  
  문제:
    
    LLM_Native_Mode:
      - Cursor LLM은 interactive
      - 자동 호출 어려움
      - 프롬프트로 값 받기 불가
    
    웹_검색:
      - API 필요 (SerpAPI, Bing 등)
      - 비용 발생
      - 파싱 복잡
    
    RAG_벤치마크:
      - QuantifierRAG 통합 필요
      - 간단하지만 의존성

---

# ═══════════════════════════════════════════════════════
# PART 2: 구현 옵션
# ═══════════════════════════════════════════════════════

implementation_options:
  
  옵션_1_점진적_구현:
    
    단계:
      
      Phase_1_통계_활용:
        현재:
          Soft에서_값_추출:
            - StatisticalValueSource
            - distribution에서 median/mean
            - 이미 구현됨 ✅
        
        개선:
          통계_패턴_활성화:
            - Soft Guide 있으면
            - Value로도 사용
            - 조건: "다른 Value 없을 때"
        
        효과:
          - 추가 구현 없이
          - Value 1-2개 확보
          - 기본 동작 가능
      
      Phase_2_샘플_데이터:
        방법:
          mock_value_source:
            - 주요 질문 20-30개
            - 샘플 값 미리 정의
            - YAML 파일
          
          예시: |
            sample_values:
              - question_pattern: "한국 음식점 월매출"
                value: 2700만원
                confidence: 0.70
                source: "샘플 데이터"
        
        장점:
          - 즉시 동작 시연
          - 테스트 가능
          - 복잡도 낮음
        
        단점:
          - 제한적 (20-30개만)
          - 실제 데이터 아님
      
      Phase_3_RAG_통합:
        방법:
          QuantifierRAG_활용:
            - market_benchmarks (100개)
            - search_benchmark() 호출
            - 코드 10줄
        
        장점:
          - 실제 데이터 100개
          - 즉시 활용
          - 간단
        
        난이도: 낮음 (1-2시간)
      
      Phase_4_웹_검색:
        방법:
          API_통합:
            - SerpAPI or Bing
            - 비용 발생
            - 파싱 로직
        
        장점:
          - 최신 데이터
          - 범용성
        
        난이도: 중간 (1일)
        비용: 유료
      
      Phase_5_LLM_API:
        방법:
          External_Mode:
            - GPT-4 API
            - OpenAI SDK
            - 프롬프트 설계
        
        장점:
          - 자동화 가능
          - 유연함
        
        난이도: 낮음 (2-3시간)
        비용: 유료
    
    권장_순서:
      1. 통계 활성화 (즉시)
      2. RAG 통합 (1-2시간)
      3. 샘플 데이터 (보조용)
      4. LLM API (필요 시)
      5. 웹 검색 (필요 시)
  
  옵션_2_통계_패턴_중심:
    
    철학: "통계 패턴이 이미 Value"
    
    방법:
      
      Soft_Guide에서_값_추출:
        현재:
          통계_패턴 → Soft Guide
          - distribution 정보
          - range [1000, 4500]
        
        개선:
          동시에_Value도:
            - median 2000 추출
            - confidence 0.65
            - "다른 Value 없을 때 사용"
      
      처리_로직:
        IF value_estimates_empty:
          FOR soft_guide IN soft_guides:
            IF soft_guide.distribution:
              value = extract_representative_value(distribution)
              confidence = 0.50-0.65
              
              value_estimates.append(value)
      
      장점:
        - 추가 구현 없음
        - 이미 데이터 있음 (통계)
        - 즉시 활용
      
      단점:
        - confidence 낮음 (0.50-0.65)
        - Value Source가 적음
    
    평가:
      실용적:
        - MVP로 충분
        - 나중에 확장
  
  옵션_3_하이브리드:
    
    조합:
      즉시: 통계 값 활용
      단기: RAG 통합 (1-2시간)
      중기: 샘플 데이터 (보조)
      장기: LLM API, 웹 검색

---

# ═══════════════════════════════════════════════════════
# PART 3: 권장 전략
# ═══════════════════════════════════════════════════════

recommended_strategy:
  
  단계_1_통계_활성화:
    
    수정_파일: "source_collector.py"
    
    로직_추가:
      _collect_values_sequential:
        # 기존 Value Sources
        estimates.extend(self.definite_data.collect(...))
        estimates.extend(self.llm.collect(...))
        estimates.extend(self.web.collect(...))
        estimates.extend(self.rag.collect(...))
        
        # 통계값 활성화 ⭐
        IF len(estimates) == 0:  # Value 없을 때만
          FOR soft_guide IN soft_guides:
            IF soft_guide.distribution:
              stat_values = self.statistical_value.collect(
                question, context, soft_guide
              )
              estimates.extend(stat_values)
    
    효과:
      - 음식점 → median 2000 (Power Law)
      - SaaS Churn → mean 0.06 (정규분포)
      - 즉시 동작!
    
    시간: 30분
  
  단계_2_RAG_통합:
    
    수정_파일: "sources/value.py - RAGBenchmarkSource"
    
    코드:
      from umis_rag.agents.quantifier import QuantifierRAG
      
      def __init__(self):
        self.quantifier = QuantifierRAG()
      
      def collect(self, question, context):
        # 도메인 지표 질문만
        if self._is_domain_metric(question):
          results = self.quantifier.search_benchmark(question, top_k=3)
          
          estimates = []
          for doc, score in results:
            value = extract_value_from_doc(doc)
            
            estimates.append(ValueEstimate(
              source_type=SourceType.RAG_BENCHMARK,
              value=value,
              confidence=score,
              ...
            ))
          
          return estimates
        
        return []
    
    효과:
      - 100개 벤치마크 활용
      - SaaS Churn, LTV 등
    
    시간: 1-2시간
  
  단계_3_샘플_보강:
    
    파일: "data/tier1_rules/sample_values.yaml"
    
    내용:
      samples:
        - question: "한국 음식점 월매출"
          value: 2700만원
          range: [1890, 3510]
          confidence: 0.70
          source: "샘플 (실제로는 웹 검색 예정)"
        
        - question: "카페 평균 매출"
          value: 3200만원
          ...
    
    로드:
      SampleValueSource 클래스 추가
      YAML 로드하여 매칭
    
    효과:
      - 시연용
      - 테스트 데이터
    
    시간: 1시간

---

# ═══════════════════════════════════════════════════════
# PART 4: 최종 권장
# ═══════════════════════════════════════════════════════

final_recommendation:
  
  즉시_구현:
    
    1_통계값_활성화:
      작업: source_collector.py 수정
      시간: 30분
      효과: 즉시 동작
    
    2_RAG_통합:
      작업: RAGBenchmarkSource 구현
      시간: 1-2시간
      효과: 100개 벤치마크
  
  선택_구현:
    
    3_샘플_데이터:
      필요성: 중간
      시간: 1시간
      용도: 테스트, 시연
    
    4_LLM_API:
      필요성: 낮음 (통계+RAG로 충분)
      시간: 2-3시간
      비용: 유료
    
    5_웹_검색:
      필요성: 낮음 (RAG로 충분)
      시간: 1일
      비용: 유료
  
  MVP_구성:
    Value_Sources:
      1. 확정 데이터 ✅
      2. 통계 패턴 값 ⭐ (활성화)
      3. RAG 벤치마크 ⭐ (통합)
      4. 샘플 데이터 (선택)
    
    충분성: MVP로 충분 ✅
    
    나중에:
      - LLM API (자동화 필요 시)
      - 웹 검색 (최신 데이터 필요 시)

---

# ═══════════════════════════════════════════════════════
# PART 5: 구현 예시
# ═══════════════════════════════════════════════════════

implementation_example:
  
  통계값_활성화:
    
    코드: |
      # source_collector.py
      
      def _collect_values_sequential(self, question, context):
        estimates = []
        
        # 1. 확정 데이터
        estimates.extend(self.definite_data.collect(question, context))
        
        # 2-4. LLM, 웹, RAG (스킵 or TODO)
        estimates.extend(self.llm.collect(question, context))
        estimates.extend(self.web.collect(question, context))
        estimates.extend(self.rag.collect(question, context))
        
        # 5. 통계값 (다른 것 없을 때만) ⭐
        if len(estimates) == 0:
          # Soft 먼저 수집해야 함
          soft_guides = self._collect_soft(question, context)
          
          for soft_guide in soft_guides:
            if soft_guide.distribution:
              stat_values = self.statistical_value.collect(
                question, context, soft_guide
              )
              estimates.extend(stat_values)
        
        return estimates
    
    효과:
      "음식점 매출?" 
        → Soft: Power Law [1000, 4500]
        → Value: median 2000 (자동 추출!)
  
  RAG_통합:
    
    코드: |
      # sources/value.py - RAGBenchmarkSource
      
      from umis_rag.agents.quantifier import QuantifierRAG
      
      class RAGBenchmarkSource(ValueSourceBase):
        def __init__(self):
          try:
            self.quantifier = QuantifierRAG()
          except:
            self.quantifier = None
        
        def collect(self, question, context):
          if not self.quantifier:
            return []
          
          # 도메인 지표만
          if not self._is_domain_metric(question):
            return []
          
          # 검색
          results = self.quantifier.search_benchmark(question, top_k=3)
          
          estimates = []
          for doc, score in results:
            # 메타데이터에서 값 추출
            value = doc.metadata.get('value')
            if value:
              estimates.append(ValueEstimate(
                source_type=SourceType.RAG_BENCHMARK,
                value=float(value),
                confidence=score,
                source_detail=doc.metadata.get('source', 'RAG')
              ))
          
          return estimates
        
        def _is_domain_metric(self, question):
          metrics = ['churn', 'ltv', 'cac', 'arpu', '전환율']
          return any(m in question.lower() for m in metrics)
    
    효과:
      "SaaS Churn?"
        → RAG에서 6% (confidence 0.75)

---

# ═══════════════════════════════════════════════════════
# PART 6: 우선순위
# ═══════════════════════════════════════════════════════

priority:
  
  P0_즉시:
    1. 통계값 활성화 (30분) ⭐
       - 이미 데이터 있음
       - 코드 수정만
       - 즉시 동작
  
  P1_단기:
    2. RAG 통합 (1-2시간) ⭐
       - QuantifierRAG 활용
       - 100개 벤치마크
       - 도메인 지표 커버
  
  P2_중기:
    3. 샘플 데이터 (1시간)
       - 테스트용
       - 시연용
  
  P3_장기:
    4. LLM API (2-3시간)
       - 필요 시
       - 자동화용
    
    5. 웹 검색 (1일)
       - 필요 시
       - 최신 데이터용

---

# ═══════════════════════════════════════════════════════
# END
# ═══════════════════════════════════════════════════════

