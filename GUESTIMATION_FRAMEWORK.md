# Guestimation Framework

**버전**: 1.0  
**작성일**: 2025-11-04  
**적용**: UMIS 전체 (모든 Agent)

---

## 📘 정의

**Guestimation**: 기초적인 지식과 논리적 추론만으로 짧은 시간 안에 대략적인 근사치를 추정하는 방법

## 🎯 핵심 철학

> "정확하지 않아도 괜찮다. 하지만 근거 없이 추정하면 안 된다."

### 언제 사용하나?

- ✅ 직접 데이터가 없을 때
- ✅ 정확한 값을 알 수 없을 때
- ✅ 짧은 시간 내 판단이 필요할 때

### 언제 사용하지 말아야 하나?

- ❌ 직접 데이터가 있을 때
- ❌ 정확한 값이 필수일 때
- ❌ 추정 불가능할 때 (억지로 추정하지 말것)

---

## 🔧 세 가지 추정 방법

### 방법 1: Benchmark-based (벤치마크 기반)

**접근**: 유사 사례를 찾아서 적용 (출처 4 활용)

```yaml
프로세스:
  1. RAG/웹에서 유사 벤치마크 검색
  2. 비교 가능성 검증 (4대 기준) ⭐ 필수!
  3. 채택된 벤치마크 기반 추론

적용 사례:
  - 전환율 추정 (유사 제품 구독률 참고)
  - Churn Rate (업계 평균)
  - 시장 점유율 (유사 시장)

🤖 AI 활용:
  - RAG 검색 → 후보 수집
  - 4대 기준 자동 검증
  - 채택/기각 명시

장점: 실제 데이터 기반, 신뢰도 높음
단점: 유사 사례 없으면 불가능
핵심: 비교 가능성 검증이 전제조건
```

### 방법 2: Decomposition-based (분해 기반) ⭐

**접근**: 문제를 작은 단위로 분해하여 계산

```yaml
프로세스:
  1. 목표를 구성 요소로 분해
  2. 각 요소를 출처 1~4로 추정
  3. 재조립하여 전체 계산

적용 사례:
  - 시장 규모 = 고객 수 × 구매 빈도 × 객단가
  - 여행 지출 = 인원 × (교통 + 식비 + 숙박)
  - 1인당 지출 = 교통 + 식비 + 숙박

장점: 벤치마크 없어도 가능, 논리 명확
핵심: First Principles, 논리적 분해
```

### 방법 3: Constraint-based (제약조건 기반) ⭐

**접근**: 물리적/시간적 제약조건 활용

```yaml
프로세스:
  1. 제약조건 식별 (시간, 용량, 물리적 한계)
  2. 제약조건으로 계산 또는 역산

적용 사례:
  - 하루 최대 고객: 운영시간 / 1인당 시간
  - 제조 용량: 요리사 × 시간 × 속도
  - 물리적 한계: 공간, 시간, 속도

제약 유형:
  - 시간 제약: 하루 24시간, 1끼 30분
  - 공간 제약: 테이블 크기, 좌석 수
  - 속도 제약: 제조 시간, 이동 시간

장점: 물리적 근거 명확
핵심: 물리 법칙, 시간 × 용량
```

### 방법 선택 가이드

```
1. 유사 사례가 있는가?
   YES → Benchmark-based
   NO → 다음 단계

2. 문제를 분해할 수 있는가?
   YES → Decomposition-based
   NO → 다음 단계

3. 공급 제약조건이 명확한가?
   YES → Constraint-based
   NO → 조합 사용

복합 사용:
  - Decomposition으로 분해
  - 일부 요소는 Benchmark
  - 일부 요소는 Constraint
```

---

## 🔑 기초적인 지식 - 8가지 출처 (AI 전략)

### 출처 1: 프로젝트 데이터
```
확정된 데이터:
  - 주어진 숫자
  - 검증된 사실

AI 방법: 직접 사용
신뢰도: High
```

### 출처 2: LLM 직접 답변
```
검색 없이 즉시 답변:
  - "한국 인구는?"
  - "일반적인 식사 시간은?"

AI 방법: LLM에게 직접 질문
신뢰도: Medium (검증 권장)
주의: 최신 정보 부족, Hallucination
사용: Order of Magnitude만 필요할 때
```

### 출처 3: 검색 엔진 공통 맥락 ⭐
```
상위 결과의 공통 패턴:
  - "평균 식사 가격" → 공통: 8천~1.5만원
  - "음식점 테이블 수" → 공통: 8-12개

AI 방법:
  1. 웹 서치
  2. 상위 5-10개 분석
  3. 공통 값/범위 추출

신뢰도: High (복수 출처)
사용: 최신 정보, 합의된 값
```

### 출처 4: 법칙 (물리/법률/도덕)
```
절대적 제약:
  - 물리: 하루 24h, 1년 365일
  - 법률: 근로 주 52h, 최저임금
  - 도덕: 공정 거래

AI 방법: 직접 적용 (검증 불필요)
신뢰도: Absolute
사용: Boundary, 제약조건
```

### 출처 5: 행동경제학 ⭐
```
예측 가능한 비합리성:
  - Loss Aversion: 손실 회피 > 이득 (2배)
  - Temporal Discounting: 현재 > 미래
  - Anchoring: 첫 정보 고정
  - Social Proof: 다수 선택 따름

AI 방법: RAG 또는 행동경제학 DB
신뢰도: High (연구 검증)
사용: 전환율 조정, 가격 민감도
```

### 출처 6: 통계적 패턴
```
수학적 패턴:
  - 80-20 법칙 (Pareto)
  - 정규분포 (68-95-99.7)
  - 회귀 평균

AI 방법: 수학 공식 적용
신뢰도: High (수학적)
사용: 분포 추정, 시장 집중도
```

### 출처 7: Rule of Thumb (RAG) ⭐
```
산업별 경험 공식:
  - SaaS: LTV/CAC > 3, Rule of 40
  - E-commerce: 전환율 2-3%
  - 구독: Churn 3-5%

AI 방법: RAG 검색 (market_benchmarks)
신뢰도: Medium-High
사용: 초기 추정, Sanity Check

⚠️ Rule of Thumb 내 Benchmark도 4대 기준 검증!
```

### 출처 8: 시공간의 절대 제약
```
물리적 한계:
  - 시간: 하루 24h, 수명 80년
  - 공간: 국토 면적, 거리
  - 인간: 수면 8h, 식사 3끼

AI 방법: 직접 적용
신뢰도: Absolute
사용: 최대 용량, 상한 설정
```

---

**중요**: 
- 사람: 출처 1~8 모두 직접 활용
- AI: 출처 1 직접, 2~8로 gap 메우기
- RAG: 출처 7의 일부 (전체의 12.5%)

### 2. 논리적 추론 (Logical Reasoning)

#### 논리의 연결
- A → B → C 형태의 단계별 추론
- 각 단계의 근거 명확화

#### 합리적 가정
- "A와 B가 유사하다면..."
- "보수적으로 가정하면..."

#### 변수 제거
- 영향이 작은 변수 무시
- 상쇄되는 요소 제거

#### Boundary 설정
- 상한(Upper Bound): 아무리 높아도 이 이상은 불가능
- 하한(Lower Bound): 아무리 낮아도 이 이하는 불가능
- 현실적 범위: 실제로는 이 범위 내에 있을 것

---

## 📝 Fermi Estimation 프로세스 (8단계)

### Step 1: 문제 명확화
```
- 추정 대상: [무엇을 알고 싶은가?]
- 사용 목적: [왜 필요한가?]
- 정확도 목표: [Order of Magnitude? ±X%?]
```

### Step 2: 모형 만들기 ⭐ Fermi 핵심!
```
추상적 문제 → 계산 가능 모형

예시:
  - 전봇대 → "면적 × 밀도"
  - 자장면 → "중국집 × 용량 × 시간"
  - 여행 → "인원 × 1인당 지출"

가정 명시:
  - "대한민국 = 직사각형"
  - "수요 = 공급"
  - "균등 분배"

핵심: 보이지 않는 것을 보이게!
```

### Step 3: 분해 (Decomposition)
```
큰 문제 → 작은 요소들

예시:
  - 1인당 지출 = 교통 + 식비 + 숙박
  - 전봇대 = 광역시 + 나머지
  - 제조량 = Peak + Normal

각 요소 출처:
  - 상식 (출처 2)
  - 경험 (출처 3)
  - Benchmark (출처 4, 검증 후)
  - 제약조건 (물리적/시간적)
```

### Step 4: 계산
```
각 요소 값 추정:
  - 상식 활용: 인구, 면적
  - 경험 활용: 시간, 속도
  - 제약 활용: 물리적 한계
  - Benchmark: 비교 가능한 것만

재조립:
  - 모형에 따라 계산
  - 단계별 중간 결과
```

### Step 4.5: Benchmark 비교 가능성 검증 (사용 시)
```
Benchmark 출처 4 사용 시에만:

후보 1: [데이터]
  ✓ 제품 속성: [동일/유사/다름]
  ✓ 소비 주체: [동일/유사/다름]
  ✓ 가격대: [동일/유사/다름]
  ✓ 구매 맥락: [동일/유사/다름]
  → 판단: [채택/기각]

✅ 4개 중 3개 이상 유사 → 채택
❌ 그 외 → 기각

→ 상식/경험(출처 2,3)은 검증 불필요
→ Benchmark만 검증 필요
```

### Step 5: 비율 조정 (필요 시)
```
불균등 분배:
  - 도시 vs 시골 (2배 차이)
  - Peak vs Normal (4배 차이)

외부 요인:
  - COVID 영향 (80% 배달)
  - 계절성
```

### Step 6: Boundary 검증
```
상한: [절대 불가능 최대값]
하한: [절대 불가능 최소값]
현실 범위: [합리적 범위]
우리 추정: [Value] → 범위 내 ✓
```

### Step 7: 검증
```
Cross-check:
  - 역산 (42만 / 1,000만 = 24명 중 1명)
  - 다른 방법으로 계산
  - 상식 체크

Order of Magnitude:
  - 자릿수 맞는가?
  - 10만? 100만? 1,000만?
```

### Step 8: 신뢰도 평가
```
정확도:
  - Order of Magnitude: ±50% (자릿수)
  - High: ±10%
  - Medium: ±20%
  - Low: ±30~50%

Confidence:
  - High: 제약조건 명확, 상식 기반
  - Medium: 일부 가정 필요
  - Low: 많은 가정
```

---

## 💡 실전 예시

### ✅ 예시 1: Benchmark-based (피아노 구독 전환율)

**방법**: 유사 사례 찾기

```yaml
Step 1 문제:
  추정 대상: 피아노 렌탈/구독 서비스 전환율
  사용 목적: Bottom-Up SAM 계산
  필요 정확도: ±20%

Step 2 기초 지식 수집:
  프로젝트 데이터:
    - 타겟: 피아노 구매 고려 고객
    - 가격: 월 50,000원
    - 제품: 물리적 악기
  
  RAG 검색 결과:
    후보 1: 정수기 구독률 25%
    후보 2: 공기청정기 렌탈률 18%
    후보 3: 음악 앱 구독률 30%
    후보 4: SaaS B2B 전환율 2-5%

Step 2.5 비교 가능성 검증: ⭐
  후보 2: 공기청정기 18%
    제품 유형: 물리적 ✓
    소비 주체: B2C ✓
    가격대: 3-5만원 ✓
    구매 맥락: 선택재 ✓
    → 판단: 채택 ✅ (4/4)
  
  후보 3: 음악 앱 30%
    제품 유형: 디지털 ✗
    → 판단: 기각 ❌
  
  최종: 공기청정기 18% 채택

Step 3 추론:
  피아노 ≈ 공기청정기 → 약간 보수적 → 15%

결론: 15% (±20%)
```

### ✅ 예시 2: Decomposition-based (휴일 여행 지출)

**방법**: 문제 분해 (벤치마크 없음!)

```yaml
Step 1 문제:
  추정 대상: 휴일 하루 증가 시 여행 지출 증가액

Step 2 문제 분해: ⭐
  총 지출 = 인원 × 1인당 지출
  1인당 지출 = 교통비 + 식비 + 숙박비

Step 3 각 요소 추정 (상식/경험):
  인원:
    - 인구: 5,000만 (상식)
    - 비율: 1/20 = 5% (가정)
    - 인원: 250만

  교통비:
    - 버스 편도: 1.5~2만원 (상식)
    - 왕복: 3.5만원

  식비:
    - 2끼 × 1만원 = 2만원 (경험)

  숙박비:
    - 1박: 4.5만원 (경험)

  1인당: 10만원

Step 4 재조립:
  250만 × 10만 = 2,500억원

Step 5 검증:
  Boundary: 500억 ~ 5,000억 → 2,500억 ✓
  
특징:
  ✅ 벤치마크 불필요
  ✅ 순수 논리 분해
  ✅ First Principles
```

### ✅ 예시 3: Constraint-based (자장면 배달량)

**방법**: 제약조건 역산

```yaml
Step 1 문제:
  추정 대상: 2021년 서울 중국집 하루 자장면 배달량

Step 2 모형:
  배달량 = 중국집 수 × 1집당 제조량 × 배달 비중

Step 3 분해 + 제약조건:
  중국집 수 역산:
    - 경제활동인구 500만
    - 수요 = 공급
    - 음식점 4만개 → 중국집 8,000개
  
  제조 용량:
    - 요리사 2명
    - Peak 96그릇 + Normal 18그릇
    - 1집당 66그릇

Step 4 계산:
  8,000 × 66 × 80% = 42만 그릇

Step 5 검증:
  1,000만 / 42만 = 24명 중 1명 ✓

특징:
  ✅ Constraint 활용
  ✅ 물리적 계산
```

### ✅ 예시 4: Model + Decomposition + Constraint (전봇대) - Fermi 고전!

**방법**: Fermi Estimation 3원리 모두 활용

```yaml
Step 1 문제:
  추정 대상: 대한민국 전봇대 총 개수
  목표: Order of Magnitude (백만 단위)

Step 2 모형 만들기: ⭐
  모형: 전봇대 수 = 환산면적 × 1km²당 전봇대 수
  
  가정:
    - 대한민국 = 직사각형
    - 전봇대 = 70m 간격 격자
    - 산지 70% = 전봇대 없음

Step 3 분해 + 데이터:
  출처 2 (상식):
    - 국토: 100,000 km²
    - 산지: 70%
    - 서울+6광역시: 6,000 km²
    - 인구: 4,850만 (광역 46%)
  
  출처 3 (경험):
    - 전봇대 간격: 70m (군대)

Step 4 계산:
  밀도: 1km / 70m = 14개 → 1km² = 200개
  
  지역별:
    - 광역시: 6,000 × 200 × 2 × 0.3 = 233만
    - 나머지: 24,000 × 200 × 1 × 0.3 = 483만

Step 5 비율 조정:
  도시 2배 (인구 밀집)
  평지만 (산지 제외)

Step 6 최종:
  233만 + 483만 = 716만개

Step 7 검증:
  실제 (한전): 858만
  오차: 16%
  자릿수: ✅ 백만 단위 일치!

Step 8 Fermi 평가:
  "몇 백만?" → "700만 수준"
  Order of Magnitude 성공! ✅

특징:
  ✅ 모형 (면적 × 밀도)
  ✅ 분해 (지역별)
  ✅ 제약 (70m)
  ✅ 상식만 사용
  ✅ 16% 오차

Fermi 철학:
  > "정답이 아니라, 보이지 않는 것을
  >  보이게 만든 과정이 중요하다"
```

### ❌ 나쁜 예시: RAG 맹신

```yaml
Step 2 RAG 검색:
  - "기타" 구독: 12% (guitar 오해)
  - 음악 앱: 18% (디지털 vs 물리적)
  - SaaS: 2-5% (B2B vs B2C)

Step 2.5 비교 가능성 검증: 누락! ⚠️

Step 3 추론:
  평균: (12% + 18%) / 2 = 15%

문제:
  ❌ 비교 불가능한 데이터 사용
  ❌ 논리 없이 평균
  ❌ 우연히 답 비슷할 뿐
```

---

## 🎓 핵심 원칙

### 원칙 1: 비교 가능성이 전제조건

```
⚠️ RAG에 있다고 모두 쓸 수 있는 것은 아님
⚠️ 키워드 매칭 ≠ 맥락 이해
⚠️ "데이터가 있다" ≠ "사용해야 한다"

✅ 비교 가능성 4대 기준:
  1. 제품/서비스 속성 (물리적/디지털)
  2. 소비 주체 (B2C/B2B)
  3. 가격대 (±3배 이내)
  4. 구매 맥락 (필수재/선택재)

→ 4개 중 3개 이상 유사해야 비교 가능
```

### 원칙 2: 논리 > 데이터

```
❌ "RAG에서 3개 찾았으니 평균"
✅ "A는 비교 가능, B는 불가. A 기반 추론"

→ 논리적으로 타당하면 데이터 1개도 충분
→ 논리 없으면 데이터 100개도 무의미
```

### 원칙 3: 명시적 기각

```
기각한 데이터도 문서화:
  - 후보 X: [데이터]
  - 기각 이유: [구체적 근거]

→ 왜 안 썼는지 설명 필요
→ 투명성과 재현 가능성 확보
```

### 원칙 4: 보수적 추정

```
불확실하면 낮게:
  - 시장 규모: 보수적
  - 전환율: 보수적
  - 성장률: 보수적

→ 과대 추정 < 과소 추정
→ "최소한 이 정도는 된다"
```

---

## ✅ 품질 기준

### Good Guestimation
- ✅ 비교 가능성 검증 완료 ⭐ (가장 중요!)
- ✅ 기각한 데이터도 명시
- ✅ 논리적 연결 명확
- ✅ 각 단계 근거 있음
- ✅ Boundary 체크 완료
- ✅ 대안 방법 고려함
- ✅ 검증 가능

### Bad Guestimation
- ❌ 비교 가능성 검증 없음 ⚠️ (치명적!)
- ❌ RAG 데이터 무조건 사용
- ❌ 키워드 매칭만으로 채택
- ❌ "그냥 20%로 가정"
- ❌ 근거 없는 평균
- ❌ 논리 비약
- ❌ Boundary 무시
- ❌ 검증 불가능

---

## 🤖 AI를 위한 Guestimation 전략

### AI의 한계와 해결책

```yaml
한계:
  ❌ 보편적 상식 부족 (군대 경험, 일상 가격)
  ❌ 경험적 지식 부족 (테이블 3명, 식사 30분)
  ❌ 최신 정보 부족 (2024년 버스 요금)

해결책: 출처별 AI 전략
```

### AI 활용 전략: 8가지 출처별 가이드

```yaml
출처 2 (LLM 직접):
  방법: LLM에게 질문
  예시: "한국 인구는?", "일반적인 식사 시간은?"
  사용: Order of Magnitude, 대략적 값
  주의: 검증 권장 (Hallucination)

출처 3 (검색 공통 맥락):
  방법: 웹 서치 → 상위 결과 공통 값
  예시: "평균 식사 가격" → 8천~1.5만원
  사용: 최신 정보, 합의된 값
  신뢰도: High (복수 출처)

출처 4 (법칙):
  방법: 직접 적용
  예시: 하루 24h, 근로 주 52h
  사용: Boundary, 제약조건
  신뢰도: Absolute

출처 5 (행동경제학):
  방법: RAG 또는 행동경제학 DB
  예시: Loss Aversion (2배), Anchoring
  사용: 전환율 조정, 가격 민감도
  적용: 전환율 × 0.8 (Loss Aversion)

출처 6 (통계 패턴):
  방법: 수학 공식
  예시: 80-20 법칙, 정규분포
  사용: 분포 추정, 시장 집중도
  신뢰도: High (수학적)

출처 7 (Rule of Thumb):
  방법: RAG 검색 (market_benchmarks)
  예시: SaaS LTV/CAC > 3, E-commerce 전환율 2-3%
  사용: 초기 추정, Sanity Check
  ⚠️ 여전히 4대 기준 검증 필요!

출처 8 (시공간 제약):
  방법: 직접 적용
  예시: 하루 24h, 수명 80년, 국토 면적
  사용: 최대 용량, 상한
  신뢰도: Absolute
```

### AI Guestimation 우선순위

```
1순위: 프로젝트 데이터 (출처 1)
2순위: 절대 제약 (출처 4, 8)
3순위: 검색 공통 맥락 (출처 3) - 최신 정보
4순위: Rule of Thumb (출처 7) - RAG
5순위: 통계/행동 패턴 (출처 5, 6)
6순위: LLM 직접 (출처 2) - 검증 필요

핵심: 신뢰도 높은 것부터!
```

---

## 🔧 UMIS에서 사용법

### Agent별 활용

#### Quantifier (Bill)
- Market Sizing 추정
- 전환율, AOV, Frequency 추정
- AI: RAG + 웹 서치 + 물리 제약

#### Explorer (Steve)
- 기회 크기 추정
- TAM/SAM 대략 계산
- AI: RAG 패턴 + Guestimation

#### Validator (Rachel)
- 데이터 신뢰도 평가
- Error Range 계산
- AI: 웹 서치로 검증

#### Observer (Albert)
- 시장 구조 비율
- Value Chain 분배
- AI: RAG + 물리 제약

### RAG 활용 (비판적 사고 필수)

```python
# ❌ 나쁜 예: RAG 결과를 그대로 사용
query = "음악 구독 전환율"
results = search_benchmarks(query)
value = average(results)  # 비교 불가능한 것 포함!

# ✅ 좋은 예: 비교 가능성 검증 후 사용
query = "제품 구독 서비스 전환율"
candidates = search_benchmarks(query)

# 1. 비교 가능성 검증
filtered = []
for candidate in candidates:
    if is_comparable(target, candidate):
        filtered.append(candidate)
        print(f"✅ 채택: {candidate.name}")
    else:
        print(f"❌ 기각: {candidate.name} - {이유}")

# 2. 채택된 데이터로 추론
if filtered:
    estimation = build_reasoning(filtered)
else:
    print("⚠️ RAG에 적절한 데이터 없음 → 대안 방법")
```

### 비교 가능성 체크 함수 (향후 구현)

```python
def is_comparable(target, candidate):
    """
    비교 가능성 4대 기준 체크
    
    Returns:
        bool: 4개 중 3개 이상 유사하면 True
    """
    score = 0
    
    # 1. 제품 속성
    if target.product_type == candidate.product_type:
        score += 1
    
    # 2. 소비 주체
    if target.consumer_type == candidate.consumer_type:
        score += 1
    
    # 3. 가격대 (±3배)
    if abs(target.price - candidate.price) < target.price * 3:
        score += 1
    
    # 4. 구매 맥락
    if target.is_essential == candidate.is_essential:
        score += 1
    
    return score >= 3  # 3개 이상 유사
```

---

## 📚 추가 자료

- **Tool Registry**: `config/tool_registry.yaml` → `tool:universal:guestimation`
- **System RAG**: Key로 검색 가능
- **예제**: `scripts/test_market_sizing_v7_2.py`

---

## 🎓 핵심 원칙

1. **투명성**: 모든 추정 과정을 문서화
2. **검증 가능성**: 다른 사람이 재현 가능
3. **합리성**: 누구나 동의할 수 있는 논리
4. **보수성**: 불확실하면 보수적으로
5. **경계 인식**: 한계를 명확히 인지

---

**작성**: UMIS Team  
**버전**: 1.0 (2025-11-04)  
**다음 업데이트**: RAG 자동화 추가 예정

