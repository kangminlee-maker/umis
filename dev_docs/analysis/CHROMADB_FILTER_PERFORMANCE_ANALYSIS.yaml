# ChromaDB Filter 성능 분석
# projected_index가 4배 커져도 왜 성능 영향이 없는가?

meta:
  version: "1.0"
  date: "2025-11-07"
  purpose: "ChromaDB 메타데이터 필터링 메커니즘과 성능 영향 분석"

---

# ═══════════════════════════════════════════════════════
# PART 1: ChromaDB Filter 메커니즘
# ═══════════════════════════════════════════════════════

chromadb_filter_mechanism:
  
  기본_개념:
    
    Filter란:
      설명: "메타데이터 기반 사전 필터링"
      
      동작:
        1. 전체 청크에서 메타데이터 조건 만족하는 것만 선택
        2. 선택된 청크에서만 벡터 검색 수행
        3. 결과 리턴
      
      핵심: "벡터 검색 전에 DB 레벨에서 필터링"
  
  사용_예시:
    
    Filter_없음:
      query = "SaaS Churn은?"
      
      검색_대상: 전체 2,700개 청크
        - explorer: 354개
        - quantifier: 130개
        - validator: 134개
        - observer: 80개
        - guestimation: 2,000개
      
      벡터_검색: 2,700개 모두 계산
      시간: 0.3-0.5초
    
    Filter_사용:
      query = "SaaS Churn은?"
      filter = {"agent_view": "guestimation"}
      
      필터링: 2,700개 → 2,000개 (guestimation만)
      
      벡터_검색: 2,000개만 계산
      시간: 0.2-0.3초
      
      차이: 약간 빠름 (필터링 덕분)

---

# ═══════════════════════════════════════════════════════
# PART 2: 성능 영향 상세 분석
# ═══════════════════════════════════════════════════════

performance_detailed_analysis:
  
  시나리오_1_Explorer_검색:
    
    Before:
      projected_index:
        explorer: 354개
        quantifier: 130개
        validator: 134개
        observer: 80개
        총: 698개
      
      Explorer_검색:
        filter: {"agent_view": "explorer"}
        
        필터링: 698개 → 354개
        벡터_검색: 354개
        시간: 0.1초
    
    After:
      projected_index:
        explorer: 354개
        quantifier: 130개
        validator: 134개
        observer: 80개
        guestimation: 2,000개 ⭐
        총: 2,698개
      
      Explorer_검색:
        filter: {"agent_view": "explorer"}
        
        필터링: 2,698개 → 354개 (동일!)
        벡터_검색: 354개 (동일!)
        시간: 0.1초 (동일!)
      
      차이: 없음! ✅
      
      이유:
        - Filter가 DB 레벨에서 작동
        - agent_view != "guestimation" 청크는 아예 안 읽음
        - 인덱스 활용 (B-Tree 같은 구조)
  
  시나리오_2_Guestimation_검색:
    
    Year_1:
      projected_index:
        기존: 698개
        guestimation: 2,000개
        총: 2,698개
      
      Guestimation_검색:
        filter: {"agent_view": "guestimation"}
        
        필터링: 2,698개 → 2,000개
        벡터_검색: 2,000개
        
        시간_계산:
          벡터_검색: O(N × log(K))
          N = 2,000 (대상)
          K = 5 (top_k)
          
          예상: 0.2-0.3초
      
      비교:
        만약_별도_Collection:
          tier1_learned_rules: 2,000개
          검색: 2,000개
          시간: 0.2-0.3초 (동일!)
      
      결론: 성능 차이 없음!
  
  시나리오_3_복합_Filter:
    
    검색:
      query: "한국 SaaS Churn은?"
      
      filter:
        agent_view: "guestimation"
        guestimation_domain: "B2B_SaaS"
        guestimation_region: "한국"
      
      필터링:
        2,698개 (전체)
        → 2,000개 (agent_view)
        → 300개 (domain)
        → 50개 (region)
      
      벡터_검색: 50개만!
      
      시간: 0.05-0.1초 (매우 빠름!)
      
      효과:
        필터_많을수록 → 검색 대상 ↓ → 빠름!

---

# ═══════════════════════════════════════════════════════
# PART 3: ChromaDB 내부 동작 (추정)
# ═══════════════════════════════════════════════════════

chromadb_internals:
  
  메타데이터_인덱싱:
    
    가정:
      ChromaDB는_아마도:
        - 메타데이터 필드에 인덱스 생성
        - B-Tree or Hash Index
        - O(log N) or O(1) 검색
    
    동작:
      
      Filter_처리:
        1. 메타데이터_인덱스_조회:
           filter: {"agent_view": "guestimation"}
           
           Index_lookup:
             agent_view="explorer" → [chunk_1, chunk_2, ...]
             agent_view="quantifier" → [chunk_10, chunk_11, ...]
             agent_view="guestimation" → [chunk_100, chunk_101, ...] ⭐
           
           시간: O(1) or O(log N) (매우 빠름!)
        
        2. ID_리스트_획득:
           guestimation_chunk_ids = [100, 101, 102, ..., 2099]
           개수: 2,000개
        
        3. 벡터_검색_수행:
           대상: 2,000개만 (전체 2,698개 아님!)
           시간: O(2000 × log 5)
      
      전체_시간:
        필터링: 0.001초 (인덱스)
        벡터_검색: 0.2초 (2,000개)
        총: 0.201초
    
    비교_Filter_없음:
      벡터_검색: 0.3초 (2,698개)
      
      차이: 0.1초 절감!
      
      역설: Filter가 오히려 빠르게 만듦!
  
  벡터_인덱스_구조:
    
    가능성_1_HNSW:
      알고리즘: "Hierarchical Navigable Small World"
      
      복잡도: O(log N)
      
      성능:
        700개: 0.1초
        2,700개: 0.12초 (log 2700 / log 700 = 1.2배)
      
      증가: 20% (미미)
    
    가능성_2_Flat_Index:
      알고리즘: "Brute Force"
      
      복잡도: O(N)
      
      성능:
        700개: 0.1초
        2,700개: 0.38초 (3.8배)
      
      증가: 280% (심각!)
    
    ChromaDB_실제:
      아마도_HNSW:
        - 현대적 Vector DB
        - 효율적 검색
        - O(log N)
      
      Filter_덕분:
        - HNSW도 적은 N 선호
        - 2,000개 vs 2,700개
        - 차이 미미

---

# ═══════════════════════════════════════════════════════
# PART 4: 실제 성능 시뮬레이션
# ═══════════════════════════════════════════════════════

performance_simulation:
  
  가정:
    ChromaDB: HNSW (O(log N))
    Filter: O(1) 인덱스
    임베딩: 미리 계산됨
  
  Case_1_Explorer_검색:
    
    Before:
      전체_청크: 698개
      filter: {"agent_view": "explorer"}
      대상: 354개
      
      시간:
        필터링: 0.001초
        벡터_검색: 0.1초 (354개, HNSW)
        총: 0.101초
    
    After:
      전체_청크: 2,698개
      filter: {"agent_view": "explorer"}
      대상: 354개 (동일!)
      
      시간:
        필터링: 0.001초 (인덱스, 빠름)
        벡터_검색: 0.1초 (354개, 동일!)
        총: 0.101초 (동일!)
      
      차이: 0초 ✅
  
  Case_2_Guestimation_검색:
    
    별도_Collection:
      Collection: tier1_learned_rules
      청크: 2,000개
      filter: 없음 (전용 Collection)
      
      시간:
        벡터_검색: 0.25초 (2,000개, HNSW)
    
    통합_Projected:
      Collection: projected_index
      청크: 2,698개
      filter: {"agent_view": "guestimation"}
      대상: 2,000개
      
      시간:
        필터링: 0.001초
        벡터_검색: 0.25초 (2,000개, HNSW)
        총: 0.251초
      
      차이: 0.001초 (무시 가능!) ✅
  
  Case_3_복합_Filter:
    
    검색:
      query: "한국 음식점 월매출은?"
      
      filter:
        agent_view: "guestimation"
        guestimation_domain: "Food_Service"
        guestimation_region: "한국"
    
    필터링:
      전체: 2,698개
      → agent_view: 2,000개
      → domain: 300개
      → region: 50개
    
    벡터_검색: 50개만!
    
    시간:
      필터링: 0.001초 (인덱스 3번)
      벡터_검색: 0.03초 (50개, 매우 빠름!)
      총: 0.031초
    
    효과:
      복합_Filter → 검색_대폭_빠름!

---

# ═══════════════════════════════════════════════════════
# PART 5: Filter 성능의 핵심
# ═══════════════════════════════════════════════════════

filter_performance_key:
  
  핵심_원리:
    
    원리_1_사전_필터링:
      
      설명: "벡터 검색 전에 DB 레벨에서 필터"
      
      순서:
        1. 메타데이터_인덱스_조회 (DB)
           filter: {"agent_view": "guestimation"}
           → ID 리스트: [100, 101, ..., 2099]
           시간: 0.001초 (인덱스 lookup)
        
        2. 벡터_검색 (선택된 것만)
           대상: 2,000개 (전체 아님!)
           시간: 0.25초
        
        3. 결과_리턴
      
      만약_Filter_없으면:
        1. 벡터_검색 (전체)
           대상: 2,698개
           시간: 0.35초
        
        2. 메타데이터_필터링 (후처리)
           시간: 0.001초
        
        총: 0.351초 (느림!)
      
      차이:
        Filter_있음: 0.251초
        Filter_없음: 0.351초
        
        Filter가 오히려 빠름! ✅
    
    원리_2_인덱스_활용:
      
      메타데이터_인덱스:
        
        구조_추정:
          agent_view_index:
            "explorer" → [1, 2, 3, ..., 354]
            "quantifier" → [355, 356, ..., 484]
            "guestimation" → [700, 701, ..., 2699]
          
          타입: B-Tree or Hash
          
          조회_시간: O(1) or O(log M)
            M = 인덱스 키 개수 (5개: 5 agent_view)
            = 거의 상수 시간!
      
      효과:
        전체_청크_증가: 700 → 2,700 (3.8배)
        인덱스_키_증가: 4개 → 5개 (1.25배)
        
        조회_시간_증가: 거의 없음!
    
    원리_3_벡터_계산_회피:
      
      벡터_검색_비용:
        가장_비싼_연산: "코사인 유사도 계산"
        
        계산량:
          N개 청크 × 3072 dim × K top_k
        
        시간_복잡도:
          Filter_있음: O(filtered_N × 3072 × log K)
          Filter_없음: O(total_N × 3072 × log K)
        
        차이:
          filtered_N = 2,000
          total_N = 2,698
          
          비율: 2,000 / 2,698 = 74%
          
          계산량: 26% 절감!

---

# ═══════════════════════════════════════════════════════
# PART 6: Filter의 한계
# ═══════════════════════════════════════════════════════

filter_limitations:
  
  한계_1_Filter_자체_비용:
    
    메타데이터_인덱스_조회:
      시간: 0.001초 (보통)
      
      하지만:
        IF 인덱스_없으면:
          시간: 0.01-0.1초 (선형 스캔)
          영향: 클 수 있음
      
      ChromaDB_실제:
        인덱스_자동_생성: 아마도_예
        
        확인_필요:
          - ChromaDB 문서 확인
          - 실제 테스트
          - 프로파일링
    
    복합_Filter_비용:
      
      단일_Filter:
        {"agent_view": "guestimation"}
        조회: 1번
        시간: 0.001초
      
      복합_Filter:
        {
          "agent_view": "guestimation",
          "guestimation_domain": "Food_Service",
          "guestimation_region": "한국"
        }
        
        조회_방식:
          
          옵션_A_AND_연산:
            agent_view_인덱스 → 2,000개
            AND domain_인덱스 → 300개
            AND region_인덱스 → 50개
            
            시간: 0.003초 (3번 조회)
          
          옵션_B_복합_인덱스:
            (agent_view, domain)_인덱스
            → 300개 바로 찾기
            
            시간: 0.001초
          
          ChromaDB는_아마도: 옵션_A
          
          영향: 무시 가능 (0.002초 차이)
  
  한계_2_Filter_안_되는_경우:
    
    시나리오:
      
      범위_검색:
        원하는_것:
          filter: {"guestimation_value": "> 2000만원"}
        
        ChromaDB_지원:
          기본적으로_등호만: "="
          범위_연산: 제한적
        
        해결:
          1. 전체_검색_후_필터링 (느림)
          2. 별도_인덱스 (복잡)
          3. 포기 (범위 검색 안 함)
      
      OR_연산:
        원하는_것:
          filter: {"region": "한국" OR "서울"}
        
        ChromaDB_지원:
          기본적으로_AND만
          OR는_제한적_or_없음
        
        해결:
          1. 검색_2번 (병합)
          2. 포기
      
      임베딩_검색:
        원하는_것:
          filter: {"유사도 > 0.8"}
        
        불가능:
          필터는_메타데이터만
          유사도는_검색_후_알_수_있음
    
    영향:
      Guestimation_사용_케이스:
        - 대부분 간단한 필터 (agent_view, domain)
        - 범위/OR/유사도 필터 불필요
        
        영향: 없음! ✅
  
  한계_3_Filter_실행_순서:
    
    문제:
      
      Filter는_벡터_검색_전:
        순서:
          1. Filter (메타데이터)
          2. 벡터 검색 (필터된 것)
        
        의미:
          벡터_유사도를_Filter로_못_씀!
      
      시나리오:
        원하는_것:
          "유사도 높은 것 중 domain=SaaS인 것"
        
        ChromaDB:
          1. domain=SaaS 필터 (먼저)
          2. 유사도 검색 (domain=SaaS 중에서)
        
        문제:
          유사도_최고인_것이_domain=Finance면?
          → 못 찾음!
      
      해결:
        1. Filter_느슨하게
        2. 후처리_필터링
        3. 재검색
    
    영향:
      Guestimation:
        - 맥락 정확히 일치하는 것만 원함
        - 이 순서가 오히려 적합!
        
        영향: 없음! ✅

---

# ═══════════════════════════════════════════════════════
# PART 7: 성능 벤치마크 (이론)
# ═══════════════════════════════════════════════════════

theoretical_benchmark:
  
  전제:
    ChromaDB: HNSW
    임베딩: 3072 dim
    Filter: 인덱스 있음
  
  시나리오별_예상:
    
    작은_DB:
      청크_수: 100개
      
      Filter_없음: 0.05초
      Filter_있음: 0.03초
      
      차이: 40% 빠름
    
    중간_DB:
      청크_수: 1,000개
      
      Filter_없음: 0.15초
      Filter_있음:
        대상_30%: 0.08초
        대상_70%: 0.12초
      
      차이: 20-50% 빠름
    
    큰_DB:
      청크_수: 10,000개
      
      Filter_없음: 0.5초
      Filter_있음:
        대상_10%: 0.15초
        대상_30%: 0.25초
      
      차이: 50-70% 빠름
    
    Guestimation_케이스:
      전체: 2,698개
      
      Filter: {"agent_view": "guestimation"}
      대상: 2,000개 (74%)
      
      예상:
        Filter_없음: 0.35초
        Filter_있음: 0.25초
      
      차이: 28% 빠름!
  
  결론:
    
    Filter는:
      - 성능_저하_방지_아님
      - 성능_향상_도구! ⭐
    
    효과:
      - 청크 증가해도 영향 적음
      - 오히려 빠를 수 있음

---

# ═══════════════════════════════════════════════════════
# PART 8: 실전 검증 필요 사항
# ═══════════════════════════════════════════════════════

validation_needed:
  
  검증_1_ChromaDB_인덱싱:
    
    질문:
      - 메타데이터에 자동 인덱스 생성되나?
      - 어떤 필드에?
      - 복합 인덱스 지원?
    
    검증_방법:
      - ChromaDB 문서 확인
      - 실제 데이터로 테스트
      - EXPLAIN 같은 기능 있나?
    
    중요도: 높음
  
  검증_2_Filter_성능:
    
    테스트_케이스:
      1. 700개 → 2,700개 증가
      2. Filter 있음 vs 없음
      3. 복합 Filter (2-3개 조건)
    
    측정:
      - 응답 시간
      - 메모리 사용
      - CPU 사용
    
    중요도: 높음
  
  검증_3_스케일링:
    
    시뮬레이션:
      - 5,000개
      - 10,000개
      - 20,000개
    
    질문:
      - 어느 시점에 느려지나?
      - Filter로 완화되나?
      - 대안 필요한가?
    
    중요도: 중간 (장기)

---

# ═══════════════════════════════════════════════════════
# PART 9: 최악의 경우 대응
# ═══════════════════════════════════════════════════════

worst_case_scenario:
  
  최악_시나리오:
    
    가정:
      - ChromaDB에 메타데이터 인덱스 없음
      - Filter = 선형 스캔 (O(N))
      - 2,700개 모두 체크
    
    성능:
      필터링: 0.05초 (2,700개 스캔)
      벡터_검색: 0.25초 (2,000개)
      총: 0.30초
    
    평가:
      목표: <0.5초 (Tier 1)
      실제: 0.30초
      
      여전히_OK! ✅
  
  대응_1_Collection_분리:
    
    트리거:
      IF 검색_시간 > 0.5초:
        → Collection 분리 고려
    
    방법:
      - tier1_learned_rules 별도 생성
      - Canonical 데이터 복사
      - 검색 로직만 교체
    
    비용:
      - 개발: 1일
      - 데이터 중복: 허용
    
    타이밍: "문제 발생 시"
  
  대응_2_샤딩:
    
    방법:
      projected_index_분리:
        - projected_index_agents (기존 Agent)
        - projected_index_guestimation (Guestimation)
    
    효과:
      - 각각 작은 Collection
      - 검색 빠름
      - 하지만 관리 복잡
    
    타이밍: "5,000개 이상"
  
  대응_3_인덱스_최적화:
    
    방법:
      - ChromaDB 설정 튜닝
      - 인덱스 재구축
      - 캐시 증가
    
    타이밍: "먼저 시도"

---

# ═══════════════════════════════════════════════════════
# PART 10: 결론 및 권장사항
# ═══════════════════════════════════════════════════════

conclusion:
  
  Filter_메커니즘_이해:
    
    핵심:
      - Filter = DB 레벨 사전 필터링
      - 메타데이터 인덱스 활용
      - 벡터 검색 전 대상 축소
    
    성능:
      - O(1) or O(log M) 필터링
      - 청크 증가해도 영향 적음
      - 오히려 빠를 수 있음
  
  Guestimation_통합_성능:
    
    예상:
      Explorer_검색: 영향 없음 (0.1초 유지)
      Guestimation_검색: 0.2-0.3초 (목표 내)
      복합_Filter: 0.03-0.1초 (매우 빠름)
    
    평가:
      목표: <0.5초
      실제: 0.1-0.3초
      여유: 충분! ✅
  
  리스크_평가:
    
    성능_리스크:
      확률: 낮음
      
      이유:
        - Filter 메커니즘 강력
        - 이론적으로 영향 적음
        - 실제 테스트 필요하지만 낙관적
      
      완화:
        - 실제 벤치마크
        - 모니터링
        - 대응 계획
      
      잔여_리스크: 매우_낮음
  
  최종_판단:
    
    Filter_덕분에:
      - 성능 단점 거의 없음
      - Projected 4배 증가 허용 가능
      - Canonical-Projected 통합 안전
    
    권장:
      ✅ Canonical-Projected 통합
      ✅ Filter 필수 사용
      ✅ 성능 모니터링
      ✅ 최악의 경우 대응 계획
    
    확신도: 높음 (85%)

---

# ═══════════════════════════════════════════════════════
# PART 11: 구현 시 주의사항
# ═══════════════════════════════════════════════════════

implementation_notes:
  
  필수_사항:
    
    1_Filter_항상_사용:
      
      모든_검색_API:
        filter_파라미터: required (필수!)
        
        나쁜_예:
          search(query)  # filter 없음 ❌
        
        좋은_예:
          search(query, filter={"agent_view": "guestimation"})  ✅
      
      강제_방법:
        API_설계:
          def search_guestimation_rules(query, context):
            # filter 자동 추가
            filter = {"agent_view": "guestimation"}
            
            # context 기반 추가
            if context.domain:
              filter["guestimation_domain"] = context.domain
            
            return projected_index.search(query, filter=filter)
    
    2_메타데이터_인덱스_확인:
      
      확인_방법:
        ChromaDB_문서:
          - 인덱스 자동 생성 여부
          - 커스텀 인덱스 방법
        
        실제_테스트:
          - 100개, 1,000개, 10,000개
          - 성능 비교
          - 로그 분석
      
      필요_시:
        명시적_인덱스_생성:
          collection.create_index("agent_view")
          collection.create_index("guestimation_domain")
    
    3_성능_모니터링:
      
      메트릭:
        - 검색_시간 (p50, p95)
        - 청크_수
        - 메모리_사용
      
      알람:
        IF p95 > 0.5초:
          → 경고
        
        IF p95 > 1.0초:
          → 조치 필요
      
      대시보드:
        - Grafana or 간단한 로그
        - 일일 체크
  
  권장_사항:
    
    1_점진적_증가:
      
      단계:
        Week 1: 10개 규칙
        Week 2: 50개
        Week 4: 200개
        Month 3: 1,000개
      
      각_단계마다:
        - 성능 측정
        - 문제 조기 발견
        - 대응 시간 확보
    
    2_주기적_정리:
      
      정책:
        - 6개월 미사용 → 아카이브
        - 검증 실패 → 제거
        - Active 규칙만 유지
      
      효과:
        - 청크 수 제한 (<3,000개)
        - 성능 유지
    
    3_대안_준비:
      
      IF 성능_문제:
        Plan_B: Collection 분리
        Plan_C: 샤딩
        Plan_D: 별도 DB

---

# ═══════════════════════════════════════════════════════
# END - Filter 성능 분석 완료
# ═══════════════════════════════════════════════════════

