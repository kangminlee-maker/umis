# ChromaDB Collection 구조 명확화
# "View"는 개념일 뿐, 실제는 모두 같은 Collection에 저장됨

meta:
  version: "1.0"
  date: "2025-11-07"
  purpose: "ChromaDB Collection과 agent_view 개념 명확화"

---

# ═══════════════════════════════════════════════════════
# PART 1: 핵심 혼동 해소
# ═══════════════════════════════════════════════════════

clarification:
  
  용어_정의:
    
    ChromaDB_Collection:
      개념: "실제 데이터 저장소 (DB의 Table과 유사)"
      
      예시:
        - explorer_knowledge_base (Collection 이름)
        - projected_index (Collection 이름)
        - canonical_index (Collection 이름)
      
      특징:
        - 물리적 저장소
        - 각각 독립적
        - 각각 임베딩 보유
    
    agent_view:
      개념: "메타데이터 필드일 뿐 (단순 태그)"
      
      위치: "metadata.agent_view"
      
      값: "explorer | quantifier | guestimation | ..."
      
      특징:
        - Collection 안의 분류
        - SQL의 WHERE 조건 같은 것
        - 물리적 분리 아님
    
    View:
      개념: "개념적 구분 (SQL View와 다름!)"
      
      의미:
        - "explorer view" = agent_view가 "explorer"인 청크들
        - "guestimation view" = agent_view가 "guestimation"인 청크들
      
      실제:
        - 모두 같은 Collection (projected_index)
        - 메타데이터로 구분만
        - SQL View처럼 별도 저장소 아님!
  
  혼동_해소:
    
    제가_잘못_설명:
      "projected_index에 guestimation view 추가"
      
      오해_가능:
        - View가 별도 저장소?
        - View가 Collection?
        - 데이터가 어디 저장?
    
    정확한_의미:
      "projected_index Collection에 
       agent_view='guestimation'인 청크들 추가"
      
      명확:
        - Collection: projected_index (하나)
        - 청크: agent_view 메타데이터로 구분
        - 모두 같은 DB에 저장

---

# ═══════════════════════════════════════════════════════
# PART 2: 실제 데이터 저장 구조
# ═══════════════════════════════════════════════════════

actual_storage_structure:
  
  ChromaDB_Collections:
    
    현재_13개:
      
      1_canonical_index:
        Collection_이름: "canonical_index"
        
        저장_데이터:
          - CAN-subscription-001 (구독 모델 패턴)
          - CAN-netflix-001 (Netflix 사례)
          - CAN-amazon-001 (Amazon 사례)
          - ...
          총: ~100개
      
      2_projected_index:
        Collection_이름: "projected_index"
        
        저장_데이터:
          - PRJ-subscription-exp-001 (agent_view="explorer")
          - PRJ-subscription-qnt-001 (agent_view="quantifier")
          - PRJ-netflix-exp-002 (agent_view="explorer")
          - PRJ-netflix-qnt-002 (agent_view="quantifier")
          - ...
          총: ~700개
        
        메타데이터_필드:
          agent_view: "explorer | quantifier | validator | observer"
          
          구분:
            agent_view="explorer": 354개 청크
            agent_view="quantifier": 130개 청크
            agent_view="validator": 134개 청크
            agent_view="observer": 80개 청크
      
      3_explorer_knowledge_base:
        (별도 Collection, 역사적 이유)
      
      4_calculation_methodologies:
        (Quantifier 전용 Collection)
      
      # ... 나머지 Collections
  
  통합_후_13개_그대로:
    
    1_canonical_index:
      Collection_이름: "canonical_index" (동일)
      
      저장_데이터:
        기존:
          - CAN-subscription-001 (패턴)
          - CAN-netflix-001 (사례)
        
        추가: ⭐
          - CAN-learned-food-001 (학습 규칙)
          - CAN-user-saas-001 (사용자 기여)
        
        총: ~100개 → ~600개 (6배 증가)
      
      청크_구분:
        metadata.chunk_type:
          - "business_model_pattern"
          - "success_case"
          - "learned_estimation_rule" ⭐
    
    2_projected_index:
      Collection_이름: "projected_index" (동일)
      
      저장_데이터:
        기존:
          - PRJ-subscription-exp-001 (agent_view="explorer")
          - PRJ-subscription-qnt-001 (agent_view="quantifier")
          - ...
          총: 700개
        
        추가: ⭐
          - PRJ-learned-food-gst-001 (agent_view="guestimation")
          - PRJ-user-saas-gst-002 (agent_view="guestimation")
          - ...
          총: +2,000개
        
        전체: 700 + 2,000 = 2,700개
      
      메타데이터_필드:
        agent_view: "explorer | quantifier | ... | guestimation" ⭐
        
        구분:
          agent_view="explorer": 354개
          agent_view="quantifier": 130개
          agent_view="guestimation": 2,000개 ⭐

---

# ═══════════════════════════════════════════════════════
# PART 3: 데이터 저장 예시
# ═══════════════════════════════════════════════════════

data_storage_example:
  
  Canonical_Index_청크:
    
    청크_1_기존_패턴:
      
      Collection: "canonical_index"
      
      Document:
        id: "CAN-subscription-001"
        
        embedding: [0.123, -0.456, ...] (3072 dim)
        
        document: "구독 모델 패턴 전체 내용..."
        
        metadata:
          chunk_id: "CAN-subscription-001"
          chunk_type: "business_model_pattern"
          
          domain: "B2B_SaaS"
          pattern_id: "subscription_model"
          
          sections:
            - agent_view: "explorer"
              anchor_path: "subscription_model.trigger"
            - agent_view: "quantifier"
              anchor_path: "subscription_model.metrics"
            - agent_view: "guestimation" ⭐
              anchor_path: "subscription_model.estimation_data"
    
    청크_2_학습_규칙:
      
      Collection: "canonical_index" (같은 Collection!)
      
      Document:
        id: "CAN-learned-food-001"
        
        embedding: [0.789, -0.123, ...] (3072 dim)
        
        document: "한국 음식점 월매출 2,700만원..."
        
        metadata:
          chunk_id: "CAN-learned-food-001"
          chunk_type: "learned_estimation_rule" ⭐
          
          # Guestimation 필드
          guestimation_question: "한국 음식점 월매출은?"
          guestimation_metric: "monthly_revenue"
          guestimation_value: 2700만원
          guestimation_domain: "Food_Service"
          guestimation_region: "한국"
          
          # Provenance
          tier_origin: "tier2"
          learned_at: "2024-11-07"
          usage_count: 10
          
          sections:
            - agent_view: "guestimation" ⭐
              anchor_path: "learned_rules.food_service.monthly_revenue"
  
  Projected_Index_청크:
    
    청크_1_Explorer_View:
      
      Collection: "projected_index"
      
      Document:
        id: "PRJ-subscription-exp-001"
        
        embedding: [0.234, -0.567, ...]
        
        document: "구독 모델 Explorer 관점 내용..."
        
        metadata:
          projected_chunk_id: "PRJ-subscription-exp-001"
          canonical_chunk_id: "CAN-subscription-001"
          
          agent_view: "explorer" ⭐
          
          explorer_pattern_id: "subscription_model"
          explorer_csf: [...]
    
    청크_2_Guestimation_View:
      
      Collection: "projected_index" (같은 Collection!)
      
      Document:
        id: "PRJ-learned-food-gst-001"
        
        embedding: [0.891, -0.234, ...]
        
        document: "한국 음식점 월매출 2,700만원..."
        
        metadata:
          projected_chunk_id: "PRJ-learned-food-gst-001"
          canonical_chunk_id: "CAN-learned-food-001"
          
          agent_view: "guestimation" ⭐
          
          guestimation_question: "한국 음식점 월매출은?"
          guestimation_value: 2700만원
          guestimation_domain: "Food_Service"
          guestimation_region: "한국"

---

# ═══════════════════════════════════════════════════════
# PART 4: Collection vs View 비교
# ═══════════════════════════════════════════════════════

collection_vs_view:
  
  비교:
    
    SQL_세계:
      
      Table:
        개념: "물리적 저장소"
        예시: "users 테이블"
        데이터: "실제로 디스크에 저장"
      
      View:
        개념: "가상 테이블 (쿼리 저장)"
        예시: "CREATE VIEW active_users AS SELECT * FROM users WHERE active=true"
        데이터: "실제 저장 안 됨, 쿼리만"
        
        조회_시:
          - 쿼리 실행
          - 결과 생성
          - 리턴
      
      Materialized_View:
        개념: "실체화된 뷰 (결과 저장)"
        예시: "CREATE MATERIALIZED VIEW ..."
        데이터: "쿼리 결과를 물리적으로 저장"
        
        조회_시:
          - 저장된 결과 리턴 (빠름!)
          - 주기적 갱신 필요
    
    ChromaDB_세계:
      
      Collection:
        개념: "물리적 저장소 (SQL Table과 유사)"
        예시: "projected_index"
        데이터: "실제로 저장됨"
        
        특징:
          - 각 청크마다 임베딩 저장
          - 메타데이터 저장
      
      View_개념:
        개념: "메타데이터 필터링 (개념적 구분만)"
        예시: "agent_view='explorer'인 청크들"
        데이터: "projected_index Collection에 실제 저장됨" ⭐
        
        조회_시:
          filter = {"agent_view": "explorer"}
          → Collection에서 필터링
          → 결과 리턴
        
        차이:
          - SQL View가 아님!
          - 단지 메타데이터 필터일 뿐
          - 데이터는 모두 Collection에 저장

---

# ═══════════════════════════════════════════════════════
# PART 5: 실제 저장 구조
# ═══════════════════════════════════════════════════════

actual_storage:
  
  파일_시스템:
    
    ChromaDB_디렉토리:
      
      data/chroma/
        
        canonical_index/
          설명: "Collection: canonical_index"
          
          파일:
            - index/  (벡터 인덱스)
            - metadata.db  (SQLite, 메타데이터)
            - embeddings.bin  (임베딩 벡터)
          
          저장_데이터:
            - CAN-subscription-001
            - CAN-netflix-001
            - CAN-learned-food-001 ⭐
            - ...
            
            총: ~600개 청크
        
        projected_index/
          설명: "Collection: projected_index"
          
          파일:
            - index/
            - metadata.db ⭐
            - embeddings.bin
          
          저장_데이터:
            모두_이_Collection에:
              - PRJ-subscription-exp-001 (agent_view="explorer")
              - PRJ-subscription-qnt-001 (agent_view="quantifier")
              - PRJ-learned-food-gst-001 (agent_view="guestimation") ⭐
              - ...
            
            총: ~2,700개 청크
          
          metadata.db_구조:
            
            테이블_추정:
              chunks 테이블:
                | id | embedding_id | document | metadata_json |
                |----|--------------|----------|---------------|
                | 1  | emb_1        | "..."    | {"agent_view": "explorer", ...} |
                | 2  | emb_2        | "..."    | {"agent_view": "quantifier", ...} |
                | 700| emb_700      | "..."    | {"agent_view": "guestimation", ...} ⭐|
                | ...| ...          | ...      | ... |
              
              메타데이터_인덱스:
                CREATE INDEX idx_agent_view ON chunks(metadata.agent_view)
                
                → 빠른 조회 가능
        
        explorer_knowledge_base/
          (별도 Collection, 역사적)
        
        # ... 다른 Collections

---

# ═══════════════════════════════════════════════════════
# PART 6: 검색 동작 상세
# ═══════════════════════════════════════════════════════

search_operation:
  
  Explorer_검색:
    
    코드:
      from umis_rag.agents.explorer import ExplorerRAG
      
      explorer = ExplorerRAG()
      results = explorer.search_patterns("구독 모델")
    
    내부_동작:
      
      1_Collection_선택:
        collection_name = "projected_index"
      
      2_Filter_설정:
        filter = {"agent_view": "explorer"}
      
      3_ChromaDB_호출:
        collection.query(
          query_embeddings=[...],
          where={"agent_view": "explorer"},  ⭐
          n_results=5
        )
      
      4_ChromaDB_내부:
        
        Step_A_메타데이터_필터:
          SQL_유사_쿼리:
            SELECT id, embedding_id 
            FROM chunks 
            WHERE metadata->>'agent_view' = 'explorer'
          
          결과_ID: [1, 2, 3, ..., 354]
          
          시간: 0.001초 (인덱스 사용)
        
        Step_B_벡터_검색:
          대상: 354개 청크만 (전체 2,700개 아님!)
          
          각_청크마다:
            유사도 = cosine_similarity(query_emb, chunk_emb)
          
          Top_5_선택
          
          시간: 0.1초
        
        Step_C_결과_리턴:
          5개 청크 (Document + score)
      
      전체_시간: 0.101초
  
  Guestimation_검색:
    
    코드:
      from umis_rag.guestimation.searcher import GuestimationSearcher
      
      searcher = GuestimationSearcher()
      results = searcher.search_learned_rule("한국 음식점 월매출은?")
    
    내부_동작:
      
      1_Collection_선택:
        collection_name = "projected_index" (동일!)
      
      2_Filter_설정:
        filter = {"agent_view": "guestimation"} ⭐
      
      3_ChromaDB_호출:
        collection.query(
          query_embeddings=[...],
          where={"agent_view": "guestimation"},  ⭐
          n_results=5
        )
      
      4_ChromaDB_내부:
        
        Step_A_메타데이터_필터:
          SELECT id, embedding_id
          FROM chunks
          WHERE metadata->>'agent_view' = 'guestimation'
          
          결과_ID: [700, 701, ..., 2699]
          
          시간: 0.001초 (인덱스)
        
        Step_B_벡터_검색:
          대상: 2,000개 청크
          
          시간: 0.25초
        
        Step_C_결과_리턴
      
      전체_시간: 0.251초

---

# ═══════════════════════════════════════════════════════
# PART 7: Collection 증가 여부
# ═══════════════════════════════════════════════════════

collection_count:
  
  질문: "Collection이 증가하는가?"
  
  답변: "아니오, 그대로 13개" ✅
  
  상세:
    
    Before:
      Collections:
        1. canonical_index
        2. projected_index
        3. explorer_knowledge_base
        4-13. (기타)
      
      총: 13개
    
    After:
      Collections:
        1. canonical_index (확장됨, 하지만 같은 Collection)
        2. projected_index (확장됨, 하지만 같은 Collection)
        3. explorer_knowledge_base
        4-13. (기타)
      
      총: 13개 (그대로!)
    
    변화:
      Collection_수: 변화_없음 ✅
      
      청크_수:
        canonical_index: 100 → 600개
        projected_index: 700 → 2,700개
      
      디렉토리_구조: 변화_없음
  
  별도_Collection이었다면:
    
    Collections:
      1-13. (기존)
      14. tier1_learned_rules ⭐
    
    총: 14개
    
    차이:
      - Collection +1개
      - 디렉토리 +1개
      - 관리 포인트 +1개

---

# ═══════════════════════════════════════════════════════
# PART 8: View의 물리적 실체
# ═══════════════════════════════════════════════════════

view_physical_reality:
  
  SQL_Materialized_View와_비교:
    
    SQL:
      CREATE MATERIALIZED VIEW explorer_chunks AS
        SELECT * FROM projected_index 
        WHERE agent_view = 'explorer'
      
      결과:
        - 별도 테이블 생성 (물리적 복사)
        - 저장 공간 2배
        - 동기화 필요
    
    ChromaDB_agent_view:
      
      실제:
        - 별도 테이블 없음!
        - 모두 projected_index에 저장
        - agent_view는 메타데이터 필드
        - 동기화 불필요 (같은 데이터니까)
      
      조회:
        filter = {"agent_view": "explorer"}
        → projected_index에서 필터링
        → 마치 별도 Collection처럼 보임
        → 하지만 실제로는 같은 곳!
  
  개념적_View:
    
    의미:
      "explorer view" = 개념적 구분
      
      실제: agent_view="explorer"인 청크들
      
      물리: projected_index Collection
    
    장점:
      - 저장 공간 효율적
      - 관리 단순
      - 동기화 불필요
    
    단점:
      - 개념적으로 약간 혼란
      - "view"가 실제 entity 아님

---

# ═══════════════════════════════════════════════════════
# PART 9: 정확한 답변
# ═══════════════════════════════════════════════════════

precise_answer:
  
  질문_1: "guestimation 관련 chunk는 어떤 collection에 저장되는가?"
  
  답변:
    
    Canonical_청크:
      Collection: "canonical_index" ✅
      
      저장_내용:
        - 기존 패턴/사례 청크
        - 학습된 규칙 청크 ⭐ (추가)
        - 사용자 기여 청크 ⭐ (추가)
      
      구분:
        metadata.chunk_type:
          - "business_model_pattern"
          - "learned_estimation_rule" ⭐
    
    Projected_청크:
      Collection: "projected_index" ✅
      
      저장_내용:
        - 기존 Agent view 청크들
        - guestimation view 청크들 ⭐ (추가)
      
      구분:
        metadata.agent_view:
          - "explorer"
          - "quantifier"
          - "guestimation" ⭐
  
  질문_2: "collection 없이 view만 늘어나는 건가?"
  
  답변:
    "정확히는, Collection은 그대로이고,
     그 Collection 안의 청크만 늘어남" ✅
    
    상세:
      Collection_수: 13개 (그대로)
      
      projected_index_안에:
        agent_view="explorer": 354개
        agent_view="quantifier": 130개
        agent_view="guestimation": 0 → 2,000개 ⭐
      
      "view"는_개념:
        - 실제 entity 아님
        - 메타데이터 분류일 뿐
  
  질문_3: "그렇다면 데이터는 어떻게 저장하지?"
  
  답변:
    "projected_index Collection에 실제 저장됨" ✅
    
    저장_과정:
      
      1_Canonical_추가:
        collection_name = "canonical_index"
        
        document_add:
          id: "CAN-learned-food-001"
          embedding: [...]
          document: "..."
          metadata: {..., chunk_type: "learned_estimation_rule"}
      
      2_Projected_생성:
        collection_name = "projected_index"
        
        document_add:
          id: "PRJ-learned-food-gst-001"
          embedding: [...]
          document: "..."
          metadata: {..., agent_view: "guestimation"} ⭐
      
      결과:
        - 2개 Collection에 각각 1개씩 저장
        - projected_index 청크 +1
        - canonical_index 청크 +1

---

# ═══════════════════════════════════════════════════════
# PART 10: 혼동 방지 용어 정리
# ═══════════════════════════════════════════════════════

terminology_clarification:
  
  올바른_표현:
    
    ✅ "projected_index Collection에 guestimation 청크 추가"
    
    ✅ "agent_view='guestimation'인 청크들"
    
    ✅ "projected_index가 2,700개로 증가"
    
    ✅ "guestimation 청크는 projected_index에 저장"
  
  혼동_유발_표현:
    
    ❌ "guestimation view 추가"
      → view가 별도 entity처럼 들림
    
    ❌ "guestimation Collection"
      → Collection이 추가되는 것처럼 들림
    
    ❌ "view가 늘어남"
      → view가 물리적 객체처럼 들림
  
  앞으로_사용할_표현:
    
    정확한_표현:
      "projected_index Collection에 
       agent_view='guestimation' 메타데이터를 가진 
       청크들을 추가한다"
    
    간단한_표현:
      "projected_index에 guestimation 청크 추가"

---

# ═══════════════════════════════════════════════════════
# PART 11: 최종 정리
# ═══════════════════════════════════════════════════════

final_summary:
  
  Collection_구조:
    
    Collection_수:
      Before: 13개
      After: 13개 ✅
      
      변화: 없음!
    
    Collection_내용:
      
      canonical_index:
        Before: 100개 청크
        After: 600개 청크
        
        추가된_청크:
          - learned_estimation_rule (학습 규칙)
          - user_contributed (사용자 기여)
        
        구분_방법:
          metadata.chunk_type
      
      projected_index:
        Before: 700개 청크
        After: 2,700개 청크
        
        추가된_청크:
          agent_view="guestimation"인 청크들
        
        구분_방법:
          metadata.agent_view
  
  저장_위치:
    
    모든_guestimation_데이터:
      
      Canonical_형태:
        Collection: canonical_index
        위치: data/chroma/canonical_index/
        개수: +500개
      
      Projected_형태:
        Collection: projected_index
        위치: data/chroma/projected_index/
        개수: +2,000개
    
    별도_저장소_없음:
      - 새 Collection 생성 안 함
      - 새 디렉토리 생성 안 함
      - 기존 Collection에 추가만
  
  View의_실체:
    
    View는:
      - 개념적 구분일 뿐
      - 물리적 entity 아님
      - 메타데이터 필터링 패턴
    
    실제_저장:
      - 모두 Collection에 저장
      - agent_view 메타데이터로 구분
      - 검색 시 filter로 선택
  
  성능_영향:
    
    Filter_덕분에:
      - 청크 증가해도 영향 적음
      - 각 Agent는 자기 것만 검색
      - 격리됨

---

# ═══════════════════════════════════════════════════════
# END - Collection 구조 명확화 완료
# ═══════════════════════════════════════════════════════

