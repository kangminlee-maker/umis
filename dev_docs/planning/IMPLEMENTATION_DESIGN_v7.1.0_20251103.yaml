# ========================================
# UMIS v7.1.0 êµ¬í˜„ ì„¤ê³„ë„
# ========================================
#
# ì‘ì„±ì¼: 2025-11-03
# ìµœì¢… ì—…ë°ì´íŠ¸: 2025-11-03 (í”¼ë“œë°± ë°˜ì˜)
# ëŒ€ìƒ ë²„ì „: v7.1.0 ~ v7.3.0
# 3ëŒ€ í•µì‹¬ í”„ë¡œì íŠ¸ ìƒì„¸ êµ¬í˜„ ì„¤ê³„
#
# ========================================

_meta:
  version: "7.1.0"
  created: "2025-11-03"
  updated: "2025-11-03"
  projects: 3
  total_duration: "4ê°œì›”"
  
  feedback_applied:
    date: "2025-11-03"
    reviewer: "ë™ë£Œ í”¼ë“œë°±"
    critical_fixes: 6
    improvements: 4
    
    changes:
      excel_bugs_fixed:
        - "Named Range ì ˆëŒ€ì°¸ì¡° ($D$5)"
        - "'SAM' ì…€ â†’ Named Range 2ë‹¨ê³„ ì •ì˜"
        - "ì¡°ê±´ë¶€ ì„œì‹ FormulaRuleë¡œ ë³€ê²½"
        - "fullCalcOnLoad=True ì¶”ê°€"
      
      system_rag_hardened:
        - "tool_key ë©”íƒ€ë°ì´í„° ì¶”ê°€"
        - "Key-first Â· Vector-fallback 2ë‹¨ê³„ ê²€ìƒ‰"
        - "ìœ ì‚¬ë„ 1.0 â†’ match_type ëª…í™•í™”"
      
      architecture_improvements:
        - "KeyDirectory O(1) ì •í™• ë§¤ì¹­"
        - "Golden-Workbook í…ŒìŠ¤íŠ¸ ì¶”ê°€"
        - "ê²°ì •ì„± í…ŒìŠ¤íŠ¸ ì¶”ê°€"

# ========================================
# í”„ë¡œì íŠ¸ 1: Excel ìë™ ìƒì„± ì‹œìŠ¤í…œ
# ========================================

project_1_excel_generation:
  
  name: "Deliverable Excel ìë™ ìƒì„±"
  priority: "P1 (ë†’ìŒ)"
  duration: "6ì£¼"
  target_version: "v7.1.0 ~ v7.2.0"
  
  goal:
    primary: "Billì˜ market_sizing.xlsxë¥¼ ì™„ë²½í•œ í•¨ìˆ˜ë¡œ ìë™ ìƒì„±"
    success_criteria:
      - "9ê°œ ì‹œíŠ¸ ëª¨ë‘ ìƒì„±"
      - "ëª¨ë“  ê³„ì‚°ì´ Excel í•¨ìˆ˜ë¡œ êµ¬í˜„"
      - "Named Rangeë¡œ ì°¸ì¡° ì•ˆì •ì„± ë³´ì¥"
      - "ì‹¤ì œ Excelì—ì„œ ì‘ë™ ê²€ì¦"
      - "Â±30% ìˆ˜ë ´ ìë™ í™•ì¸"
  
  # ========================================
  # Phase 1: í•¨ìˆ˜ ì—”ì§„ (2ì£¼)
  # ========================================
  
  phase_1_formula_engine:
    duration: "2ì£¼"
    files:
      - "umis_rag/deliverables/excel/formula_engine.py (500ì¤„)"
      - "umis_rag/deliverables/excel/named_range_manager.py (200ì¤„)"
      - "umis_rag/deliverables/excel/formula_validator.py (300ì¤„)"
    
    # --- Week 1: í•µì‹¬ ì—”ì§„ ---
    week_1_core_engine:
      
      file: "umis_rag/deliverables/excel/formula_engine.py"
      
      classes:
        
        FormulaEngine:
          purpose: "Excel í•¨ìˆ˜ ìƒì„± ë° ê´€ë¦¬"
          
          methods:
            
            __init__:
              params:
                - "workbook: Workbook"
              init:
                - "self.wb = workbook"
                - "self.named_ranges = {}"
                - "self.formula_cache = {}"
            
            define_named_range:
              purpose: "Named Range ì •ì˜ (ì°¸ì¡° ì•ˆì •ì„±)"
              params:
                - "name: str  # 'ASM_001'"
                - "sheet: str  # 'Assumptions'"
                - "cell: str  # 'D5'"
              
              implementation: |
                # openpyxl Named Range (ì ˆëŒ€ì°¸ì¡°!)
                from openpyxl.workbook.defined_name import DefinedName
                
                # ì…€ ì£¼ì†Œë¥¼ ì ˆëŒ€ì°¸ì¡°ë¡œ ë³€í™˜ (D5 â†’ $D$5)
                col_letter = ''.join(c for c in cell if c.isalpha())
                row_num = ''.join(c for c in cell if c.isdigit())
                abs_cell = f"${col_letter}${row_num}"
                
                defn = DefinedName(
                    name=name,
                    attr_text=f"'{sheet}'!{abs_cell}"  # ì ˆëŒ€ì°¸ì¡°
                )
                self.wb.defined_names.append(defn)
                self.named_ranges[name] = (sheet, cell)
              
              validation:
                - "ì´ë¦„ ì¤‘ë³µ ì²´í¬"
                - "ì…€ ë²”ìœ„ ìœ íš¨ì„±"
              
              return: "None"
            
            create_assumption_ref:
              purpose: "ê°€ì • ì°¸ì¡° í•¨ìˆ˜ ìƒì„±"
              params:
                - "asm_id: str  # 'ASM_001'"
              
              implementation: |
                if asm_id not in self.named_ranges:
                    raise ValueError(f"{asm_id} not defined")
                
                return f"={asm_id}"
              
              example:
                input: "ASM_001"
                output: "=ASM_001"
                excel_result: "Assumptions!D5 ê°’ ì°¸ì¡°"
            
            create_multiplication_chain:
              purpose: "ì—°ì‡„ ê³±ì…ˆ í•¨ìˆ˜"
              params:
                - "cells: list[str]  # ['B2', 'C2', 'D2']"
              
              implementation: |
                if not cells:
                    return "=0"
                
                return "=" + "*".join(cells)
              
              example:
                input: "['A2', 'B2', 'C2']"
                output: "=A2*B2*C2"
            
            create_sum:
              purpose: "í•©ê³„ í•¨ìˆ˜"
              params:
                - "range_ref: str  # 'B5:B10'"
              
              implementation: |
                return f"=SUM({range_ref})"
              
              example:
                input: "B5:B10"
                output: "=SUM(B5:B10)"
            
            create_average:
              purpose: "í‰ê·  í•¨ìˆ˜"
              implementation: |
                return f"=AVERAGE({range_ref})"
            
            create_stdev:
              purpose: "í‘œì¤€í¸ì°¨ í•¨ìˆ˜"
              implementation: |
                return f"=STDEV({range_ref})"
            
            create_convergence_formulas:
              purpose: "ìˆ˜ë ´ ë¶„ì„ í•¨ìˆ˜ë“¤"
              params:
                - "method_cells: list[str]  # ['B5', 'B6', 'B7', 'B8']"
              
              implementation: |
                cells_ref = ",".join(method_cells)
                
                return {
                    'average': f"=AVERAGE({cells_ref})",
                    'stdev': f"=STDEV({cells_ref})",
                    'cv': f"=STDEV({cells_ref})/AVERAGE({cells_ref})*100",
                    'max_min_ratio': f"=MAX({cells_ref})/MIN({cells_ref})",
                    'convergence_check': f'=IF(MAX({cells_ref})/MIN({cells_ref})<=1.3, "âœ… í†µê³¼", "âŒ ì¬ê²€í† ")'
                }
              
              return: "dict[str, str]"
            
            create_cross_sheet_ref:
              purpose: "ì‹œíŠ¸ ê°„ ì°¸ì¡°"
              params:
                - "sheet: str"
                - "cell: str"
              
              implementation: |
                # ì‹œíŠ¸ëª…ì— ê³µë°± ìˆìœ¼ë©´ ì‘ì€ë”°ì˜´í‘œ
                if ' ' in sheet:
                    return f"='{sheet}'!{cell}"
                return f"={sheet}!{cell}"
              
              example:
                input: "('Method_1_TopDown', 'F10')"
                output: "=Method_1_TopDown!F10"
            
            validate_formula:
              purpose: "í•¨ìˆ˜ ìœ íš¨ì„± ê²€ì¦"
              params:
                - "formula: str"
              
              checks:
                - "ë¬¸ë²• ì²´í¬ (= ì‹œì‘, ê´„í˜¸ ë§¤ì¹­)"
                - "ìˆœí™˜ ì°¸ì¡° ì²´í¬"
                - "ì°¸ì¡° ë²”ìœ„ ìœ íš¨ì„±"
                - "Named Range ì¡´ì¬ í™•ì¸"
              
              implementation: |
                # 1. ê¸°ë³¸ ë¬¸ë²•
                if not formula.startswith('='):
                    raise ValueError("í•¨ìˆ˜ëŠ” =ë¡œ ì‹œì‘")
                
                # 2. ê´„í˜¸ ë§¤ì¹­
                if formula.count('(') != formula.count(')'):
                    raise ValueError("ê´„í˜¸ ë¶ˆì¼ì¹˜")
                
                # 3. Named Range í™•ì¸
                for name in self.named_ranges:
                    if name in formula and name not in self.named_ranges:
                        raise ValueError(f"{name} not defined")
                
                return True
    
    # --- Week 2: ê²€ì¦ ì‹œìŠ¤í…œ ---
    week_2_validation:
      
      file: "umis_rag/deliverables/excel/formula_validator.py"
      
      classes:
        
        FormulaValidator:
          purpose: "í•¨ìˆ˜ ì •í™•ì„± ê²€ì¦ (ì‹¤ì œ Excel í•„ìš”)"
          
          methods:
            
            validate_workbook:
              purpose: "ì „ì²´ ì›Œí¬ë¶ ê²€ì¦"
              
              checks:
                
                named_ranges_check:
                  what: "ëª¨ë“  Named Range ì •ì˜ë¨"
                  how: |
                    for name in required_ranges:
                        if name not in wb.defined_names:
                            errors.append(f"{name} missing")
                
                formula_syntax_check:
                  what: "ëª¨ë“  í•¨ìˆ˜ ë¬¸ë²• ì •í™•"
                  how: |
                    for sheet in wb.worksheets:
                        for row in sheet.iter_rows():
                            for cell in row:
                                if isinstance(cell.value, str) and cell.value.startswith('='):
                                    validate_formula_syntax(cell.value)
                
                circular_reference_check:
                  what: "ìˆœí™˜ ì°¸ì¡° ì—†ìŒ"
                  how: |
                    dependency_graph = build_dependency_graph(wb)
                    if has_cycle(dependency_graph):
                        errors.append("ìˆœí™˜ ì°¸ì¡° ë°œê²¬")
                
                cross_sheet_check:
                  what: "ì‹œíŠ¸ ê°„ ì°¸ì¡° ìœ íš¨"
                  how: |
                    for ref in cross_sheet_refs:
                        if ref.sheet not in wb.sheetnames:
                            errors.append(f"ì‹œíŠ¸ {ref.sheet} ì—†ìŒ")
              
              return: "list[ValidationError]"
            
            test_in_excel:
              purpose: "ì‹¤ì œ Excelì—ì„œ ì‘ë™ í…ŒìŠ¤íŠ¸"
              note: "ê°€ì¥ ì¤‘ìš”! openpyxlì€ ê³„ì‚° ì•ˆí•¨"
              
              process:
                step_1: "Excel íŒŒì¼ ì €ì¥"
                step_2: "Excelì—ì„œ ì—´ê¸° (ìˆ˜ë™ ë˜ëŠ” win32com)"
                step_3: "ê³„ì‚° ê²°ê³¼ í™•ì¸"
                step_4: "ì˜ˆìƒ ê°’ê³¼ ë¹„êµ"
              
              example: |
                # ì €ì¥
                wb.save('test.xlsx')
                
                # Excelì—ì„œ ì—´ê¸° (Windows)
                import win32com.client
                excel = win32com.client.Dispatch("Excel.Application")
                wb_excel = excel.Workbooks.Open(os.path.abspath('test.xlsx'))
                
                # ê°’ í™•ì¸
                actual = wb_excel.Sheets('Convergence').Range('B9').Value
                expected = 270  # ì˜ˆìƒ í‰ê· 
                
                assert abs(actual - expected) < 1, "ê³„ì‚° ì˜¤ë¥˜"
              
              platforms:
                windows: "win32com (ì™„ì „ ì§€ì›)"
                mac: "ìˆ˜ë™ í™•ì¸ (ìë™í™” ì–´ë ¤ì›€)"
                linux: "LibreOffice --headless"
  
  # ========================================
  # Phase 2: ì‹œíŠ¸ ìƒì„±ê¸° (2ì£¼)
  # ========================================
  
  phase_2_sheet_builders:
    duration: "2ì£¼"
    files:
      - "umis_rag/deliverables/excel/assumptions_builder.py"
      - "umis_rag/deliverables/excel/method_builders.py"
      - "umis_rag/deliverables/excel/convergence_builder.py"
    
    # --- Week 3: ê¸°ë³¸ ì‹œíŠ¸ ---
    week_3_basic_sheets:
      
      assumptions_builder:
        file: "assumptions_builder.py"
        
        class AssumptionsSheetBuilder:
          
          create_sheet:
            input:
              assumptions:
                - id: "ASM_001"
                  category: "ì¸êµ¬"
                  description: "íƒ€ê²Ÿ ê³ ê° ìˆ˜"
                  value: 10000
                  unit: "ëª…"
                  data_type: "ì§ì ‘ë°ì´í„°"  # or "ì¶”ì •ì¹˜"
                  source: "SRC_20241031_001"  # or "EST_001"
                  confidence: "High"
                  notes: "í†µê³„ì²­ ê³µì‹"
            
            process:
              step_1_create_sheet:
                code: |
                  ws = wb.create_sheet("Assumptions", 0)
              
              step_2_headers:
                code: |
                  headers = ["ID", "Category", "Description", "Value", 
                            "Unit", "Data_Type", "Source", "Confidence", "Notes"]
                  ws.append(headers)
                  
                  # í—¤ë” ì„œì‹
                  for cell in ws[1]:
                      cell.font = Font(bold=True)
                      cell.fill = PatternFill(start_color="4472C4", fill_type="solid")
              
              step_3_data_rows:
                code: |
                  for i, asm in enumerate(assumptions, start=2):
                      ws.append([
                          asm['id'],
                          asm['category'],
                          asm['description'],
                          asm['value'],
                          asm['unit'],
                          asm['data_type'],
                          asm['source'],
                          asm['confidence'],
                          asm['notes']
                      ])
                      
                      # Named Range ì •ì˜ (ì¤‘ìš”!)
                      formula_engine.define_named_range(
                          asm['id'],  # "ASM_001"
                          "Assumptions",
                          f"D{i}"  # Value ì»¬ëŸ¼
                      )
                      
                      # ì„œì‹
                      ws[f'D{i}'].fill = INPUT_FILL  # ì…ë ¥ ì…€
                      ws[f'D{i}'].number_format = '#,##0'
                      
                      # ì½”ë©˜íŠ¸
                      if asm['data_type'] == 'ì¶”ì •ì¹˜':
                          comment = Comment(
                              f"ì¶”ì • ë…¼ë¦¬: {asm['source']} ì°¸ì¡°\n"
                              f"Estimation_Details ì‹œíŠ¸ í™•ì¸",
                              "Bill"
                          )
                          ws[f'A{i}'].comment = comment
              
              step_4_protection:
                code: |
                  # ì‹œíŠ¸ ë³´í˜¸
                  ws.protection.sheet = True
                  ws.protection.password = None
                  
                  # ì…ë ¥ ì…€ë§Œ í¸ì§‘ ê°€ëŠ¥
                  for row in ws.iter_rows(min_row=2):
                      row[3].protection = Protection(locked=False)  # Value ì»¬ëŸ¼
      
      method_1_topdown_builder:
        file: "method_builders.py"
        
        class Method1TopDownBuilder:
          
          create_sheet:
            input:
              tam:
                value: 1000000000000  # 1ì¡°
                definition: "ì „ì²´ ì•…ê¸° ì‹œì¥"
                source: "ASM_001"
              
              narrowing_steps:
                - dimension: "ì§€ì—­"
                  ratio_source: "ASM_002"
                  description: "í•œêµ­ ë¹„ì¤‘ 15%"
                
                - dimension: "ì œí’ˆ"
                  ratio_source: "ASM_003"
                  description: "í”¼ì•„ë…¸ë§Œ"
            
            process:
              step_1_layout:
                design: |
                  Row 1: ì°¨ì› ì´ë¦„ (TAM, ì§€ì—­, ì œí’ˆ, ...)
                  Row 2: ë¹„ìœ¨/ê³„ìˆ˜
                  Row 3: ê³„ì‚° ê²°ê³¼
                  Row 4: ì¶œì²˜ (ì½”ë©˜íŠ¸)
              
              step_2_tam_column:
                code: |
                  ws['A1'] = "TAM"
                  ws['A2'] = formula_engine.create_assumption_ref(tam['source'])
                  ws['A3'] = f"={tam['value']}"  # ë˜ëŠ” ì°¸ì¡°
                  
                  # ì½”ë©˜íŠ¸
                  ws['A3'].comment = Comment(f"ì¶œì²˜: {tam['source']}", "Bill")
              
              step_3_narrowing_columns:
                code: |
                  col = ord('B')
                  prev_result = "A3"
                  
                  for step in narrowing_steps:
                      col_letter = chr(col)
                      
                      # ì°¨ì› ì´ë¦„
                      ws[f'{col_letter}1'] = step['dimension']
                      
                      # ë¹„ìœ¨ (Named Range)
                      ws[f'{col_letter}2'] = formula_engine.create_assumption_ref(
                          step['ratio_source']
                      )
                      
                      # ê³„ì‚°: ì´ì „ Ã— ë¹„ìœ¨
                      ws[f'{col_letter}3'] = f"={prev_result}*{col_letter}2"
                      
                      # ì½”ë©˜íŠ¸
                      ws[f'{col_letter}3'].comment = Comment(
                          f"{step['description']}\nì¶œì²˜: {step['ratio_source']}",
                          "Bill"
                      )
                      
                      # ì„œì‹
                      ws[f'{col_letter}3'].fill = CALC_FILL
                      ws[f'{col_letter}3'].number_format = '#,##0'
                      
                      prev_result = f"{col_letter}3"
                      col += 1
                  
                  # ìµœì¢… SAM
                  final_col = chr(col - 1)
                  final_cell = f"{final_col}3"
                  
                  # Step 1: ì‹¤ì œ ì…€ì— ìˆ˜ì‹ ì‘ì„±
                  ws[final_cell] = f"={final_col}2*{chr(col-2)}3"  # ë§ˆì§€ë§‰ ê³„ì‚°
                  ws[final_cell].fill = RESULT_FILL
                  
                  # Step 2: ê·¸ ì…€ì„ ê°€ë¦¬í‚¤ëŠ” Named Range 'SAM' ì •ì˜ (Workbook-scope)
                  formula_engine.define_named_range(
                      name='SAM',
                      sheet='Method_1_TopDown',
                      cell=final_cell
                  )
              
              step_4_validation:
                code: |
                  # ë…¼ë¦¬ì  ìƒí•œ/í•˜í•œ í…ŒìŠ¤íŠ¸
                  ws['A10'] = "ê²€ì¦"
                  ws['A11'] = "TAM > SAM?"
                  ws['B11'] = f'=IF(A3>SAM, "âœ…", "âŒ")'
                  
                  ws['A12'] = "SAM > 0?"
                  ws['B12'] = f'=IF(SAM>0, "âœ…", "âŒ")'
      
      convergence_builder:
        
        class ConvergenceSheetBuilder:
          
          create_sheet:
            input:
              method_sheets:
                - "Method_1_TopDown"
                - "Method_2_BottomUp"
                - "Method_3_Proxy"
                - "Method_4_CompetitorRevenue"
              
              sam_cell: "SAM"  # ê° ì‹œíŠ¸ì˜ ìµœì¢… SAM ì…€
            
            process:
              step_1_method_results:
                code: |
                  ws = wb.create_sheet("Convergence_Analysis")
                  
                  # í—¤ë”
                  ws['A1'] = "Method"
                  ws['B1'] = "SAM (ì–µì›)"
                  ws['C1'] = "ì°¨ì´ (%)"
                  
                  # ê° Method ê²°ê³¼
                  for i, method in enumerate(method_sheets, start=2):
                      ws[f'A{i}'] = method
                      
                      # SAM ì°¸ì¡°
                      ws[f'B{i}'] = formula_engine.create_cross_sheet_ref(
                          method,
                          sam_cell
                      )
                      
                      # í‰ê·  ëŒ€ë¹„ ì°¨ì´ (ë‚˜ì¤‘ì— ê³„ì‚°)
                      ws[f'C{i}'] = f"=(B{i}-B$6)/B$6*100"
              
              step_2_statistics:
                code: |
                  # í‰ê· 
                  ws['A6'] = "í‰ê· "
                  ws['B6'] = formula_engine.create_average("B2:B5")
                  ws['B6'].fill = RESULT_FILL
                  
                  # í‘œì¤€í¸ì°¨
                  ws['A7'] = "í‘œì¤€í¸ì°¨"
                  ws['B7'] = formula_engine.create_stdev("B2:B5")
                  
                  # ë³€ë™ê³„ìˆ˜
                  ws['A8'] = "ë³€ë™ê³„ìˆ˜ (CV%)"
                  ws['B8'] = "=B7/B6*100"
                  
                  # Max/Min ë¹„ìœ¨
                  ws['A9'] = "Max/Min ë¹„ìœ¨"
                  ws['B9'] = "=MAX(B2:B5)/MIN(B2:B5)"
              
              step_3_convergence_check:
                code: |
                  # Â±30% ìˆ˜ë ´ í™•ì¸
                  ws['A10'] = "Â±30% ìˆ˜ë ´?"
                  ws['B10'] = '=IF(B9<=1.3, "âœ… í†µê³¼", "âŒ ì¬ê²€í†  í•„ìš”")'
                  
                  # ì¡°ê±´ë¶€ ì„œì‹ (FormulaRule ì‚¬ìš© - ì•ˆì •ì )
                  from openpyxl.formatting.rule import FormulaRule
                  from openpyxl.styles.differential import DifferentialStyle
                  
                  green_fill = PatternFill(start_color="C6EFCE", fill_type="solid")
                  red_fill = PatternFill(start_color="FFC7CE", fill_type="solid")
                  
                  # í†µê³¼ ì¡°ê±´ (âœ… í¬í•¨)
                  ws.conditional_formatting.add(
                      'B10',
                      FormulaRule(
                          formula=['NOT(ISERROR(SEARCH("âœ…",B10)))'],
                          dxf=DifferentialStyle(fill=green_fill)
                      )
                  )
                  
                  # ì‹¤íŒ¨ ì¡°ê±´ (âŒ í¬í•¨)
                  ws.conditional_formatting.add(
                      'B10',
                      FormulaRule(
                          formula=['NOT(ISERROR(SEARCH("âŒ",B10)))'],
                          dxf=DifferentialStyle(fill=red_fill)
                      )
                  )
  
  # ========================================
  # Phase 3: í†µí•© ìƒì„±ê¸° (2ì£¼)
  # ========================================
  
  phase_3_integrated_generator:
    duration: "2ì£¼"
    file: "umis_rag/deliverables/excel/market_sizing_generator.py"
    
    # --- Week 5: í†µí•© ---
    week_5_integration:
      
      class MarketSizingWorkbookGenerator:
        
        purpose: "ì „ì²´ ì›Œí¬ë¶ ìƒì„± ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜"
        
        generate:
          signature: |
            def generate(
                market_name: str,
                assumptions: list[dict],
                tam: dict,
                segments: list[dict],
                proxy_data: dict,
                competitors: list[dict],
                output_dir: Path
            ) -> Path
          
          process:
            step_1_init:
              code: |
                wb = Workbook()
                formula_engine = FormulaEngine(wb)
                
                # ê¸°ë³¸ ì‹œíŠ¸ ì œê±°
                wb.remove(wb.active)
            
            step_2_assumptions:
              code: |
                builder = AssumptionsSheetBuilder(wb, formula_engine)
                builder.create_sheet(assumptions)
                
                # Named Range ì •ì˜ë¨
                # ASM_001, ASM_002, ... ëª¨ë‘ ì‚¬ìš© ê°€ëŠ¥
            
            step_3_estimation_details:
              code: |
                # ì¶”ì •ì¹˜ê°€ ìˆìœ¼ë©´ Estimation_Details ì‹œíŠ¸ ìƒì„±
                estimations = [a for a in assumptions if a['data_type'] == 'ì¶”ì •ì¹˜']
                
                if estimations:
                    est_builder = EstimationDetailsBuilder(wb)
                    est_builder.create_sheet(estimations)
            
            step_4_methods:
              code: |
                # Method 1: Top-Down
                method1 = Method1TopDownBuilder(wb, formula_engine)
                method1.create_sheet(tam, narrowing_steps)
                
                # Method 2: Bottom-Up
                method2 = Method2BottomUpBuilder(wb, formula_engine)
                method2.create_sheet(segments)
                
                # Method 3: Proxy
                method3 = Method3ProxyBuilder(wb, formula_engine)
                method3.create_sheet(proxy_data)
                
                # Method 4: Competitor
                method4 = Method4CompetitorBuilder(wb, formula_engine)
                method4.create_sheet(competitors)
            
            step_5_convergence:
              code: |
                conv_builder = ConvergenceSheetBuilder(wb, formula_engine)
                conv_builder.create_sheet(
                    method_sheets=[
                        'Method_1_TopDown',
                        'Method_2_BottomUp',
                        'Method_3_Proxy',
                        'Method_4_CompetitorRevenue'
                    ],
                    sam_cell='SAM'
                )
            
            step_6_scenarios:
              code: |
                scenario_builder = ScenariosBuilder(wb, formula_engine)
                scenario_builder.create_sheet(['Best', 'Base', 'Worst'])
            
            step_7_validation:
              code: |
                validation_builder = ValidationLogBuilder(wb)
                validation_builder.create_sheet()
            
            step_8_save:
              code: |
                # ê°•ì œ ì¬ê³„ì‚° í”Œë˜ê·¸ ì„¤ì • (ì¤‘ìš”!)
                wb.calculation.calcMode = 'auto'
                wb.calculation.fullCalcOnLoad = True  # íŒŒì¼ ì—´ ë•Œ ê°•ì œ í’€ ì¬ê³„ì‚°
                
                # Excel ì €ì¥
                filename = f"market_sizing_{market_name}.xlsx"
                filepath = output_dir / filename
                wb.save(filepath)
                
                print(f"âœ… Excel ìƒì„±: {filepath}")
                print("ğŸ“‹ ë‹¤ìŒ: Excelì—ì„œ ì—´ì–´ì„œ í•¨ìˆ˜ ì‘ë™ í™•ì¸")
                print("ğŸ“‹ ë‹¤ìŒ: PDFë¡œ ì €ì¥ (ë°±ì—…)")
                
                return filepath
        
        usage_example: |
          from umis_rag.deliverables.excel import MarketSizingWorkbookGenerator
          
          generator = MarketSizingWorkbookGenerator()
          
          excel_path = generator.generate(
              market_name="piano_subscription",
              assumptions=[...],
              tam={...},
              segments=[...],
              proxy_data={...},
              competitors=[...],
              output_dir=Path("projects/20251103_piano/02_analysis/quantifier")
          )
          
          # Excel ìƒì„±ë¨!
          # â†’ Excelì—ì„œ ì—´ì–´ì„œ ê²€ì¦
          # â†’ ëª¨ë“  í•¨ìˆ˜ ì‘ë™ í™•ì¸
    
    # --- Week 6: í…ŒìŠ¤íŠ¸ ---
    week_6_testing:
      
      test_strategy:
        
        unit_tests:
          file: "tests/test_excel_formulas.py"
          
          tests:
            - test_named_range_creation
            - test_formula_generation
            - test_cross_sheet_references
            - test_convergence_formulas
        
        integration_tests:
          file: "tests/test_excel_generation.py"
          
          tests:
            - test_full_workbook_generation
            - test_9_sheets_created
            - test_all_formulas_present
        
        excel_validation_tests:
          manual: true
          process:
            1: "í…ŒìŠ¤íŠ¸ ë°ì´í„°ë¡œ Excel ìƒì„±"
            2: "Excelì—ì„œ ì—´ê¸°"
            3: "ê° ì‹œíŠ¸ í•¨ìˆ˜ ì‘ë™ í™•ì¸"
            4: "Convergence Â±30% í™•ì¸"
            5: "ìˆ˜ë™/ìë™ ê³„ì‚° ì¼ì¹˜ í™•ì¸"
          
          checklist:
            - "[ ] Assumptions: Named Range ëª¨ë‘ ì •ì˜ë¨"
            - "[ ] Method 1-4: ê³„ì‚° ì •í™•"
            - "[ ] Convergence: í†µê³„ í•¨ìˆ˜ ì‘ë™"
            - "[ ] ìƒ‰ìƒ ì½”ë”© ì •í™•"
            - "[ ] ì…€ ì½”ë©˜íŠ¸ ì¡´ì¬"
            - "[ ] ì‹œíŠ¸ ë³´í˜¸ ì‘ë™"
  
  # ========================================
  # í•µì‹¬ ê³ ë ¤ì‚¬í•­
  # ========================================
  
  critical_considerations:
    
    named_range_strategy:
      why: "í–‰ ì¶”ê°€/ì‚­ì œ ì‹œ ì°¸ì¡° ì•ˆê¹¨ì§"
      
      implementation:
        all_assumptions: "Named Rangeë¡œ"
        all_intermediate_results: "ì…€ ì°¸ì¡°ë¡œ (ë³€ë™ ê°€ëŠ¥)"
        final_results: "Named Rangeë¡œ"
      
      example: |
        # Good
        ws['B5'] = "=ASM_001*ASM_002"  # Named Range
        
        # Bad
        ws['B5'] = "=D5*D6"  # í–‰ ì¶”ê°€ ì‹œ ê¹¨ì§
    
    formula_validation:
      why: "openpyxlì€ ê³„ì‚° ì•ˆí•¨, Excelì—ì„œ ê²€ì¦ í•„ìˆ˜"
      
      process:
        1: "openpyxlë¡œ ìƒì„±"
        2: "ë¬¸ë²• ê²€ì¦ (validator)"
        3: "Excelì—ì„œ ì—´ê¸°"
        4: "ê³„ì‚° ê²°ê³¼ í™•ì¸"
        5: "ì˜ˆìƒ ê°’ê³¼ ë¹„êµ"
      
      platforms:
        windows: "win32com ì‚¬ìš© (ìë™)"
        mac: "ìˆ˜ë™ í™•ì¸ (ì•ˆë‚´ ë©”ì‹œì§€)"
        linux: "LibreOffice --headless"
    
    error_handling:
      div_by_zero:
        formula: '=IFERROR(A1/B1, "N/A")'
        why: "0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€"
      
      missing_data:
        formula: '=IF(ISBLANK(A1), "ë°ì´í„° ì—†ìŒ", A1*B1)'
        why: "ë¹ˆ ì…€ ì²˜ë¦¬"
    
    performance:
      calculation_mode:
        set: "wb.calculation.calcMode = 'auto'"
        why: "íŒŒì¼ ì—´ ë•Œ ìë™ ê³„ì‚°"
      
      formula_caching:
        avoid: "ê³¼ë„í•œ ì¤‘ë³µ ê³„ì‚°"
        use: "ì¤‘ê°„ ê²°ê³¼ ì…€ë¡œ ì €ì¥"

# ========================================
# í”„ë¡œì íŠ¸ 2: System RAG (Key-based)
# ========================================

project_2_system_rag:
  
  name: "System RAG (Key-based ì •í™• ê²€ìƒ‰)"
  priority: "P0 (ìµœìš°ì„ )"
  duration: "4ì£¼"
  target_version: "v7.1.0"
  
  goal:
    primary: "AIê°€ 5ë¶„ ë‚´ UMIS ì „ì²´ íŒŒì•… + ìµœì  ë°©ë²• íŒë‹¨"
    context_saving: "í‰ê·  77% (4,200ì¤„) ì ˆì•½"
    
    success_criteria:
      - "umis_core.yaml (INDEX) < 1,000ì¤„"
      - "Keyë¡œ ìœ ì‚¬ë„ 1.0 ì •í™• ê²€ìƒ‰"
      - "ì»¨í…ìŠ¤íŠ¸ 70% ì´ìƒ ì ˆì•½"
      - "AIê°€ ëª¨ë“  ê¸°ëŠ¥ ëˆ„ë½ ì—†ì´ í™œìš©"
  
  # ========================================
  # Phase 1: Tool Registry (1ì£¼)
  # ========================================
  
  phase_1_tool_registry:
    duration: "1ì£¼"
    file: "config/tool_registry.yaml"
    
    # --- Day 1-2: ë„êµ¬ ì‹ë³„ ---
    day_1_2_tool_identification:
      
      process:
        step_1_analyze_umis:
          action: "umis.yaml (5,509ì¤„) ì „ì²´ ë¶„ì„"
          
          identify:
            - "Agentë³„ ì£¼ìš” ê¸°ëŠ¥"
            - "Frameworkë³„ í”„ë¡œì„¸ìŠ¤"
            - "Workflowë³„ ë‹¨ê³„"
          
          output: "25-30ê°œ ë„êµ¬ ëª©ë¡"
        
        step_2_categorize:
          categories:
            
            agent_tools:
              - "explorer:pattern_search (RAG íŒ¨í„´ ê²€ìƒ‰)"
              - "explorer:7_step_process (ê¸°íšŒ ë°œêµ´)"
              - "explorer:validation_protocol (ê²€ì¦)"
              - "quantifier:sam_4methods (SAM ê³„ì‚°)"
              - "quantifier:growth_analysis (ì„±ì¥ ë¶„ì„)"
              - "observer:market_structure (êµ¬ì¡° ë¶„ì„)"
              - "observer:value_chain (ê°€ì¹˜ì‚¬ìŠ¬)"
              - "validator:data_definition (ì •ì˜ ê²€ì¦)"
              - "validator:creative_sourcing (ì°½ì˜ì  ì†Œì‹±)"
              - "guardian:progress_monitoring (ì§„í–‰ ëª¨ë‹ˆí„°ë§)"
            
            framework_tools:
              - "framework:13_dimensions (ì‹œì¥ ì •ì˜)"
              - "framework:7_powers (ê²½ìŸ ìš°ìœ„)"
              - "framework:discovery_sprint (Discovery)"
              - "framework:counter_positioning (1ë“± ì¶”ì›”)"
            
            workflow_tools:
              - "workflow:comprehensive_study (2-4ì£¼)"
              - "workflow:rapid_assessment (1-3ì¼)"
              - "workflow:quick_insights (1-2ì‹œê°„)"
              - "workflow:discovery_sprint (1-3ì¼)"
          
          total: "~25ê°œ ë„êµ¬"
    
    # --- Day 3-5: Tool Registry ì‘ì„± ---
    day_3_5_registry_creation:
      
      structure:
        
        tool_template: |
          - tool_id: "explorer:pattern_search"
            tool_key: "tool:explorer:pattern_search"  # RAG ì •í™• ë§¤ì¹­ í‚¤
            
            metadata:
              agent: "explorer"
              category: "rag_search"
              complexity: "low"
              context_size: 200  # ì¤„ ìˆ˜
              priority: "high"
            
            when_to_use:
              keywords:
                - "íŒ¨í„´"
                - "ëª¨ë¸"
                - "ì‚¬ë¡€"
                - "ë²¤ì¹˜ë§ˆí¬"
              
              conditions:
                - "agent == 'explorer'"
                - "task_type in ['pattern_discovery', 'model_matching']"
              
              scenarios:
                - "@Explorer, êµ¬ë… ëª¨ë¸ íŒ¨í„´ ì°¾ì•„ì¤˜"
                - "@Explorer, í”Œë«í¼ ë¹„ì¦ˆë‹ˆìŠ¤ ì‚¬ë¡€"
            
            what_it_does:
              description: "RAGë¡œ 31ê°œ ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸ + 23ê°œ Disruption íŒ¨í„´ ìë™ ê²€ìƒ‰"
              
              capabilities:
                - "Vector Search (ìœ ì‚¬ íŒ¨í„´)"
                - "Graph Search (ì¡°í•© íŒ¨í„´)"
                - "Case Search (ì„±ê³µ ì‚¬ë¡€)"
              
              output:
                - "matched_patterns (5ê°œ, ìœ ì‚¬ë„ ìˆœ)"
                - "similar_cases (3ê°œ, ë²¤ì¹˜ë§ˆí¬)"
                - "combinations (ì¡°í•© íŒ¨í„´)"
            
            how_to_use: |
              from umis_rag.agents.explorer import ExplorerRAG
              
              explorer = ExplorerRAG()
              
              # íŒ¨í„´ ê²€ìƒ‰
              patterns = explorer.search_patterns("êµ¬ë… ëª¨ë¸")
              # â†’ subscription_model (0.95)
              
              # ì‚¬ë¡€ ê²€ìƒ‰
              cases = explorer.search_cases("ìŒì•… ì‚°ì—…", pattern_id="subscription_model")
              # â†’ Spotify, Netflix, Apple Music
              
              # ì¡°í•© ê²€ìƒ‰ (Graph)
              combinations = explorer.search_combinations("subscription")
              # â†’ subscription + platform (0.87)
            
            prerequisites:
              optional:
                - tool: "observer:market_structure"
                  why: "ì‹œì¥ ë§¥ë½ ìˆìœ¼ë©´ ë” ì •í™•"
            
            output_to:
              - "explorer:7_step_process (ë‹¤ìŒ ë‹¨ê³„)"
              - "deliverable:opportunity_hypothesis"
            
            content: |
              # Explorer: RAG íŒ¨í„´ ê²€ìƒ‰
              
              ## ëª©ì 
              31ê°œ ë¹„ì¦ˆë‹ˆìŠ¤ ëª¨ë¸ + 23ê°œ Disruption íŒ¨í„´ì—ì„œ ê´€ë ¨ íŒ¨í„´ ìë™ ê²€ìƒ‰
              
              ## RAG ì•„í‚¤í…ì²˜
              - Vector: projected_index (agent_view=explorer)
              - Graph: Neo4j (13 ë…¸ë“œ, 45 ê´€ê³„)
              - Embedding: text-embedding-3-large (3072 dim)
              
              ## ê²€ìƒ‰ í”„ë¡œì„¸ìŠ¤
              1. Vector Search
                 Query: "êµ¬ë… ëª¨ë¸"
                 â†’ subscription_model (0.95)
                 â†’ platform + subscription (0.87)
              
              2. Graph Search
                 (subscription)-[COMBINES_WITH]->()
                 â†’ subscription + platform (confidence 0.87)
                 â†’ subscription + advertising (0.78)
              
              3. Case Search
                 Filter: pattern_id = "subscription_model"
                 â†’ Spotify (2.2ì–µ êµ¬ë…ì)
                 â†’ Netflix (í•´ì§€ìœ¨ 2.4%)
                 â†’ Adobe (êµ¬ë… ì „í™˜ í›„ ë§¤ì¶œ 3ë°°)
              
              ## ì‚¬ìš© ì˜ˆì‹œ
              
              ### ê¸°ë³¸ ê²€ìƒ‰
              ```python
              patterns = explorer.search_patterns("êµ¬ë… ëª¨ë¸")
              
              for p in patterns:
                  print(f"{p.pattern_id}: {p.similarity}")
                  print(f"  CSF: {p.critical_success_factors}")
              ```
              
              ### Hybrid Search (Vector + Graph)
              ```python
              result = explorer.search_patterns_with_graph("êµ¬ë… ëª¨ë¸")
              
              print("Direct matches:", result['patterns'])
              print("Combinations:", result['combinations'])
              print("Insights:", result['insights'])
              ```
              
              ## ì¶œë ¥ í˜•ì‹
              ```yaml
              matched_patterns:
                - pattern_id: "subscription_model"
                  similarity: 0.95
                  critical_success_factors:
                    - "í•´ì§€ìœ¨ < 5%"
                    - "LTV/CAC > 3.0"
                  
                  success_cases:
                    - "Spotify: 5.2% churn"
                    - "Netflix: 2.4% churn"
              
              combinations:
                - pattern: "subscription + platform"
                  confidence: 0.87
                  evidence: ["Spotify", "LinkedIn Premium"]
                  
                  insight: "í”Œë«í¼ ë„¤íŠ¸ì›Œí¬ íš¨ê³¼ + êµ¬ë… ì•ˆì •ì„±"
              ```
              
              ## ë‹¤ìŒ ë‹¨ê³„
              - ë°œê²¬í•œ íŒ¨í„´ìœ¼ë¡œ 7ë‹¨ê³„ í”„ë¡œì„¸ìŠ¤ ì‹œì‘
              - ë˜ëŠ” ì‚¬ë¡€ ì‹¬ì¸µ ë¶„ì„
              
              (ì´ ~200ì¤„ ìƒì„¸ ë‚´ìš©)
      
      total_tools: "25ê°œ"
      total_lines: "5,000ì¤„ (ë„êµ¬ë³„ 200ì¤„ í‰ê· )"
  
  # ========================================
  # Phase 2: umis_core.yaml (INDEX) (1ì£¼)
  # ========================================
  
  phase_2_core_index:
    duration: "1ì£¼"
    file: "umis_core.yaml"
    target_size: "< 1,000ì¤„"
    
    structure:
      
      section_1_system_overview:
        size: "200ì¤„"
        
        content:
          system_identity:
            name: "UMIS v7.1.0"
            tagline: "RAG ê¸°ë°˜ 5-Agent í˜‘ì—… ì‹œì¥ ë¶„ì„"
            
            what_it_can_do:
              rag:
                - "54ê°œ ê²€ì¦ëœ íŒ¨í„´/ì‚¬ë¡€ ìë™ ê²€ìƒ‰"
                - "íŒ¨í„´ ì¡°í•© ë°œê²¬ (Knowledge Graph)"
              
              agents:
                - "5ëª… ì „ë¬¸ Agent í˜‘ì—…"
                - "ì™„ì „í•œ ì¶”ì ì„± (ID Namespace)"
                - "ì¬ê²€ì¦ ê°€ëŠ¥ (Excel í•¨ìˆ˜)"
              
              automation:
                - "AI ìë™ ì„¤ì¹˜"
                - "ì‚°ì¶œë¬¼ ìë™ ìƒì„±"
                - "ê²€ì¦ ìë™í™”"
          
          rag_architecture:
            version: "v3.0"
            active_agent: "Explorer"
            
            layers:
              layer_1: "Canonical + Projected (ChromaDB)"
              layer_3: "Knowledge Graph (Neo4j)"
              layer_4: "Memory (Query/Goal/RAE)"
            
            how_it_works: |
              "@Explorer, êµ¬ë… ëª¨ë¸"
              â†’ Vector RAG ê²€ìƒ‰
              â†’ íŒ¨í„´ ë°œê²¬ (subscription_model)
              â†’ Graph ì¡°í•© (subscription + platform)
              â†’ ì‚¬ë¡€ ë§¤ì¹­ (Spotify, Netflix)
      
      section_2_agent_summary:
        size: "500ì¤„"
        note: "ê° Agent 100ì¤„ ìš”ì•½"
        
        agent_template: |
          observer:
            name: "Albert (ê¸°ë³¸)"
            role: "ì‹œì¥ êµ¬ì¡° ë¶„ì„"
            rag: false
            
            what_it_does:
              - "ê°€ì¹˜ì‚¬ìŠ¬ ë§µí•‘"
              - "ê±°ë˜ íŒ¨í„´ ê´€ì°°"
              - "ë¹„íš¨ìœ¨ì„± ë°œê²¬"
            
            when_to_use:
              - "ì‹œì¥ êµ¬ì¡° ì´í•´ í•„ìš”"
              - "ê°€ì¹˜ íë¦„ ë¶„ì„"
              - "ê²½ìŸ êµ¬ë„ íŒŒì•…"
            
            deliverables:
              - "market_reality_report.md"
            
            detail_module: "modules/agents/observer.yaml"
          
          explorer:
            name: "Steve (ê¸°ë³¸)"
            role: "ê¸°íšŒ ë°œêµ´ (RAG í™œìš©!)"
            rag: true
            
            what_it_does:
              - "RAG íŒ¨í„´ ìë™ ê²€ìƒ‰ (31+23ê°œ)"
              - "7ë‹¨ê³„ ê¸°íšŒ ë°œêµ´"
              - "ê²€ì¦ í”„ë¡œí† ì½œ"
            
            key_tools:
              - "tool:explorer:pattern_search (RAG)"
              - "tool:explorer:7_step_process"
              - "tool:explorer:validation"
            
            when_to_use:
              - "ê¸°íšŒ ë°œêµ´"
              - "ê°€ì„¤ ìƒì„±"
              - "íŒ¨í„´ ë§¤ì¹­"
            
            deliverables:
              - "OPP_*.md (ê¸°íšŒ ê°€ì„¤)"
              - "opportunity_portfolio.md"
            
            detail_module: "modules/agents/explorer.yaml"
          
          # (ë‚˜ë¨¸ì§€ 3ê°œ Agentë„ ë™ì¼)
      
      section_3_decision_guide:
        size: "200ì¤„"
        note: "í•µì‹¬! AIê°€ ìµœì  ë°©ë²• íŒë‹¨"
        
        structure:
          
          question_type_mapping:
            
            market_analysis:
              keywords: ["ì‹œì¥ ë¶„ì„", "ì‚°ì—… ë¶„ì„", "ê²½ìŸ êµ¬ì¡°"]
              
              decision_logic:
                step_1_check_clarity:
                  if_low_clarity:
                    action: "Discovery Sprint"
                    load_tools:
                      - "tool:discovery:sprint"
                      - "tool:observer:market_structure"
                      - "tool:explorer:pattern_search"
                    agents: "ëª¨ë“  Agent ë³‘ë ¬"
                  
                  if_high_clarity:
                    action: "Structured Analysis"
                    load_tools:
                      - "tool:observer:market_structure"
                      - "tool:explorer:7_step_process"
                    agents: "Albert â†’ Steve ìˆœì°¨"
                
                step_2_determine_depth:
                  quick: "modules/workflows/quick.yaml"
                  standard: "modules/workflows/standard.yaml"
                  comprehensive: "modules/workflows/comprehensive.yaml"
            
            opportunity_discovery:
              keywords: ["ê¸°íšŒ", "ì•„ì´ë””ì–´", "í˜ì‹ ", "ìƒˆë¡œìš´"]
              
              primary_agent: "explorer"
              
              required_tools:
                - "tool:explorer:pattern_search (RAG ìš°ì„ !)"
                - "tool:explorer:7_step_process"
              
              optional_tools:
                - "tool:observer:market_structure (ë§¥ë½)"
                - "tool:quantifier:sam_4methods (ê·œëª¨)"
              
              load_order:
                1: "tool:explorer:pattern_search"
                2: "tool:explorer:7_step_process"
                3: "í•„ìš” ì‹œ observer, quantifier"
            
            market_sizing:
              keywords: ["ì‹œì¥ ê·œëª¨", "SAM", "TAM", "í¬ê¸°"]
              
              primary_agent: "quantifier"
              
              required_tools:
                - "tool:validator:data_definition (ë¨¼ì €!)"
                - "tool:quantifier:sam_4methods"
              
              workflow:
                1: "Validatorê°€ ë°ì´í„° ì •ì˜ ê²€ì¦"
                2: "Quantifierê°€ 4ê°€ì§€ ë°©ë²• ê³„ì‚°"
                3: "Convergence Â±30% í™•ì¸"
              
              deliverable:
                - "market_sizing.xlsx (Excel ìë™ ìƒì„±)"
          
          ai_loading_strategy: |
            ì‚¬ìš©ì ì¿¼ë¦¬ ë¶„ì„
              â†“
            question_type_mappingì—ì„œ ë§¤ì¹­
              â†“
            í•„ìš”í•œ tool_keyë“¤ ì‹ë³„
              â†“
            System RAGë¡œ ì •í™• ê²€ìƒ‰ (key ê¸°ë°˜)
              â†“
            ì»¨í…ìŠ¤íŠ¸ êµ¬ì„± (í•„ìš”í•œ ê²ƒë§Œ)
              â†“
            ì‹¤í–‰
      
      section_4_module_index:
        size: "100ì¤„"
        
        content: |
          modules:
            
            agents:
              observer: 
                file: "modules/agents/observer.yaml"
                size: "800ì¤„"
                tools: 5ê°œ
              
              explorer:
                file: "modules/agents/explorer.yaml"
                size: "900ì¤„"
                tools: 6ê°œ
                rag: true
              
              quantifier:
                file: "modules/agents/quantifier.yaml"
                size: "700ì¤„"
                tools: 4ê°œ
              
              validator:
                file: "modules/agents/validator.yaml"
                size: "600ì¤„"
                tools: 3ê°œ
              
              guardian:
                file: "modules/agents/guardian.yaml"
                size: "800ì¤„"
                tools: 4ê°œ
            
            frameworks:
              market_definition:
                file: "modules/frameworks/market_definition.yaml"
                size: "1,000ì¤„"
              
              seven_powers:
                file: "modules/frameworks/seven_powers.yaml"
                size: "500ì¤„"
              
              discovery_sprint:
                file: "modules/frameworks/discovery_sprint.yaml"
                size: "400ì¤„"
            
            workflows:
              comprehensive:
                file: "modules/workflows/comprehensive.yaml"
                size: "600ì¤„"
              
              rapid:
                file: "modules/workflows/rapid.yaml"
                size: "400ì¤„"
              
              quick:
                file: "modules/workflows/quick.yaml"
                size: "200ì¤„"
  
  # ========================================
  # Phase 2: System RAG Index êµ¬ì¶• (1ì£¼)
  # ========================================
  
  phase_2_system_rag_index:
    duration: "1ì£¼"
    
    # --- Day 1-3: ì²­í‚¹ ë° ì¸ë±ì‹± ---
    chunking_strategy:
      
      source: "config/tool_registry.yaml"
      
      chunk_creation:
        each_tool_is_chunk:
          chunk_id: "tool_id (explorer:pattern_search)"
          chunk_key: "tool_key (tool:explorer:pattern_search)"
          content: "tool.content (200-800ì¤„)"
          
          metadata:
            agent: "explorer"
            category: "rag_search"
            context_size: 200
            priority: "high"
      
      indexing:
        script: "scripts/build_system_knowledge.py"
        
        code: |
          def build_system_knowledge_index():
              """Tool Registry â†’ System RAG"""
              
              # 1. Tool Registry ë¡œë“œ
              with open('config/tool_registry.yaml') as f:
                  registry = yaml.safe_load(f)
              
              # 2. ì²­í¬ ìƒì„± (tool_keyë¥¼ ë©”íƒ€ë°ì´í„°ì— í¬í•¨!)
              chunks = []
              for tool in registry['tools']:
                  chunk = {
                      'id': tool['tool_id'],
                      'key': tool['tool_key'],  # ì •í™• ë§¤ì¹­ í‚¤
                      'content': tool['content'],
                      'metadata': {
                          **tool['metadata'],
                          'tool_key': tool['tool_key']  # âœ… ë©”íƒ€ë°ì´í„°ì— ì¶”ê°€!
                      }
                  }
                  chunks.append(chunk)
              
              # 3. ChromaDB ì €ì¥
              client = chromadb.PersistentClient(path="data/chroma")
              collection = client.get_or_create_collection(
                  "system_knowledge",
                  metadata={"description": "UMIS ë„êµ¬ ê²€ìƒ‰"}
              )
              
              collection.add(
                  ids=[c['id'] for c in chunks],
                  documents=[c['content'] for c in chunks],
                  metadatas=[c['metadata'] for c in chunks]
              )
              
              print(f"âœ… {len(chunks)}ê°œ ë„êµ¬ ì¸ë±ì‹± ì™„ë£Œ")
        
        execution: |
          python scripts/build_system_knowledge.py
          
          â†’ system_knowledge Collection ìƒì„±
          â†’ 25ê°œ ë„êµ¬ ì¸ë±ì‹±
    
    # --- Day 4-5: ê²€ìƒ‰ ìŠ¤í¬ë¦½íŠ¸ ---
    search_script:
      
      file: "scripts/query_system_rag.py"
      
      code: |
        class SystemRAG:
            """Key-first Â· Vector-fallback 2ë‹¨ê³„ ê²€ìƒ‰"""
            
            def __init__(self):
                self.client = chromadb.PersistentClient(path="data/chroma")
                self.collection = self.client.get_collection("system_knowledge")
                
                # KeyDirectory (ë©”ëª¨ë¦¬ ìƒì£¼) - O(1) ì •í™• ë§¤ì¹­
                self.key_directory = self._build_key_directory()
            
            def _build_key_directory(self) -> dict:
                """ëª¨ë“  ë„êµ¬ í‚¤ â†’ ID ë§¤í•‘ (ë©”ëª¨ë¦¬)"""
                # Collectionì˜ ëª¨ë“  ë©”íƒ€ë°ì´í„° ë¡œë“œ
                all_data = self.collection.get()
                
                key_dir = {}
                for idx, metadata in enumerate(all_data['metadatas']):
                    tool_key = metadata.get('tool_key')
                    if tool_key:
                        key_dir[tool_key] = {
                            'id': all_data['ids'][idx],
                            'agent': metadata.get('agent'),
                            'context_size': metadata.get('context_size', 200)
                        }
                
                return key_dir
            
            def search_tool_by_key(self, tool_key: str) -> dict:
                """Keyë¡œ ë„êµ¬ ê²€ìƒ‰ (2ë‹¨ê³„)"""
                
                # Step 1: KeyDirectory ì •í™• ë§¤ì¹­ (O(1), ë¬´ë£Œ, í™•ì‹¤)
                if tool_key in self.key_directory:
                    tool_info = self.key_directory[tool_key]
                    
                    # IDë¡œ ì§ì ‘ ì¡°íšŒ (ë²¡í„° ê²€ìƒ‰ ë¶ˆí•„ìš”!)
                    result = self.collection.get(ids=[tool_info['id']])
                    
                    return {
                        'tool_id': tool_info['id'],
                        'content': result['documents'][0],
                        'metadata': result['metadatas'][0],
                        'match_type': 'exact_key',  # âœ… ì •í™• ë§¤ì¹­
                        'latency_ms': 0.5
                    }
                
                # Step 2: Vector Fallback (ì˜¤íƒ€/ë™ì˜ì–´ í—ˆìš©)
                results = self.collection.query(
                    query_texts=[tool_key],
                    n_results=1
                )
                
                if not results['documents']:
                    raise ValueError(f"ë„êµ¬ ì—†ìŒ: {tool_key}")
                
                return {
                    'tool_id': results['ids'][0][0],
                    'content': results['documents'][0][0],
                    'metadata': results['metadatas'][0][0],
                    'match_type': 'vector_fallback',  # âœ… ìœ ì‚¬ë„ ê²€ìƒ‰
                    'similarity': results['distances'][0][0],
                    'latency_ms': 15.2
                }
        
        # ì‚¬ìš©
        # python scripts/query_system_rag.py "tool:explorer:pattern_search"
      
      usage_in_cursorrules: |
        # .cursorrulesì—ì„œ
        
        @Explorer ê°ì§€
          â†“
        keywords ë¶„ì„
          â†“
        tool_key ê²°ì •: "tool:explorer:pattern_search"
          â†“
        ê²€ìƒ‰: python scripts/query_system_rag.py "tool:explorer:pattern_search"
          â†“
        ê²°ê³¼ ë¡œë“œ: 200ì¤„
          â†“
        ì»¨í…ìŠ¤íŠ¸ ì¶”ê°€
  
  # ========================================
  # Phase 3: .cursorrules í†µí•© (1ì£¼)
  # ========================================
  
  phase_3_cursorrules_integration:
    duration: "1ì£¼"
    
    cursorrules_update:
      
      new_section:
        name: "PART 6: System RAG"
        size: "~100ì¤„"
        
        content: |
          # === PART 6: System RAG (Key-based) ===
          
          system_rag:
            enabled: true
            collection: "system_knowledge"
            tools: 25ê°œ
            
            # AI ì‚¬ìš© ì „ëµ
            ai_strategy:
              step_1_parse:
                action: "ì‚¬ìš©ì ì¿¼ë¦¬ì—ì„œ agent + keywords ì¶”ì¶œ"
                
                examples:
                  - query: "@Explorer, êµ¬ë… ëª¨ë¸ íŒ¨í„´"
                    parse:
                      agent: "explorer"
                      keywords: ["êµ¬ë…", "ëª¨ë¸", "íŒ¨í„´"]
              
              step_2_key_selection:
                rules:
                  - if: "agent=explorer AND 'íŒ¨í„´' in keywords"
                    key: "tool:explorer:pattern_search"
                  
                  - if: "agent=explorer AND 'ê¸°íšŒ' in keywords"
                    key: "tool:explorer:7_step_process"
                  
                  - if: "agent=quantifier AND 'SAM' in keywords"
                    key: "tool:quantifier:sam_4methods"
                  
                  - if: "task='Discovery Sprint'"
                    keys:
                      - "tool:discovery:sprint"
                      - "tool:observer:market_structure"
                      - "tool:explorer:pattern_search"
              
              step_3_search:
                for_each_key:
                  command: "python scripts/query_system_rag.py {key}"
                  result: "ë„êµ¬ content (200-800ì¤„)"
                  similarity: "1.0 (ì •í™• ë§¤ì¹­)"
              
              step_4_context:
                load:
                  always: "umis_core.yaml (50ì¤„, í•µì‹¬ë§Œ)"
                  searched: "System RAG ê²°ê³¼ (200-1,500ì¤„)"
                
                total: "250-1,550ì¤„"
                
                vs_original: "5,509ì¤„"
                saving: "72-95%"
            
            # ë‹¨ì¶• ëª…ë ¹
            shortcuts:
              - "ë„êµ¬ ê²€ìƒ‰ {key}": python scripts/query_system_rag.py {key}
              - "ì‹œìŠ¤í…œ rag ë¹Œë“œ": python scripts/build_system_knowledge.py
  
  # ========================================
  # Phase 4: í…ŒìŠ¤íŠ¸ & ìµœì í™” (1ì£¼)
  # ========================================
  
  phase_4_testing:
    duration: "1ì£¼"
    
    test_scenarios:
      
      scenario_1_simple:
        query: "@Explorer, êµ¬ë… ëª¨ë¸ íŒ¨í„´ ì°¾ì•„ì¤˜"
        
        expected_flow:
          step_1: "umis_core.yaml (50ì¤„) ì½ê¸°"
          step_2: "parse: agent=explorer, keywords=['íŒ¨í„´']"
          step_3: "key: 'tool:explorer:pattern_search'"
          step_4: "System RAG ê²€ìƒ‰ â†’ 200ì¤„"
          step_5: "ì´ ì»¨í…ìŠ¤íŠ¸: 250ì¤„"
        
        validation:
          context_size: "< 300ì¤„"
          all_features_available: true
          tool_loaded: "pattern_search"
          similarity: 1.0
      
      scenario_2_medium:
        query: "@Explorer, ìŒì•… ìŠ¤íŠ¸ë¦¬ë° ì‹œì¥ ê¸°íšŒ ë¶„ì„"
        
        expected_flow:
          step_1: "umis_core.yaml (50ì¤„)"
          step_2: "parse: agent=explorer, keywords=['ê¸°íšŒ', 'ë¶„ì„']"
          step_3: "keys: ['tool:explorer:pattern_search', 'tool:explorer:7_step_process']"
          step_4: "System RAG 2íšŒ ê²€ìƒ‰ â†’ 1,000ì¤„"
          step_5: "ì´ ì»¨í…ìŠ¤íŠ¸: 1,050ì¤„"
        
        validation:
          context_size: "< 1,200ì¤„"
          saving: "> 80%"
      
      scenario_3_complex:
        query: "Discovery Sprint ì‹œì‘"
        
        expected_flow:
          step_1: "umis_core.yaml (50ì¤„)"
          step_2: "parse: task=discovery_sprint"
          step_3: "keys: 5ê°œ ë„êµ¬"
          step_4: "System RAG 5íšŒ ê²€ìƒ‰ â†’ 1,800ì¤„"
          step_5: "ì´ ì»¨í…ìŠ¤íŠ¸: 1,850ì¤„"
        
        validation:
          context_size: "< 2,000ì¤„"
          saving: "> 65%"
    
    performance_metrics:
      target:
        avg_context: "< 1,200ì¤„"
        avg_saving: "> 75%"
        search_accuracy: "100% (key ê¸°ë°˜)"
        query_cost: "< $0.001"

# ========================================
# í”„ë¡œì íŠ¸ 3: RAG ë°ì´í„° í’ˆì§ˆ ê´€ë¦¬
# ========================================

project_3_data_quality:
  
  name: "RAG ë°ì´í„° í’ˆì§ˆ ê´€ë¦¬ ì‹œìŠ¤í…œ"
  priority: "P1 (ë†’ìŒ)"
  duration: "3ì£¼"
  target_version: "v7.1.0"
  
  philosophy: "ì§ˆ â†’ ì–‘ â†’ ë°¸ëŸ°ìŠ¤"
  
  goal:
    primary: "A ë“±ê¸‰ íŒ¨í„´ 80% ë‹¬ì„±"
    
    quality_definition:
      criteria:
        1_context_completeness:
          weight: 3
          requirement: "ì²­í¬ í•˜ë‚˜ë¡œ ì™„ì „ ì´í•´ ê°€ëŠ¥"
          
          must_include:
            - "íŒ¨í„´ ì´ë¦„/ID"
            - "ê°œë… ì„¤ëª…"
            - "ì™œ ì¤‘ìš”í•œì§€"
            - "ì–´ë–¤ ìƒí™©ì—ì„œ"
            - "ì ìš© ê°€ëŠ¥ ì‚°ì—…"
          
          example_good: |
            pattern_id: "subscription_model"
            pattern_name: "êµ¬ë… ëª¨ë¸"
            
            concept: |
              ê³ ê°ì´ ì œí’ˆ/ì„œë¹„ìŠ¤ë¥¼ êµ¬ë§¤í•˜ì§€ ì•Šê³ 
              ì •ê¸°ì ìœ¼ë¡œ ì‚¬ìš©ë£Œë¥¼ ì§€ë¶ˆí•˜ëŠ” ëª¨ë¸
            
            why_important: |
              - ë°˜ë³µ ìˆ˜ìµ (Recurring Revenue)
              - ì˜ˆì¸¡ ê°€ëŠ¥í•œ í˜„ê¸ˆíë¦„
              - ê³ ê° LTV ê·¹ëŒ€í™”
            
            when_applicable: |
              - ì œí’ˆ/ì„œë¹„ìŠ¤ ë°˜ë³µ ì‚¬ìš©
              - ì§€ì†ì  ê°€ì¹˜ ì œê³µ
              - ê³ ê° íšë“ ë¹„ìš© ë†’ìŒ
            
            industries:
              - "SaaS (ì†Œí”„íŠ¸ì›¨ì–´)"
              - "ìŠ¤íŠ¸ë¦¬ë° (ìŒì•…, ì˜ìƒ)"
              - "ë Œíƒˆ (ì •ìˆ˜ê¸°, ê³µê¸°ì²­ì •ê¸°)"
          
          measurement: |
            ì§ˆë¬¸: "ì´ ì²­í¬ë§Œ ë³´ê³  íŒ¨í„´ì„ ì´í•´í•˜ê³  ì ìš©í•  ìˆ˜ ìˆëŠ”ê°€?"
            Pass: ë°”ë¡œ ê°€ëŠ¥
            Fail: ì¶”ê°€ ì •ë³´ í•„ìš”
        
        2_actionability:
          weight: 3
          requirement: "êµ¬ì²´ì  ìˆ˜ì¹˜ + How-to + ì¸¡ì • ë°©ë²•"
          
          must_include:
            - "êµ¬ì²´ì  ëª©í‘œì¹˜ (< 5%, > 3.0x)"
            - "ë‹¬ì„± ë°©ë²• (How-to)"
            - "ì¸¡ì • ë°©ë²•"
            - "ë²¤ì¹˜ë§ˆí¬ (ì‹¤ì œ ì‚¬ë¡€)"
          
          example_good: |
            critical_success_factors:
              
              low_churn_rate:
                target: "< 5% monthly"
                
                how_to_achieve:
                  - action: "ê°œì¸í™” ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜"
                    example: "Spotify Discover Weekly"
                    impact: "ì´íƒˆë¥  15% ê°ì†Œ"
                  
                  - action: "ì‚¬ìš© ìŠµê´€ í˜•ì„±"
                    example: "ë§¤ì¼ ì•Œë¦¼, ìŠ¤íŠ¸ë¦­ ë³´ìƒ"
                    impact: "ì¬ë°©ë¬¸ìœ¨ 2ë°°"
                  
                  - action: "Family Plan"
                    example: "ê°€ì¡± 6ëª… ê³µìœ "
                    impact: "ì´íƒˆë¥  70% ê°ì†Œ"
                
                measurement:
                  formula: "í•´ì§€ ê³ ê° / ì „ì²´ êµ¬ë…ì"
                  period: "ì›”ë³„"
                  cohort: "ê°€ì… ì‹œê¸°ë³„ ì¶”ì "
                
                benchmarks:
                  - company: "Spotify"
                    value: "5.2%"
                    year: "2023"
                  
                  - company: "Netflix"
                    value: "2.4%"
                    year: "2023"
                    note: "ì—…ê³„ ìµœì €"
                  
                  - company: "ì½”ì›¨ì´"
                    value: "4.2%"
                    year: "2023"
                    note: "í•œêµ­ ë Œíƒˆ 1ìœ„"
          
          measurement: |
            ì§ˆë¬¸: "ì´ëŒ€ë¡œ ì‹¤í–‰ ê°€ëŠ¥í•œê°€?"
            Pass: êµ¬ì²´ì  ì•¡ì…˜ + ìˆ˜ì¹˜
            Fail: ì¶”ìƒì , ëª¨í˜¸
        
        3_evidence_based:
          weight: 3
          requirement: "ì‹¤ì œ ì‚¬ë¡€ + ì •ëŸ‰ ë°ì´í„° + ì¶œì²˜"
          
          must_include:
            - "íšŒì‚¬ëª… + ë…„ë„"
            - "êµ¬ì²´ì  ìˆ˜ì¹˜"
            - "ì¶œì²˜ (ê³µì‹œ, ì—°êµ¬, ë³´ê³ ì„œ)"
          
          example_good: |
            success_cases:
              
              spotify:
                company: "Spotify"
                year: "2023"
                
                metrics:
                  subscribers_total: "5.7ì–µëª…"
                  subscribers_premium: "2.2ì–µëª…"
                  conversion_rate: "38.6%"
                  monthly_churn: "5.2%"
                  revenue: "$13.2B"
                  revenue_per_user: "$5/ì›”"
                
                evidence:
                  - source: "Spotify 2023 ì—°ê°„ ë³´ê³ ì„œ"
                    url: "https://investors.spotify.com/..."
                  
                  - source: "Midia Research 2023"
                    finding: "ìŒì•… ìŠ¤íŠ¸ë¦¬ë° ì‹œì¥ ì ìœ ìœ¨ 31%"
                
                success_factors:
                  - "Discover Weekly ê°œì¸í™” (ì´íƒˆë¥  15% ê°ì†Œ)"
                  - "Podcast ë²ˆë“¤ (ì²´ë¥˜ì‹œê°„ 2ë°°)"
                  - "Family Plan (ARPU 35% ì¦ê°€)"
                
                lessons:
                  - "í”„ë¦¬ë¯¸ì—„ ì°¨ë³„í™” ëª…í™•í•´ì•¼ (ê´‘ê³  ì œê±° + ìŒì§ˆ)"
                  - "ë¬´ë£Œ â†’ ìœ ë£Œ ì „í™˜ í¼ë„ ì¤‘ìš”"
                  - "ë„¤íŠ¸ì›Œí¬ íš¨ê³¼ (í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ê³µìœ )"
          
          measurement: |
            ì§ˆë¬¸: "ì´ ë°ì´í„°ë¥¼ ì‹ ë¢°í•  ìˆ˜ ìˆëŠ”ê°€?"
            Pass: ì¶œì²˜ ëª…í™• + ìˆ˜ì¹˜ ê²€ì¦ ê°€ëŠ¥
            Fail: ì£¼ì¥ë§Œ, ê·¼ê±° ì—†ìŒ
        
        4_applicability:
          weight: 2
          requirement: "5+ ì‚°ì—… ì ìš© ì˜ˆì‹œ + í…œí”Œë¦¿"
          
          must_include:
            - "ìµœì†Œ 5ê°œ ì‚°ì—… ì˜ˆì‹œ"
            - "ì‚°ì—…ë³„ ì ì‘ ë°©ë²•"
            - "ì ìš© í…œí”Œë¦¿"
          
          example_good: |
            industry_applications:
              
              music_streaming:
                companies: ["Spotify", "Apple Music", "YouTube Music"]
                
                adaptation:
                  product: "ìŒì•… ìŠ¤íŠ¸ë¦¬ë°"
                  pricing: "ì›” 9,900ì› (ê°œì¸), 14,900ì› (ê°€ì¡±)"
                  differentiation: "íë ˆì´ì…˜ ì•Œê³ ë¦¬ì¦˜"
                  lock_in: "í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ì¶•ì "
              
              video_streaming:
                companies: ["Netflix", "Disney+", "Apple TV+"]
                
                adaptation:
                  product: "ì˜ìƒ ì½˜í…ì¸ "
                  pricing: "ì›” 9,500 ~ 17,000ì› (í”Œëœë³„)"
                  differentiation: "ì˜¤ë¦¬ì§€ë„ ì½˜í…ì¸ "
                  lock_in: "ì‹œì²­ ì´ë ¥ ê¸°ë°˜ ì¶”ì²œ"
              
              saas_software:
                companies: ["Adobe Creative Cloud", "Microsoft 365"]
              
              fitness:
                companies: ["Peloton", "ClassPass"]
              
              rental:
                companies: ["ì½”ì›¨ì´", "ì²­í˜¸ë‚˜ì´ìŠ¤"]
              
              food:
                companies: ["ë°€í‚¤íŠ¸ ì •ê¸° ë°°ì†¡", "ì™€ì¸ êµ¬ë…"]
              
              # ... (ì´ 5+ ì‚°ì—…)
            
            adaptation_template:
              step_1: "ë°˜ë³µ ì‚¬ìš©/ì†Œë¹„ë˜ëŠ”ê°€?"
              step_2: "ì§€ì†ì  ê°€ì¹˜ ì œê³µ ê°€ëŠ¥í•œê°€?"
              step_3: "ì´ˆê¸° êµ¬ë§¤ ì¥ë²½ ë†’ì€ê°€? (êµ¬ë…ìœ¼ë¡œ ë‚®ì¶¤)"
              step_4: "ê³ ê° ë°ì´í„° ì¶•ì  ê°€ëŠ¥í•œê°€?"
              step_5: "Lock-in ë©”ì»¤ë‹ˆì¦˜ ì„¤ê³„"
          
          measurement: |
            ì§ˆë¬¸: "5ê°œ ì´ìƒ ì‚°ì—…ì— ì ìš© ì˜ˆì‹œ ìˆëŠ”ê°€?"
            Pass: ë²”ìš© íŒ¨í„´ ì¦ëª…
            Fail: íŠ¹ì • ì‚°ì—…ë§Œ
        
        5_recency:
          weight: 2
          requirement: "2023-2024 ìµœì‹  ë°ì´í„°"
          
          must_include:
            - "ìµœê·¼ 2ë…„ ë°ì´í„°"
            - "ìµœì‹  íŠ¸ë Œë“œ"
            - "ì—…ë°ì´íŠ¸ ë‚ ì§œ"
          
          example_good: |
            latest_data:
              
              spotify_2023:
                subscribers: "2.2ì–µëª… (2023 Q4)"
                growth: "YoY +14%"
                churn: "5.2% (ê°œì„ , 2022ë…„ 5.8%)"
              
              trends_2024:
                - trend: "AI ê°œì¸í™”"
                  example: "Spotify AI DJ (2023ë…„ ì¶œì‹œ)"
                  adoption: "3ê°œì›” ë‚´ 1,000ë§Œ ì‚¬ìš©"
                  impact: "ì´íƒˆë¥  15% ê°ì†Œ"
                
                - trend: "Podcast ë²ˆë“¤ë§"
                  growth: "2020-2023ë…„ ì—°í‰ê·  40% ì„±ì¥"
                  revenue_share: "ì „ì²´ ë§¤ì¶œì˜ 20%"
                
                - trend: "ê°€ì¡± ìš”ê¸ˆì œ ì„±ì¥"
                  spotify_family: "35% ARPU ì¦ê°€"
                  adoption_rate: "êµ¬ë…ìì˜ 40%"
            
            last_updated: "2025-11-03"
          
          measurement: |
            ì§ˆë¬¸: "2023-2025ë…„ ë°ì´í„° í¬í•¨í•˜ëŠ”ê°€?"
            Pass: ìµœì‹  ë°ì´í„° + íŠ¸ë Œë“œ
            Fail: 3ë…„ ì´ìƒ ëœ ë°ì´í„°
  
  # ========================================
  # í’ˆì§ˆ ê´€ë¦¬ í”„ë¡œì„¸ìŠ¤
  # ========================================
  
  quality_management:
    
    # --- Week 1: ìë™ ê²€ì¦ ë„êµ¬ ---
    automated_validation:
      
      script: "scripts/validate_pattern_quality.py"
      
      code: |
        def validate_pattern(pattern: dict) -> dict:
            """5ê°€ì§€ í’ˆì§ˆ ìš”ê±´ ê²€ì¦"""
            
            score = {
                'context': 0,  # max 3
                'actionability': 0,  # max 3
                'evidence': 0,  # max 3
                'applicability': 0,  # max 2
                'recency': 0  # max 2
            }
            
            # 1. Context (3ì )
            required_fields = ['pattern_name', 'concept', 'why_important', 
                              'when_applicable', 'industries']
            if all(f in pattern for f in required_fields):
                score['context'] = 3
            elif sum(f in pattern for f in required_fields) >= 3:
                score['context'] = 2
            else:
                score['context'] = 1
            
            # 2. Actionability (3ì )
            if 'critical_success_factors' in pattern:
                csf = pattern['critical_success_factors']
                
                # êµ¬ì²´ì  ëª©í‘œì¹˜ ìˆë‚˜?
                has_targets = any('target' in str(f) for f in csf)
                # How-to ìˆë‚˜?
                has_howto = any('how_to_achieve' in str(f) for f in csf)
                # ì¸¡ì • ë°©ë²• ìˆë‚˜?
                has_measurement = any('measurement' in str(f) for f in csf)
                # ë²¤ì¹˜ë§ˆí¬ ìˆë‚˜?
                has_benchmarks = any('benchmarks' in str(f) for f in csf)
                
                score['actionability'] = sum([has_targets, has_howto, 
                                             has_measurement, has_benchmarks])
                score['actionability'] = min(score['actionability'], 3)
            
            # 3. Evidence (3ì )
            if 'success_cases' in pattern:
                cases = pattern['success_cases']
                
                # ìµœì‹  ì‚¬ë¡€ (2023+)
                recent_cases = [c for c in cases 
                               if 'year' in str(c) and '2023' in str(c) or '2024' in str(c)]
                
                # ì •ëŸ‰ ë°ì´í„°
                has_metrics = any('metrics' in str(c) for c in cases)
                
                # ì¶œì²˜
                has_source = any('source' in str(c) or 'evidence' in str(c) for c in cases)
                
                if len(recent_cases) >= 2 and has_metrics and has_source:
                    score['evidence'] = 3
                elif len(recent_cases) >= 1 and has_metrics:
                    score['evidence'] = 2
                else:
                    score['evidence'] = 1
            
            # 4. Applicability (2ì )
            if 'industry_applications' in pattern:
                industries = pattern['industry_applications']
                
                if len(industries) >= 5:
                    score['applicability'] = 2
                elif len(industries) >= 3:
                    score['applicability'] = 1
            
            # 5. Recency (2ì )
            if 'last_updated' in pattern:
                year = int(pattern['last_updated'][:4])
                if year >= 2024:
                    score['recency'] = 2
                elif year >= 2023:
                    score['recency'] = 1
            
            # Overall Grade
            total = sum(score.values())
            
            if total >= 12:
                grade = 'A+'
            elif total >= 10:
                grade = 'A'
            elif total >= 8:
                grade = 'B+'
            elif total >= 6:
                grade = 'B'
            else:
                grade = 'C'
            
            return {
                'scores': score,
                'total': total,
                'grade': grade,
                'improvements': generate_improvement_suggestions(score)
            }
      
      usage: |
        python scripts/validate_pattern_quality.py
        
        â†’ ê° íŒ¨í„´ ì ìˆ˜
        â†’ ë“±ê¸‰ ë¶„í¬
        â†’ ê°œì„  í•„ìš” í•­ëª©
    
    # --- Week 2: í’ˆì§ˆ í–¥ìƒ (ìƒìœ„ 10ê°œ) ---
    week_2_quality_improvement:
      
      target_patterns:
        - "subscription_model"
        - "platform_business_model"
        - "d2c_model"
        - "saas_model"
        - "marketplace_model"
        - "franchise_model"
        - "licensing_model"
        - "advertising_model"
        - "freemium_model"
        - "aggregator_model"
      
      improvement_template:
        
        file: "scripts/improve_pattern_template.yaml"
        
        template: |
          # {pattern_id} í’ˆì§ˆ í–¥ìƒ í…œí”Œë¦¿
          
          # í˜„ì¬ ì ìˆ˜: {current_grade}
          # ëª©í‘œ ì ìˆ˜: A+
          
          improvements:
            
            context_completeness:
              current_missing:
                - {field_1}
                - {field_2}
              
              add:
                {field_1}: |
                  (ë‚´ìš© ì‘ì„±)
            
            actionability:
              current_abstract:
                - "ë‚®ì€ í•´ì§€ìœ¨" (ì–¼ë§ˆë‚˜?)
              
              make_concrete:
                - target: "< 5% monthly"
                  how: "ê°œì¸í™” ì¶”ì²œ"
                  measure: "ì›”ë³„ í•´ì§€ ê³ ê° / êµ¬ë…ì"
                  benchmarks: ["Spotify: 5.2%"]
            
            evidence:
              current_missing:
                - "ì¶œì²˜ ì—†ìŒ"
                - "ì˜¤ë˜ëœ ë°ì´í„° (2020)"
              
              add:
                - company: "Spotify"
                  year: "2023"
                  metrics: {...}
                  source: "ì—°ê°„ ë³´ê³ ì„œ"
            
            applicability:
              current: "3ê°œ ì‚°ì—…"
              target: "5+ ì‚°ì—…"
              
              add_industries:
                - "fitness (Peloton)"
                - "food (ë°€í‚¤íŠ¸)"
            
            recency:
              current: "2022"
              target: "2024"
              
              update:
                - "2023-2024 ìµœì‹  ë°ì´í„°"
                - "AI ê°œì¸í™” íŠ¸ë Œë“œ"
      
      process:
        for_each_pattern:
          step_1: "í˜„ì¬ í’ˆì§ˆ ê²€ì¦"
          step_2: "ê°œì„  í…œí”Œë¦¿ ìƒì„±"
          step_3: "ê° ì„¹ì…˜ ë³´ê°•"
          step_4: "ì¬ê²€ì¦"
          step_5: "A ë“±ê¸‰ í™•ì¸"
        
        result: "10ê°œ íŒ¨í„´ A+ ë“±ê¸‰"
    
    # --- Week 3: ë°ì´í„° ì¶”ê°€ ìë™í™” ---
    week_3_data_addition:
      
      cursorrules_update:
        
        section: "data_add"
        
        content: |
          # .cursorrules
          
          data_add:
            detect: ["ë°ì´í„° ì¶”ê°€", "íŒ¨í„´ ì¶”ê°€", "ì‚¬ë¡€ ì¶”ê°€", "ë„£ì–´ì¤˜"]
            
            smart_flow:
              
              step_1_understand:
                user_input: "ì½”ì›¨ì´ í•´ì§€ìœ¨ 4.2% ì¶”ê°€í•´ì¤˜"
                
                ai_parse:
                  entity: "ì½”ì›¨ì´"
                  metric: "í•´ì§€ìœ¨ 4.2%"
                  context: "êµ¬ë…/ë Œíƒˆ ë¹„ì¦ˆë‹ˆìŠ¤"
                
                ai_infer:
                  pattern: "subscription_model"
                  section: "success_cases ë˜ëŠ” critical_success_factors"
                  reason: "í•´ì§€ìœ¨ = êµ¬ë… ëª¨ë¸ì˜ í•µì‹¬ ì§€í‘œ"
              
              step_2_find_location:
                action: "data/raw/umis_business_model_patterns.yaml ì—´ê¸°"
                
                search_pattern: "subscription_model"
                
                search_section:
                  options:
                    - "critical_success_factors.low_churn_rate.benchmarks"
                    - "success_cases"
                  
                  choose: "low_churn_rate.benchmarks (ë” ì ì ˆ)"
              
              step_3_suggest_addition:
                show_current: |
                  low_churn_rate:
                    benchmarks:
                      - company: "Spotify"
                        value: "5.2%"
                        year: "2023"
                      
                      - company: "Netflix"
                        value: "2.4%"
                        year: "2023"
                
                suggest_add: |
                  low_churn_rate:
                    benchmarks:
                      - company: "Spotify"
                        value: "5.2%"
                        year: "2023"
                      
                      - company: "Netflix"
                        value: "2.4%"
                        year: "2023"
                      
                      - company: "ì½”ì›¨ì´"  â† ì¶”ê°€
                        value: "4.2%"
                        year: "2023"
                        industry: "ë Œíƒˆ (í•œêµ­)"
                        source: "ê³µì‹œìë£Œ"
                
                ask: "ì´ë ‡ê²Œ ì¶”ê°€í• ê¹Œìš”? (Y/n)"
              
              step_4_quality_check:
                before_add:
                  - "ì¶œì²˜ ìˆë‚˜? â†’ 'source' í•„ë“œ"
                  - "ë…„ë„ ìˆë‚˜? â†’ 'year' í•„ë“œ"
                  - "ë§¥ë½ ìˆë‚˜? â†’ 'industry' í•„ë“œ"
                
                if_missing:
                  prompt: "ì¶œì²˜ë¥¼ ì¶”ê°€í•´ì£¼ì„¸ìš” (ì˜ˆ: ê³µì‹œìë£Œ, ì–¸ë¡  ë³´ë„)"
              
              step_5_add:
                if_approved:
                  - "íŒŒì¼ ìˆ˜ì •"
                  - "git diff í™•ì¸ (ì‚¬ìš©ìì—ê²Œ ë³´ì—¬ì£¼ê¸°)"
                  - "ì €ì¥"
              
              step_6_rebuild:
                ask: "RAG ì¬êµ¬ì¶•? (2ì´ˆ ì†Œìš”) (Y/n)"
                
                if_yes:
                  - "python scripts/01_convert_yaml.py"
                  - "python scripts/02_build_index.py --agent explorer"
                  - "âœ… RAG ì—…ë°ì´íŠ¸ ì™„ë£Œ!"
            
            shortcuts:
              - "ragì— {data} ì¶”ê°€": ìœ„ í”Œë¡œìš° ìë™ ì‹¤í–‰
              - "rag ì¬êµ¬ì¶•": scripts/01+02
              - "íŒ¨í„´ í’ˆì§ˆ ê²€ì¦": scripts/validate_pattern_quality.py
      
      interactive_script:
        
        file: "scripts/add_data_interactive.py"
        
        flow: |
          def interactive_add():
              print("ğŸ¯ RAG ë°ì´í„° ì¶”ê°€ (í’ˆì§ˆ ë³´ì¥)")
              
              # 1. íƒ€ì…
              type_choice = select_type()  # business_model or disruption
              
              # 2. íŒ¨í„´ ì„ íƒ
              patterns = list_patterns(type_choice)
              pattern = select_pattern(patterns)
              
              # 3. ì„¹ì…˜ ì„ íƒ
              sections = list_sections(pattern)
              section = select_section(sections)
              
              # 4. ë°ì´í„° ì…ë ¥
              data = input_data_with_template(section)
              
              # 5. í’ˆì§ˆ ê²€ì¦
              quality = validate_input_quality(data)
              
              if quality['grade'] < 'B':
                  print(f"âš ï¸ í’ˆì§ˆ: {quality['grade']}")
                  print("ê°œì„  í•„ìš”:")
                  for improvement in quality['improvements']:
                      print(f"  - {improvement}")
                  
                  if not confirm("ê³„ì†?"):
                      return
              
              # 6. ë¯¸ë¦¬ë³´ê¸°
              show_diff(pattern, section, data)
              
              # 7. ìŠ¹ì¸
              if confirm("ì¶”ê°€?"):
                  add_to_yaml(pattern, section, data)
                  
                  if confirm("RAG ì¬êµ¬ì¶•?"):
                      rebuild_rag()
                  
                  print("âœ… ì™„ë£Œ!")
  
  # ========================================
  # ë°¸ëŸ°ìŠ¤ ê´€ë¦¬
  # ========================================
  
  balance_management:
    
    current_distribution:
      industry:
        tech: "40%"
        retail: "20%"
        service: "15%"
        manufacturing: "10%"
        finance: "8%"
        others: "7%"
      
      model_type:
        platform: "25%"
        subscription: "20%"
        transaction: "15%"
        licensing: "10%"
        advertising: "10%"
        others: "20%"
      
      market_type:
        b2c: "60%"
        b2b: "30%"
        b2g: "5%"
        c2c: "5%"
    
    target_distribution:
      industry:
        each: "15-20% (ê· í˜•)"
      
      model_type:
        major: "> 15% (ì£¼ìš” ëª¨ë¸)"
        others: "> 5% (ì»¤ë²„ë¦¬ì§€)"
      
      market_type:
        b2c: "40%"
        b2b: "40%"
        b2g: "10%"
        c2c: "10%"
    
    rebalancing_strategy:
      
      identify_gaps:
        code: |
          current = analyze_current_distribution()
          target = get_target_distribution()
          
          gaps = {
              industry: target - current
              for industry, target in target.items()
          }
          
          # ê°€ì¥ ë¶€ì¡±í•œ ê²ƒ ìš°ì„ 
          priority_gaps = sorted(gaps.items(), key=lambda x: -x[1])
      
      targeted_addition:
        process: |
          for industry, gap in priority_gaps:
              if gap > 0:
                  print(f"ğŸ“‹ {industry} íŒ¨í„´ {gap}% ë¶€ì¡±")
                  print(f"   ì¶”ê°€ í•„ìš”: ~{gap/15}ê°œ íŒ¨í„´")
                  
                  # í•´ë‹¹ ì‚°ì—… íŒ¨í„´ ì¡°ì‚¬
                  # í’ˆì§ˆ ê¸°ì¤€ ì¶©ì¡±í•˜ëŠ” íŒ¨í„´ ì¶”ê°€

# ========================================
# êµ¬í˜„ ìˆœì„œ (ìµœì¢…)
# ========================================

implementation_order:
  
  v7_1_0:
    duration: "2ê°œì›”"
    
    # ========================================
    # Sprint 1: System RAG ì•ˆì •í™” (ì™„ë£Œ!)
    # ========================================
    
    sprint_1_completed:
      date: "2025-11-03"
      duration: "Day 1-2 (ì™„ë£Œ)"
      status: "âœ… ì™„ë£Œ"
      
      completed_tasks:
        - task: "KeyDirectory êµ¬í˜„"
          file: "scripts/query_system_rag.py"
          lines: 200
          status: "âœ…"
        
        - task: "tool_key ë©”íƒ€ë°ì´í„° ì£¼ì…"
          file: "scripts/build_system_knowledge.py"
          lines: 150
          status: "âœ…"
        
        - task: "Key-first Â· Vector-fallback ë¡œì§"
          file: "scripts/query_system_rag.py"
          lines: "í¬í•¨"
          status: "âœ…"
        
        - task: "ê²°ì •ì„± í…ŒìŠ¤íŠ¸"
          file: "scripts/test_system_rag_determinism.py"
          lines: 150
          status: "âœ…"
        
        - task: "Tool Registry ì‘ì„±"
          file: "config/tool_registry.yaml"
          tools: 10
          lines: 450
          status: "âœ…"
      
      deliverables:
        - "SystemRAG í´ë˜ìŠ¤ (Key-first Â· Vector-fallback)"
        - "KeyDirectory O(1) ì •í™• ë§¤ì¹­"
        - "ê²°ì •ì„± í…ŒìŠ¤íŠ¸ (100íšŒ ë°˜ë³µ)"
        - "Tool Registry (10ê°œ ë„êµ¬)"
      
      metrics_achieved:
        - "ì§€ì—°ì‹œê°„ < 1ms (KeyDirectory ì„¤ê³„)"
        - "ê²°ì •ì„± 100% (í…ŒìŠ¤íŠ¸ ì½”ë“œ ì™„ì„±)"
        - "ì½”ë“œ í’ˆì§ˆ Clean"
    
    # ========================================
    # Month 1: System RAG ì™„ì„±
    # ========================================
    
    month_1:
      week_1: "Tool Registry êµ¬ì¶• (10ê°œ â†’ 25ê°œ ë„êµ¬ í™•ì¥)"  # âœ… 10ê°œ ì™„ë£Œ
      week_2: "umis_core.yaml (INDEX) ì‘ì„±"
      week_3: "System RAG Index êµ¬ì¶•"  # âœ… ìŠ¤í¬ë¦½íŠ¸ ì™„ì„±
      week_4: ".cursorrules í†µí•© + í…ŒìŠ¤íŠ¸"
      
      deliverable: "System RAG ì™„ì„±"
      context_saving: "77% (4,200ì¤„)"
      
      progress:
        week_1: "50% (10/25ê°œ ë„êµ¬)"
        week_3: "80% (ìŠ¤í¬ë¦½íŠ¸ ì™„ì„±, ì‹¤í–‰ ëŒ€ê¸°)"
    
    month_2:
      week_1_2: "Excel FormulaEngine"
      week_3: "9ê°œ ì‹œíŠ¸ ìƒì„±ê¸°"
      week_4: "Excel ê²€ì¦ + ë°ì´í„° í’ˆì§ˆ í–¥ìƒ"
      
      deliverable:
        - "Excel ìë™ ìƒì„±"
        - "A ë“±ê¸‰ íŒ¨í„´ 65%"
  
  v7_2_0:
    duration: "1ê°œì›”"
    
    focus:
      - "ë°ì´í„° ë°¸ëŸ°ìŠ¤ (ì‚°ì—…ë³„ ê· í˜•)"
      - "Markdown ì‚°ì¶œë¬¼ ìƒì„±"
      - "System RAG ìµœì í™”"

# ========================================
# ì„±ê³µ ì§€í‘œ
# ========================================

success_metrics:
  
  project_1_excel:
    - "9ê°œ ì‹œíŠ¸ ìë™ ìƒì„±: 100%"
    - "í•¨ìˆ˜ ì •í™•ë„: 100% (Excel ê²€ì¦)"
    - "Named Range ì‚¬ìš©ë¥ : 100%"
    - "Â±30% ìˆ˜ë ´: ìë™ í™•ì¸"
  
  project_2_system_rag:
    - "ì»¨í…ìŠ¤íŠ¸ ì ˆì•½: > 75%"
    - "ê²€ìƒ‰ ì •í™•ë„: 100% (key ê¸°ë°˜)"
    - "AI íŒŒì•… ì‹œê°„: < 5ë¶„"
    - "ê¸°ëŠ¥ ëˆ„ë½: 0%"
  
  project_3_data_quality:
    - "A ë“±ê¸‰ íŒ¨í„´: > 80%"
    - "ì‚°ì—…ë³„ ê· í˜•: 15-20%"
    - "B2B/B2C ê· í˜•: 40:40"
    - "ìµœì‹  ë°ì´í„°: 2023+ > 80%"

# ========================================
# í…ŒìŠ¤íŠ¸ ì „ëµ (í”¼ë“œë°± ë°˜ì˜)
# ========================================

testing_strategy:
  
  # 1. System RAG ê²°ì •ì„± í…ŒìŠ¤íŠ¸
  system_rag_determinism:
    file: "scripts/test_system_rag_determinism.py"
    
    purpose: "ê°™ì€ í‚¤ â†’ í•­ìƒ ê°™ì€ ê²°ê³¼ (íšŒê·€ ë°©ì§€)"
    
    code: |
      def test_system_rag_determinism():
          """100íšŒ ë°˜ë³µí•´ë„ ë™ì¼í•œ ê²°ê³¼"""
          
          system_rag = SystemRAG()
          test_keys = [
              "tool:explorer:pattern_search",
              "tool:explorer:7_step_process",
              "tool:quantifier:sam_4methods",
              "tool:validator:data_definition",
              "tool:observer:market_structure"
          ]
          
          for key in test_keys:
              results = []
              latencies = []
              
              for _ in range(100):
                  start = time.time()
                  result = system_rag.search_tool_by_key(key)
                  latency = (time.time() - start) * 1000
                  
                  results.append(result['tool_id'])
                  latencies.append(latency)
              
              # ê²€ì¦
              assert len(set(results)) == 1, f"{key}: ê²°ê³¼ ë¶ˆì¼ì¹˜!"
              assert all(r == results[0] for r in results), f"{key}: ë¹„ê²°ì •ì !"
              
              avg_latency = sum(latencies) / len(latencies)
              
              print(f"âœ… {key}")
              print(f"   ê²°ê³¼: {results[0]}")
              print(f"   í‰ê·  ì§€ì—°ì‹œê°„: {avg_latency:.2f}ms")
              print(f"   í‘œì¤€í¸ì°¨: {stdev(latencies):.2f}ms")
    
    metrics:
      determinism: "100% (ë™ì¼ ê²°ê³¼)"
      latency_avg: "< 1ms (KeyDirectory)"
      latency_fallback: "< 20ms (Vector)"
      failure_rate: "0%"
  
  # 2. Excel Golden-Workbook í…ŒìŠ¤íŠ¸
  excel_golden_workbook:
    file: "scripts/test_excel_golden_workbook.py"
    
    purpose: "ìˆ˜ì‹/Named Range íšŒê·€ ê°ì§€ (ê³„ì‚°ê°’ X)"
    
    setup: |
      # 1íšŒë§Œ: ê³¨ë“  ì›Œí¬ë¶ ìƒì„±
      golden_data = {
          'market_name': 'test_market',
          'assumptions': [...],
          'tam': {...},
          ...
      }
      
      golden_wb = generate_workbook(**golden_data)
      save_golden(golden_wb, 'tests/golden/market_sizing_golden.xlsx')
    
    code: |
      def test_excel_generation_regression():
          """ì‹ ê·œ ìƒì„±ë³¸ vs ê³¨ë“  ë¹„êµ"""
          
          # ê³¨ë“  ë¡œë“œ
          golden = load_workbook('tests/golden/market_sizing_golden.xlsx')
          
          # ì‹ ê·œ ìƒì„±
          generated = generate_workbook(**golden_data)
          
          # 1. Named Range ë¹„êµ
          assert_named_ranges_match(golden, generated)
          
          # 2. ìˆ˜ì‹ í† í°í™” ë¹„êµ (ê³„ì‚°ê°’ X, ìˆ˜ì‹ë§Œ!)
          assert_formulas_match(golden, generated)
          
          # 3. êµì°¨ ì‹œíŠ¸ ì°¸ì¡° ê·¸ë˜í”„ ë¹„êµ
          assert_cross_sheet_refs_match(golden, generated)
          
          # 4. ì¡°ê±´ë¶€ ì„œì‹ ë¹„êµ
          assert_conditional_formatting_match(golden, generated)
      
      def assert_formulas_match(golden, generated):
          """ìˆ˜ì‹ í† í°í™” í›„ ë¹„êµ"""
          
          for sheet_name in golden.sheetnames:
              golden_sheet = golden[sheet_name]
              gen_sheet = generated[sheet_name]
              
              for row in golden_sheet.iter_rows():
                  for cell in row:
                      if isinstance(cell.value, str) and cell.value.startswith('='):
                          golden_formula = normalize_formula(cell.value)
                          gen_formula = normalize_formula(gen_sheet[cell.coordinate].value)
                          
                          assert golden_formula == gen_formula, \
                              f"{sheet_name}!{cell.coordinate}: ìˆ˜ì‹ ë¶ˆì¼ì¹˜\n" \
                              f"  Golden: {golden_formula}\n" \
                              f"  Generated: {gen_formula}"
      
      def normalize_formula(formula: str) -> str:
          """ìˆ˜ì‹ ì •ê·œí™” (ê³µë°±/ëŒ€ì†Œë¬¸ì)"""
          return formula.upper().replace(' ', '')
    
    metrics:
      formula_match: "100%"
      named_range_match: "100%"
      cross_ref_match: "100%"
      regression_detected: "Yes/No"
  
  # 3. ë°ì´í„° í’ˆì§ˆ ë¦°í„° (CI/CD)
  data_quality_linter:
    file: "scripts/validate_pattern_quality.py"
    
    purpose: "ì‹ ê·œ/ìˆ˜ì • íŒ¨í„´ í’ˆì§ˆ ê²€ì¦ (B+ ì´ìƒ)"
    
    integration: "PR íŒŒì´í”„ë¼ì¸"
    
    code: |
      def lint_modified_patterns(diff_files: list[str]) -> bool:
          """ìˆ˜ì •ëœ íŒ¨í„´ë§Œ ê²€ì¦"""
          
          modified_patterns = extract_patterns_from_diff(diff_files)
          
          all_passed = True
          for pattern in modified_patterns:
              result = validate_pattern(pattern)
              
              if result['grade'] < 'B':
                  print(f"âŒ {pattern['pattern_id']}: {result['grade']}")
                  print(f"   ê°œì„  í•„ìš”:")
                  for improvement in result['improvements']:
                      print(f"     - {improvement}")
                  
                  all_passed = False
              else:
                  print(f"âœ… {pattern['pattern_id']}: {result['grade']}")
          
          return all_passed
      
      # CI/CDì—ì„œ
      # if not lint_modified_patterns(git_diff_files):
      #     exit(1)  # PR ë³‘í•© ì°¨ë‹¨
    
    metrics:
      min_grade: "B"
      auto_block: "Yes"
      feedback_time: "< 30ì´ˆ"
  
  # 4. ê´€ì°°ê°€ëŠ¥ì„± (Observability)
  observability:
    
    retrieval_trace:
      file: "umis_rag/core/tracer.py"
      
      log_format: |
        {
          "timestamp": "2025-11-03T14:23:45.123Z",
          "query": "êµ¬ë… ëª¨ë¸ íŒ¨í„´",
          "agent": "explorer",
          "retrieval_path": "vector_search",
          "top_k": 5,
          "latency_ms": 15.2,
          "results_count": 5,
          "top_similarity": 0.95
        }
    
    guardian_trace:
      file: "umis_rag/guardian/evaluator.py"
      
      log_format: |
        {
          "deliverable_id": "OPP_20251103_001",
          "stage_1_score": 8.5,
          "stage_2_pass": true,
          "stage_3_llm_called": false,
          "final_grade": "A",
          "warnings": [],
          "recommendations": ["ê²½ìŸìš°ìœ„ êµ¬ì²´í™”"]
        }
    
    excel_generation_trace:
      file: "umis_rag/deliverables/excel/logger.py"
      
      log_format: |
        {
          "workbook": "market_sizing_piano.xlsx",
          "named_ranges_defined": 25,
          "cross_sheet_refs": 18,
          "suspicious_formulas": [],
          "validation_passed": true
        }
    
    dashboard:
      frequency: "ì£¼ê°„"
      metrics:
        - "í‰ê·  ê²€ìƒ‰ ì§€ì—°ì‹œê°„"
        - "Guardian í‰ê°€ ë¶„í¬"
        - "Excel ìƒì„± ì„±ê³µë¥ "
        - "íšŒê·€ ê°ì§€ ê±´ìˆ˜"

# ========================================
# ì‹¤í–‰ ìš°ì„ ìˆœìœ„ (7-10ì¼ ìŠ¤í”„ë¦°íŠ¸)
# ========================================

execution_priority:
  
  sprint_1_system_rag:
    duration: "Day 1-2"
    priority: "P0 (Critical)"
    
    tasks:
      - task: "KeyDirectory êµ¬í˜„"
        file: "scripts/query_system_rag.py"
        estimate: "4ì‹œê°„"
        
      - task: "tool_key ë©”íƒ€ë°ì´í„° ì£¼ì…"
        file: "scripts/build_system_knowledge.py"
        estimate: "2ì‹œê°„"
        
      - task: "Key-first Â· Vector-fallback ë¡œì§"
        file: "scripts/query_system_rag.py"
        estimate: "3ì‹œê°„"
        
      - task: "ê²°ì •ì„± í…ŒìŠ¤íŠ¸"
        file: "scripts/test_system_rag_determinism.py"
        estimate: "3ì‹œê°„"
    
    success_criteria:
      - "100íšŒ ë°˜ë³µ ì‹œ ë™ì¼ ê²°ê³¼"
      - "í‰ê·  ì§€ì—°ì‹œê°„ < 1ms (KeyDirectory)"
      - "ì‹¤íŒ¨ìœ¨ 0%"
  
  sprint_2_excel_hardening:
    duration: "Day 3-5"
    priority: "P0 (Critical)"
    
    tasks:
      - task: "Named Range ì ˆëŒ€ì°¸ì¡° ìˆ˜ì •"
        file: "umis_rag/deliverables/excel/formula_engine.py"
        estimate: "2ì‹œê°„"
        
      - task: "'SAM' Named Range 2ë‹¨ê³„ ì •ì˜"
        file: "umis_rag/deliverables/excel/method_builders.py"
        estimate: "3ì‹œê°„"
        
      - task: "ì¡°ê±´ë¶€ ì„œì‹ FormulaRule êµì²´"
        file: "umis_rag/deliverables/excel/convergence_builder.py"
        estimate: "2ì‹œê°„"
        
      - task: "fullCalcOnLoad=True ì¶”ê°€"
        file: "umis_rag/deliverables/excel/market_sizing_generator.py"
        estimate: "1ì‹œê°„"
        
      - task: "Golden-Workbook í…ŒìŠ¤íŠ¸"
        file: "scripts/test_excel_golden_workbook.py"
        estimate: "4ì‹œê°„"
    
    success_criteria:
      - "Named Range 100% ì ˆëŒ€ì°¸ì¡°"
      - "ì¡°ê±´ë¶€ ì„œì‹ ì‘ë™ (Excel í™•ì¸)"
      - "Golden-Workbook íšŒê·€ í…ŒìŠ¤íŠ¸ í†µê³¼"
  
  sprint_3_quality_gates:
    duration: "Day 6-7"
    priority: "P1 (High)"
    
    tasks:
      - task: "ë°ì´í„° í’ˆì§ˆ ë¦°í„° PR ì—°ê²°"
        file: ".github/workflows/quality-check.yml"
        estimate: "3ì‹œê°„"
        
      - task: "Retrieval/Guardian/Excel ë¡œê·¸ í‘œì¤€í™”"
        files:
          - "umis_rag/core/tracer.py"
          - "umis_rag/guardian/evaluator.py"
          - "umis_rag/deliverables/excel/logger.py"
        estimate: "4ì‹œê°„"
        
      - task: "ì£¼ê°„ ëŒ€ì‹œë³´ë“œ ìŠ¤í¬ë¦½íŠ¸"
        file: "scripts/generate_weekly_dashboard.py"
        estimate: "3ì‹œê°„"
    
    success_criteria:
      - "PR ì‹œ ìë™ í’ˆì§ˆ ê²€ì¦"
      - "ë¡œê·¸ JSON í˜•ì‹ í†µì¼"
      - "ëŒ€ì‹œë³´ë“œ ìë™ ìƒì„±"

# ========================================
# END
# ========================================

