# Claude Sonnet 4.5 â†’ GPT-4o ë§ˆì´ê·¸ë ˆì´ì…˜ ê°€ì´ë“œ
**Thinking ëª¨ë¸ í’ˆì§ˆì„ ì¼ë°˜ LLMìœ¼ë¡œ ì¬í˜„í•˜ëŠ” ì‹¤ì „ ì ‘ê·¼**

---

## ğŸ“Œ í˜„ì¬ ìƒí™©

### Claude Sonnet 4.5 (Extended Thinking)

```yaml
íŠ¹ì§•:
  - Extended Thinking: ë‚´ì¥ Chain-of-Thought
  - ìì²´ ê²€ì¦: Self-correction ëŠ¥ë ¥
  - ë³µì¡í•œ ì¶”ë¡ : ë‹¤ë‹¨ê³„ ë¬¸ì œ í•´ê²° ìš°ìˆ˜
  - ë¶ˆí™•ì‹¤ì„± ì²˜ë¦¬: ì• ë§¤í•œ ìƒí™© ì˜ ë‹¤ë£¸
  - ë§¥ë½ ìœ ì§€: ê¸´ ëŒ€í™”ì—ì„œ ì¼ê´€ì„± ìœ ì§€

ë¹„ìš©:
  - ì…ë ¥: ~$3/1M í† í°
  - ì¶œë ¥: ~$15/1M í† í°
  - Extended Thinking í† í°: ì¶”ê°€ ë¹„ìš© (ìˆ¨ê²¨ì§„ í† í°)

UMISì—ì„œ ê°•ì :
  1. Estimator Phase 4: ì°½ì˜ì  ëª¨í˜• ìƒì„±
  2. Discovery Sprint: ëª¨í˜¸í•œ ëª©í‘œ êµ¬ì²´í™”
  3. ë³µì¡í•œ ë°ì´í„° ë¶„ì„: ë‹¤ì°¨ì› íŒ¨í„´ ì¸ì‹
  4. ì¶”ë¡  ì²´ì¸: "A â†’ B â†’ C â†’ ê²°ë¡ " ìë™ ì—°ê²°
```

### GPT-4o (íƒ€ê²Ÿ ëª¨ë¸)

```yaml
íŠ¹ì§•:
  - ë¹ ë¥¸ ì¶”ë¡ : ì‘ë‹µ ì‹œê°„ ì§§ìŒ
  - ì•ˆì •ì : API ì œí•œ ì ìŒ
  - ë©€í‹°ëª¨ë‹¬: ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ í†µí•©
  - ì½”ë“œ ìƒì„±: ë›°ì–´ë‚¨

ë¹„ìš©:
  - ì…ë ¥: ~$5/1M í† í°
  - ì¶œë ¥: ~$15/1M í† í°
  - ì´: Claudeì™€ ìœ ì‚¬ ë˜ëŠ” ì•½ê°„ ë¹„ìŒˆ

ì•½ì :
  - Chain-of-Thought: ëª…ì‹œì  ê°€ì´ë“œ í•„ìš”
  - Self-correction: ì•½í•¨ (í•œ ë²ˆì— ë§ì¶°ì•¼ í•¨)
  - ë³µì¡í•œ ì¶”ë¡ : ë‹¨ê³„ë³„ ë¶„í•´ í•„ìš”
  - ë¶ˆí™•ì‹¤ì„±: ëª…í™•í•œ ì˜µì…˜ ì œì‹œ í•„ìš”
```

### í•µì‹¬ ì°¨ì´

```yaml
Claude Sonnet 4.5ì˜ "ë§ˆë²•":
  1. ë‚´ì¬ì  ì¶”ë¡ : "ìƒê°í•˜ë©´ì„œ" ë‹µë³€
  2. ìë™ ê²€ì¦: ìŠ¤ìŠ¤ë¡œ ì˜¤ë¥˜ ë°œê²¬/ìˆ˜ì •
  3. ë§¥ë½ í†µí•©: ì—¬ëŸ¬ ì •ë³´ ìë™ ì—°ê²°
  4. ë¶ˆí™•ì‹¤ì„± ì²˜ë¦¬: ì• ë§¤í•  ë•Œ ì—¬ëŸ¬ ê°€ëŠ¥ì„± ê³ ë ¤

GPT-4oì˜ íŠ¹ì§•:
  1. ëª…ì‹œì  ê°€ì´ë“œ: ì •í™•í•œ ì§€ì‹œ í•„ìš”
  2. í•œ ë²ˆì— ì •í™•: ì¬ì‹œë„ ì–´ë ¤ì›€
  3. ìˆœì°¨ ì²˜ë¦¬: í•œ ë²ˆì— í•œ ë‹¨ê³„
  4. í™•ì •ì  ì„ í˜¸: ëª…í™•í•œ ë‹µ ì„ í˜¸
```

---

## ğŸ¯ í’ˆì§ˆ ì¬í˜„ ì „ëµ (4ë‹¨ê³„)

### Level 1: ê¸°ë³¸ (70% í’ˆì§ˆ, 1-2ì¼)

**ëª©í‘œ**: ë¹ ë¥´ê²Œ ë™ì‘í•˜ê²Œ ë§Œë“¤ê¸°

#### 1.1 ëª…ì‹œì  Chain-of-Thought í”„ë¡¬í”„íŠ¸

```yaml
Before (Claude Sonnet 4.5):
  "ì„œìš¸ í”¼ì•„ë…¸ í•™ì› ìˆ˜ë¥¼ ì¶”ì •í•´ì¤˜"
  
  â†’ Claude ë‚´ë¶€ì ìœ¼ë¡œ:
    1. ë¬¸ì œ ë¶„í•´ (ìë™)
    2. ë³€ìˆ˜ ì‹ë³„ (ìë™)
    3. ë°ì´í„° ìˆ˜ì§‘ (ìë™)
    4. ëª¨í˜• ìƒì„± (ìë™)
    5. ê²€ì¦ (ìë™)

After (GPT-4o, ëª…ì‹œì  CoT):
  í”„ë¡¬í”„íŠ¸:
    """
    ì„œìš¸ í”¼ì•„ë…¸ í•™ì› ìˆ˜ë¥¼ ì¶”ì •í•´ì¤˜.
    
    ë‹¤ìŒ ë‹¨ê³„ë¥¼ ë”°ë¼ ìƒê°í•´ì¤˜:
    1. ë¬¸ì œ ë¶„í•´: ì–´ë–¤ ë³€ìˆ˜ê°€ í•„ìš”í•œê°€?
    2. ë³€ìˆ˜ ì‹ë³„: ê° ë³€ìˆ˜ë¥¼ ì–´ë–»ê²Œ êµ¬í• ê¹Œ?
    3. ë°ì´í„° ìˆ˜ì§‘: ì•Œë ¤ì§„ ê°’ì€?
    4. ëª¨í˜• ìƒì„±: ì–´ë–¤ ê³µì‹ì„ ì“¸ê¹Œ?
    5. ê²€ì¦: ê²°ê³¼ê°€ í•©ë¦¬ì ì¸ê°€?
    
    ê° ë‹¨ê³„ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì‘ì„±í•œ í›„ ìµœì¢… ë‹µë³€ì„ ì œì‹œí•´ì¤˜.
    """

íš¨ê³¼:
  - Claude 70% ìˆ˜ì¤€ í’ˆì§ˆ
  - êµ¬í˜„ ì‹œê°„: í”„ë¡¬í”„íŠ¸ ìˆ˜ì •ë§Œ (ì¦‰ì‹œ)
```

#### 1.2 Few-shot ì˜ˆì‹œ (í•„ìˆ˜!)

```yaml
í”„ë¡¬í”„íŠ¸ì— ì¶”ê°€:

ì˜ˆì‹œ 1:
  ì§ˆë¬¸: "B2B SaaS í•œêµ­ ARPUëŠ”?"
  
  ìƒê° ê³¼ì •:
    1. ë¬¸ì œ ë¶„í•´:
       - ARPU = Average Revenue Per User
       - ì§€ì—­: í•œêµ­
       - ì‚°ì—…: B2B SaaS
    
    2. ë³€ìˆ˜ ì‹ë³„:
       - ê¸€ë¡œë²Œ B2B SaaS ARPU: $100 (ì•Œë ¤ì§)
       - í•œêµ­ ì¡°ì • ê³„ìˆ˜: 0.6 (ì¶”ì • í•„ìš”)
       - ì‚°ì—… ì¡°ì •: B2B = B2C Ã— 3
    
    3. ë°ì´í„° ìˆ˜ì§‘:
       - ê¸€ë¡œë²Œ í‰ê· : Statista ë¦¬í¬íŠ¸
       - í•œêµ­ ì¡°ì •: GDP per capita ë¹„ìœ¨
    
    4. ëª¨í˜• ì‹¤í–‰:
       - $100 Ã— 0.6 Ã— 3 = $180
       - ì›í™”: $180 Ã— 1,300 = 234,000ì›
       - ë°˜ì˜¬ë¦¼: 200,000ì›
    
    5. ê²€ì¦:
       - í•œêµ­ B2C SaaS ARPU ~70,000ì›
       - B2Bê°€ 3ë°° â†’ 210,000ì› (í•©ë¦¬ì )
  
  ë‹µ: 200,000ì› (confidence: 0.70)

ì˜ˆì‹œ 2:
  ì§ˆë¬¸: "ì„œìš¸ í”¼ì•„ë…¸ í•™ì› ìˆ˜ëŠ”?"
  
  ìƒê° ê³¼ì •:
    1. ë¬¸ì œ ë¶„í•´:
       - ì§€ì—­: ì„œìš¸
       - ì—…ì¢…: í”¼ì•„ë…¸ í•™ì›
       - ëª©í‘œ: ê°œìˆ˜ ì¶”ì •
    
    2. ëª¨í˜• ì„ íƒ:
       - Top-down: ì¸êµ¬ ê¸°ë°˜
       - Bottom-up: í•™ìƒ ìˆ˜ ê¸°ë°˜
    
    3. Top-down:
       - ì„œìš¸ ì¸êµ¬: 1,000ë§Œëª…
       - 1ì¸ë‹¹ í•™ì› ìˆ˜: 1/5,000
       - ê²°ê³¼: 2,000ê°œ
    
    4. Bottom-up:
       - ì„œìš¸ ì´ˆì¤‘ê³ ìƒ: 100ë§Œëª…
       - í”¼ì•„ë…¸ í•™ìŠµë¥ : 3%
       - í•™ì›ë‹¹ í•™ìƒ: 10ëª…
       - ê²°ê³¼: 100ë§Œ Ã— 0.03 / 10 = 3,000ê°œ
    
    5. í‰ê· :
       - (2,000 + 3,000) / 2 = 2,500ê°œ
  
  ë‹µ: 2,500ê°œ (confidence: 0.65)

ì´ì œ ë‹¹ì‹ ì˜ ì§ˆë¬¸ì„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ í’€ì–´ì¤˜:
[ì‹¤ì œ ì§ˆë¬¸]
```

**íš¨ê³¼**:
- Claude 75% ìˆ˜ì¤€
- GPT-4oê°€ ì˜ˆì‹œë¥¼ ëª¨ë°©
- êµ¬í˜„: ì˜ˆì‹œ 5-10ê°œ ì‘ì„± (2-3ì‹œê°„)

#### 1.3 êµ¬ì¡°í™”ëœ ì¶œë ¥ ìš”ì²­

```yaml
í”„ë¡¬í”„íŠ¸ ì¶”ê°€:

ë‹µë³€ í˜•ì‹:
  {
    "thinking_process": [
      {
        "step": 1,
        "description": "ë¬¸ì œ ë¶„í•´",
        "details": "..."
      },
      ...
    ],
    "final_answer": {
      "value": 200000,
      "unit": "ì›",
      "confidence": 0.70,
      "phase": 3
    },
    "reasoning": "ê°„ë‹¨ ìš”ì•½"
  }

íš¨ê³¼:
  - êµ¬ì¡°í™”ëœ ì¶œë ¥ â†’ íŒŒì‹± ì‰¬ì›€
  - ë‹¨ê³„ë³„ ê²€ì¦ ê°€ëŠ¥
```

**Level 1 ì´ íš¨ê³¼**:
- í’ˆì§ˆ: Claude 70-75%
- êµ¬í˜„ ì‹œê°„: 1-2ì¼
- ë¹„ìš©: ë™ì¼ (í”„ë¡¬í”„íŠ¸ ê¸¸ì–´ì§)

---

### Level 2: ì¤‘ê¸‰ (80-85% í’ˆì§ˆ, 1ì£¼)

**ëª©í‘œ**: í…œí”Œë¦¿ê³¼ ë£°ë¡œ í’ˆì§ˆ í–¥ìƒ

#### 2.1 ì˜ì‚¬ê²°ì • íŠ¸ë¦¬ êµ¬í˜„

```python
# umis_rag/agents/estimator/gpt4o_adapter.py (ì‹ ê·œ)

class GPT4oEstimator:
    """
    GPT-4oë¥¼ Claude ìˆ˜ì¤€ìœ¼ë¡œ ëŒì–´ì˜¬ë¦¬ëŠ” ì–´ëŒ‘í„°
    """
    
    TEMPLATES = {
        "ì§€ì—­ë³„_ì¥ì†Œ_ê°œìˆ˜": {
            "trigger": ["ì„œìš¸", "ë¶€ì‚°", "ìŒì‹ì ", "ì¹´í˜", "í•™ì›"],
            "prompt_template": """
ì§ˆë¬¸: {query}

ì´ ì§ˆë¬¸ì€ "ì§€ì—­ë³„ ì¥ì†Œ ê°œìˆ˜" ìœ í˜•ì…ë‹ˆë‹¤.

ì‚¬ìš©í•  ëª¨í˜•:
1. Top-down: {ì§€ì—­}_ì¸êµ¬ Ã— (1 / 1ì¸ë‹¹_{ì¥ì†Œ}_ìˆ˜)
2. Bottom-up: ì ì¬_ê³ ê°_ìˆ˜ Ã— ì´ìš©ë¥  Ã— (1 / ì¥ì†Œë‹¹_ê³ ê°ìˆ˜)

ë‹¨ê³„:
1. ë³€ìˆ˜ ê°’ í™•ì¸:
   - {ì§€ì—­} ì¸êµ¬: [ì•Œë ¤ì§„ ê°’ ë˜ëŠ” ì¶”ì •]
   - 1ì¸ë‹¹ {ì¥ì†Œ} ìˆ˜: [ì¶”ì • í•„ìš”]
   - ì ì¬ ê³ ê° ìˆ˜: [ê³„ì‚° í•„ìš”]

2. ê° ëª¨í˜• ì‹¤í–‰

3. ê²°ê³¼ í‰ê·  ë° ê²€ì¦

ì´ì œ ìœ„ êµ¬ì¡°ë¥¼ ë”°ë¼ ë‹µë³€í•´ì¤˜.
""",
            "examples": [
                # 2-3ê°œ ê´€ë ¨ ì˜ˆì‹œ
            ]
        },
        
        "SaaS_ì§€í‘œ": {
            "trigger": ["LTV", "CAC", "ARPU", "Churn", "MRR"],
            "prompt_template": """
ì§ˆë¬¸: {query}

ì´ ì§ˆë¬¸ì€ "SaaS ì§€í‘œ" ìœ í˜•ì…ë‹ˆë‹¤.

í™•ì • ê³µì‹:
- LTV = ARPU / Churn_Rate
- CAC Payback = CAC / (ARPU Ã— Gross_Margin)
- Rule of 40 = Growth_Rate + Profit_Margin

í•„ìš”í•œ ë³€ìˆ˜:
{variables}

ë‹¨ê³„:
1. ê° ë³€ìˆ˜ ê°’ í™•ì¸ (ì•Œë ¤ì§/ì¶”ì • í•„ìš”)
2. ì¶”ì •ì´ í•„ìš”í•œ ë³€ìˆ˜ â†’ ë²¤ì¹˜ë§ˆí¬ ê²€ìƒ‰
3. ê³µì‹ ì ìš©
4. ê²€ì¦ (ì—…ê³„ í‰ê· ê³¼ ë¹„êµ)

ì´ì œ ë‹µë³€í•´ì¤˜.
""",
            "formulas": {
                "LTV": lambda arpu, churn: arpu / churn,
                # ...
            }
        },
        
        # ... 20-30ê°œ í…œí”Œë¦¿
    }
    
    def estimate(self, query: str, context: dict = None) -> dict:
        """
        GPT-4oë¡œ Claude ìˆ˜ì¤€ ì¶”ì •
        """
        # 1. í…œí”Œë¦¿ ìë™ ì„ íƒ
        template = self._select_template(query)
        
        if template:
            # 2. í…œí”Œë¦¿ ê¸°ë°˜ í”„ë¡¬í”„íŠ¸ ìƒì„±
            prompt = self._build_template_prompt(template, query, context)
        else:
            # 3. Fallback: ì¼ë°˜ CoT í”„ë¡¬í”„íŠ¸
            prompt = self._build_generic_cot_prompt(query, context)
        
        # 4. GPT-4o í˜¸ì¶œ
        response = self._call_gpt4o(prompt)
        
        # 5. ì‘ë‹µ íŒŒì‹± ë° ê²€ì¦
        result = self._parse_and_validate(response)
        
        return result
    
    def _select_template(self, query: str) -> dict:
        """í…œí”Œë¦¿ ìë™ ì„ íƒ (ë£° ê¸°ë°˜)"""
        for name, template in self.TEMPLATES.items():
            if any(trigger in query for trigger in template['trigger']):
                return template
        return None
    
    def _build_template_prompt(self, template: dict, query: str, context: dict) -> str:
        """í…œí”Œë¦¿ ê¸°ë°˜ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        # Few-shot ì˜ˆì‹œ ì¶”ê°€
        examples = "\n\n".join([
            self._format_example(ex) for ex in template['examples'][:3]
        ])
        
        # í”„ë¡¬í”„íŠ¸ ì¡°í•©
        prompt = f"""
ë‹¹ì‹ ì€ ì‹œì¥ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

ë‹¤ìŒ ì˜ˆì‹œë¥¼ ì°¸ê³ í•˜ì—¬ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”:

{examples}

---

ì´ì œ ë‹¹ì‹ ì˜ ì§ˆë¬¸ì…ë‹ˆë‹¤:

{template['prompt_template'].format(query=query, **context)}
"""
        return prompt
```

#### 2.2 ìë™ ê²€ì¦ ë ˆì´ì–´

```python
class ValidationLayer:
    """
    GPT-4o ì‘ë‹µ ìë™ ê²€ì¦ (Claudeì˜ Self-correction ëª¨ë°©)
    """
    
    def validate_and_correct(self, response: dict, query: str) -> dict:
        """
        ì‘ë‹µ ê²€ì¦ ë° ìë™ ìˆ˜ì •
        """
        issues = []
        
        # ê²€ì¦ 1: ë²”ìœ„ ì²´í¬
        if response['value'] < 0:
            issues.append("ìŒìˆ˜ ê°’ (ë¶ˆê°€ëŠ¥)")
        
        # ê²€ì¦ 2: í¬ê¸° ìƒì‹ ì²´í¬
        if "ì„œìš¸" in query and "í•™ì›" in query:
            if not (100 <= response['value'] <= 100000):
                issues.append(f"ë¹„í˜„ì‹¤ì  í¬ê¸°: {response['value']}")
        
        # ê²€ì¦ 3: ë‹¨ìœ„ ì²´í¬
        if "ì›" in query and response.get('unit') != 'ì›':
            issues.append("ë‹¨ìœ„ ë¶ˆì¼ì¹˜")
        
        # ê²€ì¦ 4: Confidence í•©ë¦¬ì„±
        if response.get('phase') == 4 and response.get('confidence', 0) > 0.8:
            issues.append("Fermi ì¶”ì •ì¸ë° confidenceê°€ ë„ˆë¬´ ë†’ìŒ")
        
        # ìˆ˜ì • í•„ìš” ì‹œ
        if issues:
            return self._request_correction(response, issues, query)
        
        return response
    
    def _request_correction(self, original: dict, issues: list, query: str) -> dict:
        """
        ë¬¸ì œ ë°œê²¬ ì‹œ GPT-4oì—ê²Œ ì¬ìš”ì²­ (Self-correction ëª¨ë°©)
        """
        correction_prompt = f"""
ì´ì „ ë‹µë³€ì— ë‹¤ìŒ ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤:
{chr(10).join(f"- {issue}" for issue in issues)}

ì›ë˜ ì§ˆë¬¸: {query}
ì´ì „ ë‹µë³€: {original}

ë¬¸ì œë¥¼ ìˆ˜ì •í•˜ì—¬ ë‹¤ì‹œ ë‹µë³€í•´ì£¼ì„¸ìš”.
"""
        
        corrected = self._call_gpt4o(correction_prompt)
        return corrected
```

#### 2.3 Multi-pass ì „ëµ

```python
class MultiPassEstimator:
    """
    Claudeì˜ Extended Thinkingì„ Multi-passë¡œ ëª¨ë°©
    """
    
    def estimate_with_refinement(self, query: str, max_passes: int = 2) -> dict:
        """
        ì—¬ëŸ¬ ë²ˆ ì¶”ë¡ í•˜ì—¬ ì •í™•ë„ í–¥ìƒ
        """
        # Pass 1: ì´ˆê¸° ì¶”ì •
        result_1 = self.estimator.estimate(query)
        
        if result_1['confidence'] >= 0.85:
            return result_1  # ì¶©ë¶„íˆ í™•ì‹  â†’ ì¢…ë£Œ
        
        # Pass 2: ê²€ì¦ ë° ê°œì„ 
        refinement_prompt = f"""
ì§ˆë¬¸: {query}

1ì°¨ ë‹µë³€: {result_1['value']} (confidence: {result_1['confidence']})

1ì°¨ ì¶”ë¡  ê³¼ì •ì„ ê²€í† í•˜ê³ , ë‹¤ìŒì„ í™•ì¸í•´ì¤˜:
1. ê°€ì •ì´ í•©ë¦¬ì ì¸ê°€?
2. ê³„ì‚°ì´ ì •í™•í•œê°€?
3. ë†“ì¹œ ìš”ì¸ì€ ì—†ë‚˜?
4. ë” ë‚˜ì€ ì ‘ê·¼ì´ ìˆë‚˜?

ê°œì„ ëœ ë‹µë³€ì„ ì œì‹œí•´ì¤˜.
"""
        
        result_2 = self._call_gpt4o(refinement_prompt)
        
        # ë‘ ê²°ê³¼ ë¹„êµ ë° ì„ íƒ
        if abs(result_2['value'] - result_1['value']) / result_1['value'] < 0.2:
            # 20% ì´ë‚´ ì°¨ì´ â†’ í‰ê· 
            return self._merge_results(result_1, result_2)
        else:
            # í° ì°¨ì´ â†’ ë” ë†’ì€ confidence ì„ íƒ
            return result_2 if result_2['confidence'] > result_1['confidence'] else result_1
```

**Level 2 ì´ íš¨ê³¼**:
- í’ˆì§ˆ: Claude 80-85%
- êµ¬í˜„ ì‹œê°„: 1ì£¼
- ë¹„ìš©: +20-30% (Multi-pass)

---

### Level 3: ê³ ê¸‰ (90% í’ˆì§ˆ, 2ì£¼)

**ëª©í‘œ**: Claudeì™€ ê±°ì˜ ë™ë“±í•œ í’ˆì§ˆ

#### 3.1 Ensemble ì „ëµ

```python
class EnsembleEstimator:
    """
    ì—¬ëŸ¬ ì ‘ê·¼ì„ ì¡°í•©í•˜ì—¬ Claude ìˆ˜ì¤€ ë‹¬ì„±
    """
    
    def estimate(self, query: str) -> dict:
        """
        3ê°€ì§€ ì ‘ê·¼ ë³‘ë ¬ ì‹¤í–‰ â†’ ìµœì„  ì„ íƒ
        """
        # Approach 1: í…œí”Œë¦¿ ê¸°ë°˜
        result_template = self.template_estimator.estimate(query)
        
        # Approach 2: RAG ê¸°ë°˜ (ìœ ì‚¬ ì‚¬ë¡€ ê²€ìƒ‰)
        similar_cases = self.rag_search(query, top_k=5)
        result_rag = self._estimate_from_cases(similar_cases)
        
        # Approach 3: ìˆœìˆ˜ LLM (CoT)
        result_llm = self.llm_estimator.estimate(query)
        
        # 3ê°€ì§€ ê²°ê³¼ ë¹„êµ
        results = [result_template, result_rag, result_llm]
        
        # í•©ì˜ í™•ì¸
        if self._check_consensus(results, threshold=0.3):
            # 30% ì´ë‚´ ì¼ì¹˜ â†’ ê°€ì¤‘í‰ê· 
            return self._weighted_average(results)
        else:
            # ë¶ˆì¼ì¹˜ â†’ ê°€ì¥ ë†’ì€ confidence ì„ íƒ
            return max(results, key=lambda r: r['confidence'])
    
    def _check_consensus(self, results: list, threshold: float) -> bool:
        """ê²°ê³¼ ê°„ í•©ì˜ í™•ì¸"""
        values = [r['value'] for r in results]
        mean = sum(values) / len(values)
        
        max_deviation = max(abs(v - mean) / mean for v in values)
        return max_deviation <= threshold
```

#### 3.2 Meta-learner (í•™ìŠµ ì‹œìŠ¤í…œ)

```python
class MetaLearner:
    """
    ì„±ê³µ/ì‹¤íŒ¨ í•™ìŠµí•˜ì—¬ GPT-4o í”„ë¡¬í”„íŠ¸ ìë™ ê°œì„ 
    """
    
    def __init__(self):
        self.success_log = []
        self.failure_log = []
    
    def log_result(self, query: str, result: dict, ground_truth: float = None):
        """ê²°ê³¼ ë¡œê¹…"""
        if ground_truth:
            error = abs(result['value'] - ground_truth) / ground_truth
            
            if error < 0.2:
                self.success_log.append({
                    'query': query,
                    'template': result.get('template_used'),
                    'approach': result.get('approach'),
                    'error': error
                })
            else:
                self.failure_log.append({
                    'query': query,
                    'expected': ground_truth,
                    'got': result['value'],
                    'error': error
                })
    
    def improve_prompt(self, template_name: str) -> str:
        """
        ì„±ê³µ/ì‹¤íŒ¨ íŒ¨í„´ ë¶„ì„ â†’ í”„ë¡¬í”„íŠ¸ ê°œì„ 
        """
        successes = [s for s in self.success_log if s['template'] == template_name]
        failures = [f for f in self.failure_log if f.get('template') == template_name]
        
        if len(successes) > 10 and len(failures) > 5:
            # íŒ¨í„´ ë¶„ì„ (LLM í™œìš©)
            analysis_prompt = f"""
í…œí”Œë¦¿ "{template_name}"ì˜ ì„±ëŠ¥ ë¶„ì„:

ì„±ê³µ ì‚¬ë¡€ ({len(successes)}ê°œ):
{self._format_cases(successes[:5])}

ì‹¤íŒ¨ ì‚¬ë¡€ ({len(failures)}ê°œ):
{self._format_cases(failures[:5])}

ì‹¤íŒ¨ íŒ¨í„´ì„ ë¶„ì„í•˜ê³ , í”„ë¡¬í”„íŠ¸ ê°œì„  ë°©ì•ˆì„ ì œì‹œí•´ì¤˜.
"""
            
            improvements = self._call_gpt4o(analysis_prompt)
            return improvements
```

#### 3.3 Context-aware í”„ë¡¬í”„íŒ…

```python
class ContextAwarePrompter:
    """
    í”„ë¡œì íŠ¸ ë§¥ë½ì„ í™œìš©í•œ ë™ì  í”„ë¡¬í”„íŠ¸
    """
    
    def build_prompt(self, query: str, project_context: dict) -> str:
        """
        í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ í”„ë¡¬í”„íŠ¸
        """
        # í”„ë¡œì íŠ¸ ë§¥ë½ ì¶”ì¶œ
        domain = project_context.get('domain', 'general')
        region = project_context.get('region', 'ì „êµ­')
        existing_data = project_context.get('data', {})
        
        # ë§¥ë½ ê¸°ë°˜ í”„ë¡¬í”„íŠ¸ ìƒì„±
        context_prompt = f"""
ë‹¹ì‹ ì€ ì‹œì¥ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.

í˜„ì¬ í”„ë¡œì íŠ¸ ë§¥ë½:
- ì‚°ì—…: {domain}
- ì§€ì—­: {region}
- ê¸°ì¡´ ë°ì´í„°:
{self._format_data(existing_data)}

ìœ„ ë§¥ë½ì„ ê³ ë ¤í•˜ì—¬ ë‹¤ìŒ ì§ˆë¬¸ì— ë‹µí•´ì£¼ì„¸ìš”:
{query}

ê°€ëŠ¥í•˜ë©´ ê¸°ì¡´ ë°ì´í„°ì™€ ì¼ê´€ì„±ì„ ìœ ì§€í•˜ê³ ,
ì‚°ì—…/ì§€ì—­ íŠ¹ì„±ì„ ë°˜ì˜í•´ì£¼ì„¸ìš”.
"""
        
        return context_prompt
```

**Level 3 ì´ íš¨ê³¼**:
- í’ˆì§ˆ: Claude 90%
- êµ¬í˜„ ì‹œê°„: 2ì£¼
- ë¹„ìš©: +40-50% (Ensemble)

---

### Level 4: ìµœê³ ê¸‰ (95%+ í’ˆì§ˆ, 1ê°œì›”)

**ëª©í‘œ**: Claudeë¥¼ ëŠ¥ê°€

#### 4.1 GPT-4o + Claude Hybrid

```python
class HybridEstimator:
    """
    GPT-4o + Claude Sonnet 4.5 ì¡°í•©
    """
    
    def estimate(self, query: str, budget: str = 'balanced') -> dict:
        """
        ì˜ˆì‚°ì— ë”°ë¼ ëª¨ë¸ ì„ íƒ
        """
        complexity = self._analyze_complexity(query)
        
        if budget == 'minimal':
            # GPT-4oë§Œ
            return self.gpt4o_estimator.estimate(query)
        
        elif budget == 'balanced':
            if complexity > 0.7:
                # ë³µì¡ â†’ Claude
                return self.claude_estimator.estimate(query)
            else:
                # ë‹¨ìˆœ â†’ GPT-4o
                return self.gpt4o_estimator.estimate(query)
        
        elif budget == 'quality':
            # ë‘˜ ë‹¤ ì‹¤í–‰ â†’ ë¹„êµ
            result_gpt = self.gpt4o_estimator.estimate(query)
            result_claude = self.claude_estimator.estimate(query)
            
            if abs(result_gpt['value'] - result_claude['value']) / result_claude['value'] < 0.2:
                # ì¼ì¹˜ â†’ GPT ê²°ê³¼ (ì €ë ´)
                return result_gpt
            else:
                # ë¶ˆì¼ì¹˜ â†’ Claude ì„ íƒ (ì‹ ë¢°)
                return result_claude
```

#### 4.2 ì „ë¬¸ê°€ ì‹œìŠ¤í…œ (Expert System)

```python
class ExpertSystem:
    """
    ë„ë©”ì¸ ì „ë¬¸ê°€ ì§€ì‹ ì¸ì½”ë”©
    """
    
    DOMAIN_KNOWLEDGE = {
        "B2B_SaaS": {
            "typical_ranges": {
                "ARPU": (50000, 500000),  # ì›
                "Churn_Rate": (0.03, 0.15),
                "CAC": (500000, 5000000)
            },
            "rules": [
                {
                    "if": "segment == 'Enterprise'",
                    "then": "ARPU Ã— 3",
                    "confidence": 0.9
                },
                {
                    "if": "region == 'í•œêµ­'",
                    "then": "global_value Ã— 0.6",
                    "confidence": 0.8
                }
            ],
            "benchmarks": {
                "LTV/CAC": (3, 5),  # ê±´ê°•í•œ ë²”ìœ„
                "Payback_months": (6, 18)
            }
        },
        
        "êµìœ¡": {
            "typical_ranges": {
                "í•™ì›ë‹¹_í•™ìƒ": (10, 50),
                "í•™ìŠµë¥ ": (0.02, 0.10),
                "ì›”_ìˆ˜ê°•ë£Œ": (100000, 500000)
            },
            # ...
        }
    }
    
    def validate_result(self, result: dict, domain: str) -> dict:
        """
        ë„ë©”ì¸ ì§€ì‹ìœ¼ë¡œ ê²€ì¦
        """
        knowledge = self.DOMAIN_KNOWLEDGE.get(domain, {})
        
        metric = result.get('metric')
        value = result.get('value')
        
        # ë²”ìœ„ ì²´í¬
        expected_range = knowledge.get('typical_ranges', {}).get(metric)
        if expected_range:
            min_val, max_val = expected_range
            if not (min_val <= value <= max_val):
                result['warning'] = f"ë²”ìœ„ ì´íƒˆ: {metric}ëŠ” ë³´í†µ {min_val}-{max_val}"
        
        # ê·œì¹™ ì ìš©
        for rule in knowledge.get('rules', []):
            if self._evaluate_condition(rule['if'], result):
                suggestion = rule['then']
                result['suggestion'] = suggestion
                result['confidence'] = min(result['confidence'], rule['confidence'])
        
        return result
```

**Level 4 ì´ íš¨ê³¼**:
- í’ˆì§ˆ: Claude 95%+
- êµ¬í˜„ ì‹œê°„: 1ê°œì›”
- ë¹„ìš©: ìƒí™©ë³„ (Hybridë¡œ ìµœì í™”)

---

## ğŸ“Š ë ˆë²¨ë³„ ë¹„êµ

| Level | í’ˆì§ˆ | êµ¬í˜„ ì‹œê°„ | ì£¼ìš” ê¸°ë²• | ë¹„ìš© | ê¶Œì¥ |
|-------|------|----------|----------|------|------|
| **Level 1** | 70-75% | 1-2ì¼ | CoT í”„ë¡¬í”„íŠ¸ + Few-shot | ë™ì¼ | â­â­â­ ì¦‰ì‹œ ì‹œì‘ |
| **Level 2** | 80-85% | 1ì£¼ | í…œí”Œë¦¿ + ê²€ì¦ + Multi-pass | +20-30% | â­â­â­ ì‹¤ìš©ì  |
| **Level 3** | 90% | 2ì£¼ | Ensemble + í•™ìŠµ + Context | +40-50% | â­â­ ê³ í’ˆì§ˆ í•„ìš” ì‹œ |
| **Level 4** | 95%+ | 1ê°œì›” | Hybrid + ì „ë¬¸ê°€ ì‹œìŠ¤í…œ | ìµœì í™” | â­ ì™„ë²½ì£¼ì˜ |

---

## ğŸ¯ ì‹¤ì „ ê¶Œì¥ (ë‹¨ê³„ë³„ ì ‘ê·¼)

### Week 1: Level 1 êµ¬í˜„ (í•„ìˆ˜!)

```yaml
Day 1-2: CoT í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿
  - umis.yamlì— í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ ì¶”ê°€
  - "ìƒê° ê³¼ì •ì„ ëª…ì‹œí•˜ë¼" ì§€ì‹œ
  - êµ¬ì¡°í™”ëœ ì¶œë ¥ í˜•ì‹ ì •ì˜
  
  íŒŒì¼: umis.yaml
  ì„¹ì…˜: gpt4o_prompts
  
  íš¨ê³¼: ì¦‰ì‹œ 70% í’ˆì§ˆ

Day 3-4: Few-shot ì˜ˆì‹œ 10ê°œ
  - Estimator: 5ê°œ
  - Explorer: 3ê°œ
  - Discovery Sprint: 2ê°œ
  
  ê° ì˜ˆì‹œ: ì§ˆë¬¸ â†’ ë‹¨ê³„ë³„ ìƒê° â†’ ë‹µë³€
  
  íš¨ê³¼: 75% í’ˆì§ˆ

Day 5: í…ŒìŠ¤íŠ¸ ë° ì¡°ì •
  - ì‹¤ì œ ì§ˆë¬¸ 10-20ê°œ í…ŒìŠ¤íŠ¸
  - í”„ë¡¬í”„íŠ¸ ë¯¸ì„¸ ì¡°ì •
  
  íš¨ê³¼: ì•ˆì •í™”

ì´ íš¨ê³¼:
  - í’ˆì§ˆ: 70-75% (Claude ëŒ€ë¹„)
  - ë¹„ìš©: ë™ì¼
  - ì†ë„: ì•½ê°„ ëŠë¦¼ (í”„ë¡¬í”„íŠ¸ ê¹€)
```

### Week 2: Level 2 êµ¬í˜„ (ê¶Œì¥)

```yaml
Day 1-3: ì˜ì‚¬ê²°ì • íŠ¸ë¦¬ (10ê°œ í…œí”Œë¦¿)
  íŒŒì¼: umis_rag/agents/estimator/gpt4o_adapter.py
  
  í…œí”Œë¦¿:
    1. ì§€ì—­ë³„_ì¥ì†Œ_ê°œìˆ˜
    2. SaaS_ì§€í‘œ
    3. ì‹œì¥_ê·œëª¨_ë¶„í•´
    4. í•™ìŠµë¥ _ì¶”ì •
    5. ì „í™˜ìœ¨_ì¶”ì •
    6. ê°€ê²©_ì¶”ì •
    7. ê²½ìŸ_ë¶„ì„
    8. ì„±ì¥ë¥ _ì˜ˆì¸¡
    9. ì„¸ê·¸ë¨¼íŠ¸_ë¶„í• 
    10. ë¹„ìš©_êµ¬ì¡°

Day 4-5: ìë™ ê²€ì¦ ë ˆì´ì–´
  íŒŒì¼: umis_rag/core/validation_layer.py
  
  ê²€ì¦:
    - ë²”ìœ„ ì²´í¬
    - ë‹¨ìœ„ ì²´í¬
    - ìƒì‹ ì²´í¬
    - Confidence í•©ë¦¬ì„±

Day 6-7: Multi-pass ì „ëµ
  íŒŒì¼: umis_rag/agents/estimator/multi_pass.py
  
  Pass 1: ì´ˆê¸° ì¶”ì •
  Pass 2: ê²€ì¦ ë° ê°œì„  (confidence < 0.85)

ì´ íš¨ê³¼:
  - í’ˆì§ˆ: 80-85%
  - ë¹„ìš©: +20-30%
  - ì•ˆì •ì„±: ë†’ìŒ
```

### Week 3-4: Level 3 êµ¬í˜„ (ì„ íƒ)

```yaml
ë³µì¡í•œ í”„ë¡œì íŠ¸ë§Œ:
  - Ensemble
  - Meta-learner
  - Context-aware

í’ˆì§ˆ: 90%
ë¹„ìš©: +40-50%
```

---

## ğŸ’¡ ì‹¤ì „ íŒ

### 1. í”„ë¡¬í”„íŠ¸ ìµœì í™”

```yaml
íš¨ê³¼ì ì¸ CoT í”„ë¡¬í”„íŠ¸:

êµ¬ì¡°:
  1. ì—­í•  ì •ì˜: "ë‹¹ì‹ ì€ ì‹œì¥ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤"
  2. ì˜ˆì‹œ ì œì‹œ: 2-3ê°œ ì™„ì „í•œ ì˜ˆì‹œ
  3. ëª…ì‹œì  ë‹¨ê³„: "ë‹¤ìŒ ìˆœì„œë¡œ ìƒê°í•˜ì„¸ìš”"
  4. ì¶œë ¥ í˜•ì‹: JSON ë˜ëŠ” êµ¬ì¡°í™”ëœ í…ìŠ¤íŠ¸
  5. ê²€ì¦ ìš”ì²­: "ë‹µë³€ì´ í•©ë¦¬ì ì¸ì§€ í™•ì¸í•˜ì„¸ìš”"

ì˜ˆì‹œ:
  """
  ë‹¹ì‹ ì€ ì‹œì¥ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤.
  
  ì˜ˆì‹œ 1:
  ì§ˆë¬¸: "B2B SaaS ARPUëŠ”?"
  ìƒê°: [ë‹¨ê³„ë³„ ì¶”ë¡ ]
  ë‹µ: 200,000ì› (confidence: 0.70)
  
  ì˜ˆì‹œ 2:
  ì§ˆë¬¸: "ì„œìš¸ í•™ì› ìˆ˜ëŠ”?"
  ìƒê°: [ë‹¨ê³„ë³„ ì¶”ë¡ ]
  ë‹µ: 2,500ê°œ (confidence: 0.65)
  
  ì´ì œ ë‹¤ìŒì„ ê°™ì€ ë°©ì‹ìœ¼ë¡œ:
  ì§ˆë¬¸: {query}
  
  ë‹¤ìŒ ë‹¨ê³„ë¡œ ìƒê°í•˜ì„¸ìš”:
  1. ë¬¸ì œ ë¶„í•´
  2. ë³€ìˆ˜ ì‹ë³„
  3. ë°ì´í„° ìˆ˜ì§‘
  4. ëª¨í˜• ìƒì„±
  5. ê²€ì¦
  
  JSON í˜•ì‹ìœ¼ë¡œ ë‹µë³€:
  {
    "thinking": [...],
    "answer": {...}
  }
  
  ë§ˆì§€ë§‰ìœ¼ë¡œ ë‹µë³€ì´ í•©ë¦¬ì ì¸ì§€ í™•ì¸í•˜ì„¸ìš”.
  """
```

### 2. í…œí”Œë¦¿ ìš°ì„ ìˆœìœ„

```yaml
ë†’ì€ ROI í…œí”Œë¦¿ (ë¨¼ì € êµ¬í˜„):

1. ì§€ì—­ë³„_ì¥ì†Œ_ê°œìˆ˜ â­â­â­
   - ì‚¬ìš© ë¹ˆë„: ë†’ìŒ
   - íŒ¨í„´: ëª…í™•
   - íš¨ê³¼: í°

2. SaaS_ì§€í‘œ â­â­â­
   - ì‚¬ìš© ë¹ˆë„: ë†’ìŒ
   - ê³µì‹: í™•ì •ì 
   - ì •í™•ë„: ë§¤ìš° ë†’ìŒ

3. ì‹œì¥_ê·œëª¨_ë¶„í•´ â­â­
   - ì‚¬ìš© ë¹ˆë„: ì¤‘ê°„
   - ë³µì¡ë„: ì¤‘ê°„

4. í•™ìŠµë¥ /ì „í™˜ìœ¨ â­â­
   - ì‚¬ìš© ë¹ˆë„: ì¤‘ê°„

5-10: ë„ë©”ì¸ë³„ â­
   - í•„ìš”ì— ë”°ë¼
```

### 3. ë¹„ìš© ìµœì í™”

```yaml
ë¹„ìš© ì ˆê° ì „ëµ:

1. ìºì‹± (80% ì ˆê° ê°€ëŠ¥)
   - ë™ì¼ ì§ˆë¬¸ â†’ ìºì‹œ ì‚¬ìš©
   - TTL: 24ì‹œê°„
   
   êµ¬í˜„:
   @lru_cache(maxsize=1000)
   def estimate_cached(query: str, context_hash: str):
       ...

2. ë°°ì¹˜ ì²˜ë¦¬
   - ì—¬ëŸ¬ ì§ˆë¬¸ í•œ ë²ˆì—
   - API í˜¸ì¶œ 1íšŒ
   
   íš¨ê³¼: 30% ì ˆê°

3. í”„ë¡¬í”„íŠ¸ ì••ì¶•
   - ë¶ˆí•„ìš”í•œ ì„¤ëª… ì œê±°
   - í•µì‹¬ë§Œ
   
   íš¨ê³¼: 20% ì ˆê°

4. ë™ì  Few-shot
   - ëª¨ë“  ì˜ˆì‹œ X
   - ê´€ë ¨ ì˜ˆì‹œ 3ê°œë§Œ
   
   íš¨ê³¼: 40% ì ˆê°
```

### 4. í’ˆì§ˆ ëª¨ë‹ˆí„°ë§

```python
class QualityMonitor:
    """
    GPT-4o vs Claude í’ˆì§ˆ ë¹„êµ
    """
    
    def compare(self, query: str, ground_truth: float = None):
        """
        ë‘ ëª¨ë¸ ë¹„êµ ì‹¤í–‰
        """
        # GPT-4o
        result_gpt = self.gpt4o.estimate(query)
        
        # Claude
        result_claude = self.claude.estimate(query)
        
        # ë¹„êµ
        comparison = {
            'query': query,
            'gpt4o': {
                'value': result_gpt['value'],
                'confidence': result_gpt['confidence'],
                'time': result_gpt['time']
            },
            'claude': {
                'value': result_claude['value'],
                'confidence': result_claude['confidence'],
                'time': result_claude['time']
            },
            'difference_pct': abs(result_gpt['value'] - result_claude['value']) / result_claude['value'],
            'agreement': 'yes' if abs(...) < 0.2 else 'no'
        }
        
        if ground_truth:
            comparison['gpt4o']['error'] = abs(result_gpt['value'] - ground_truth) / ground_truth
            comparison['claude']['error'] = abs(result_claude['value'] - ground_truth) / ground_truth
        
        return comparison
    
    def benchmark(self, test_cases: list):
        """
        ë²¤ì¹˜ë§ˆí¬ ì‹¤í–‰
        """
        results = []
        for case in test_cases:
            result = self.compare(case['query'], case.get('ground_truth'))
            results.append(result)
        
        # í†µê³„
        stats = {
            'total': len(results),
            'agreement_rate': sum(1 for r in results if r['agreement'] == 'yes') / len(results),
            'avg_difference': sum(r['difference_pct'] for r in results) / len(results),
            'gpt4o_avg_error': ...,
            'claude_avg_error': ...
        }
        
        return stats
```

---

## ğŸš€ ì¦‰ì‹œ ì‹¤í–‰ (Copy-paste)

### Step 1: CoT í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿ (umis.yaml ì¶”ê°€)

```yaml
# umis.yaml

gpt4o_prompting:
  role: "ë‹¹ì‹ ì€ ì‹œì¥ ë¶„ì„ ì „ë¬¸ê°€ì…ë‹ˆë‹¤. ë³µì¡í•œ ë¬¸ì œë¥¼ ì²´ê³„ì ìœ¼ë¡œ ë¶„ì„í•˜ê³  ê·¼ê±° ìˆëŠ” ì¶”ì •ì„ ì œê³µí•©ë‹ˆë‹¤."
  
  cot_template: |
    ë‹¤ìŒ ë‹¨ê³„ë¡œ ìƒê°í•˜ë©° ë‹µë³€í•´ì£¼ì„¸ìš”:
    
    1. ë¬¸ì œ ë¶„í•´: ì´ ì§ˆë¬¸ì€ ë¬´ì—‡ì„ ë¬»ëŠ”ê°€? ì–´ë–¤ ë³€ìˆ˜ê°€ í•„ìš”í•œê°€?
    2. ë³€ìˆ˜ ì‹ë³„: ê° ë³€ìˆ˜ë¥¼ ì–´ë–»ê²Œ êµ¬í•  ìˆ˜ ìˆë‚˜? (ì•Œë ¤ì§/ì¶”ì • í•„ìš”)
    3. ë°ì´í„° ìˆ˜ì§‘: ì•Œë ¤ì§„ ê°’ì€? ë²¤ì¹˜ë§ˆí¬ëŠ”? ìœ ì‚¬ ì‚¬ë¡€ëŠ”?
    4. ëª¨í˜• ìƒì„±: ì–´ë–¤ ê³µì‹/ì ‘ê·¼ìœ¼ë¡œ ê³„ì‚°í• ê¹Œ? (2-3ê°œ ëª¨í˜•)
    5. ê²€ì¦: ê²°ê³¼ê°€ í•©ë¦¬ì ì¸ê°€? ì—…ê³„ ìƒì‹ê³¼ ë¶€í•©í•˜ë‚˜?
    
    ê° ë‹¨ê³„ë¥¼ ëª…ì‹œì ìœ¼ë¡œ ì‘ì„±í•œ í›„ ìµœì¢… ë‹µë³€ì„ JSONìœ¼ë¡œ ì œì‹œí•˜ì„¸ìš”:
    {
      "thinking": [
        {"step": 1, "content": "..."},
        {"step": 2, "content": "..."},
        ...
      ],
      "answer": {
        "value": ìˆ«ì,
        "unit": "ë‹¨ìœ„",
        "confidence": 0.0-1.0,
        "phase": 2/3/4,
        "reasoning_summary": "í•œ ë¬¸ì¥ ìš”ì•½"
      }
    }
  
  examples:
    - id: EX-001
      category: saas_metrics
      query: "B2B SaaS í•œêµ­ ì‹œì¥ ARPUëŠ”?"
      thinking:
        step_1: |
          ë¬¸ì œ ë¶„í•´:
          - ARPU = Average Revenue Per User
          - íƒ€ê²Ÿ: B2B SaaS, í•œêµ­ ì‹œì¥
          - í•„ìš” ë³€ìˆ˜: ê¸€ë¡œë²Œ ARPU, í•œêµ­ ì¡°ì • ê³„ìˆ˜, B2B vs B2C ë°°ìˆ˜
        
        step_2: |
          ë³€ìˆ˜ ì‹ë³„:
          - ê¸€ë¡œë²Œ B2B SaaS ARPU: ~$100 (ì•Œë ¤ì§, Statista)
          - í•œêµ­ GDP per capita: ê¸€ë¡œë²Œ ëŒ€ë¹„ 60% (ì¶”ì •)
          - B2B vs B2C: 3ë°° ì°¨ì´ (ì—…ê³„ ìƒì‹)
        
        step_3: |
          ë°ì´í„° ìˆ˜ì§‘:
          - Statista: Global B2B SaaS ARPU $80-120
          - IMF: í•œêµ­ GDP per capita vs Global
          - ë²¤ì¹˜ë§ˆí¬: í•œêµ­ B2C SaaS ARPU ~50,000-100,000ì›
        
        step_4: |
          ëª¨í˜• ìƒì„±:
          ëª¨í˜• 1: ê¸€ë¡œë²Œ ê¸°ì¤€ ì¡°ì •
            $100 Ã— 0.6 (í•œêµ­) = $60
            $60 Ã— 1,300 (í™˜ìœ¨) = 78,000ì›
            Ã— 3 (B2B ë°°ìˆ˜) = 234,000ì›
          
          ëª¨í˜• 2: í•œêµ­ B2C ê¸°ì¤€
            B2C ARPU: 70,000ì› (ì¤‘ê°„ê°’)
            B2B = B2C Ã— 3 = 210,000ì›
          
          í‰ê· : (234,000 + 210,000) / 2 = 222,000ì›
          ë°˜ì˜¬ë¦¼: 200,000ì›
        
        step_5: |
          ê²€ì¦:
          - ë²”ìœ„ ì²´í¬: 50,000-500,000ì› (í•©ë¦¬ì )
          - ë¹„ìœ¨ ì²´í¬: B2B/B2C = 200k/70k = 2.9ë°° (ì—…ê³„ ìƒì‹ ë¶€í•©)
          - Confidence: Phase 3 (Guestimation) â†’ 0.70
      
      answer:
        value: 200000
        unit: "ì›"
        confidence: 0.70
        phase: 3
        reasoning_summary: "ê¸€ë¡œë²Œ ë²¤ì¹˜ë§ˆí¬($100) Ã— í•œêµ­ ì¡°ì •(0.6) Ã— B2B ë°°ìˆ˜(3) = 200,000ì›"
    
    - id: EX-002
      category: fermi_decomposition
      query: "ì„œìš¸ í”¼ì•„ë…¸ í•™ì› ìˆ˜ëŠ”?"
      thinking:
        step_1: |
          ë¬¸ì œ ë¶„í•´:
          - ì§€ì—­: ì„œìš¸
          - ì—…ì¢…: í”¼ì•„ë…¸ í•™ì›
          - ëª©í‘œ: ê°œìˆ˜ ì¶”ì •
          - í•„ìš” ë³€ìˆ˜: ì¸êµ¬, í•™ìŠµë¥ , í•™ì›ë‹¹ í•™ìƒ ìˆ˜
        
        step_2: |
          ë³€ìˆ˜ ì‹ë³„:
          - ì„œìš¸ ì¸êµ¬: 1,000ë§Œëª… (ì•Œë ¤ì§)
          - ì„œìš¸ ì´ˆì¤‘ê³ ìƒ: ~100ë§Œëª… (ì•Œë ¤ì§, ì¸êµ¬ì˜ 10%)
          - í”¼ì•„ë…¸ í•™ìŠµë¥ : ì¶”ì • í•„ìš” (3%?)
          - í•™ì›ë‹¹ í•™ìƒ: ì¶”ì • í•„ìš” (10ëª…?)
        
        step_3: |
          ë°ì´í„° ìˆ˜ì§‘:
          - í†µê³„ì²­: ì„œìš¸ ì¸êµ¬ 9.7ë°±ë§Œ, ì´ˆì¤‘ê³ ìƒ ~1ë°±ë§Œ
          - êµìœ¡ë¶€: ìŒì•…í•™ì› í†µê³„ (ì „êµ­ ~15,000ê°œ)
          - ì¶”ì •: í”¼ì•„ë…¸ ë¹„ì¤‘ 30% â†’ í”¼ì•„ë…¸ í•™ì› ~4,500ê°œ (ì „êµ­)
          - ì„œìš¸ ë¹„ì¤‘: ì „êµ­ì˜ ~60% â†’ 2,700ê°œ
        
        step_4: |
          ëª¨í˜• ìƒì„±:
          ëª¨í˜• 1 (Top-down, ì¸êµ¬ ê¸°ë°˜):
            ì„œìš¸ ì¸êµ¬ 1,000ë§Œ / 1ì¸ë‹¹ í•™ì› ìˆ˜ 5,000 = 2,000ê°œ
          
          ëª¨í˜• 2 (Bottom-up, í•™ìƒ ê¸°ë°˜):
            ì´ˆì¤‘ê³ ìƒ 100ë§Œ Ã— í•™ìŠµë¥  3% = 30,000ëª…
            30,000ëª… / í•™ì›ë‹¹ 10ëª… = 3,000ê°œ
          
          ëª¨í˜• 3 (ì „êµ­ ë¹„ìœ¨):
            ì „êµ­ 4,500ê°œ Ã— ì„œìš¸ ë¹„ì¤‘ 60% = 2,700ê°œ
          
          í‰ê· : (2,000 + 3,000 + 2,700) / 3 = 2,567ê°œ
          ë°˜ì˜¬ë¦¼: 2,500ê°œ
        
        step_5: |
          ê²€ì¦:
          - ì„œìš¸ êµ¬ë³„: 25ê°œ êµ¬ â†’ êµ¬ë‹¹ 100ê°œ (í•©ë¦¬ì )
          - ë™ë„¤ë³„: ë™ë‹¹ 5-10ê°œ (ê´€ì°°ê³¼ ë¶€í•©)
          - Confidence: Phase 4 (Fermi) â†’ 0.65
      
      answer:
        value: 2500
        unit: "ê°œ"
        confidence: 0.65
        phase: 4
        reasoning_summary: "3ê°œ ëª¨í˜• (ì¸êµ¬, í•™ìƒ, ì „êµ­ ë¹„ìœ¨) í‰ê·  â†’ 2,500ê°œ"
```

### Step 2: GPT-4o ì–´ëŒ‘í„° êµ¬í˜„

```python
# umis_rag/agents/estimator/gpt4o_adapter.py

import yaml
from pathlib import Path
from typing import Dict, Any
import json

class GPT4oEstimator:
    """
    GPT-4oë¥¼ Claude Sonnet 4.5 ìˆ˜ì¤€ìœ¼ë¡œ ëŒì–´ì˜¬ë¦¬ëŠ” ì–´ëŒ‘í„°
    """
    
    def __init__(self):
        # umis.yaml ë¡œë“œ
        umis_path = Path(__file__).parent.parent.parent.parent / 'umis.yaml'
        with open(umis_path) as f:
            umis_data = yaml.safe_load(f)
        
        self.prompting_config = umis_data.get('gpt4o_prompting', {})
        self.role = self.prompting_config.get('role')
        self.cot_template = self.prompting_config.get('cot_template')
        self.examples = self.prompting_config.get('examples', [])
    
    def estimate(self, query: str, context: Dict = None) -> Dict[str, Any]:
        """
        GPT-4oë¡œ ì¶”ì • (Claude ìˆ˜ì¤€)
        """
        # 1. ê´€ë ¨ ì˜ˆì‹œ ì„ íƒ (ìµœëŒ€ 3ê°œ)
        relevant_examples = self._select_examples(query, top_k=3)
        
        # 2. í”„ë¡¬í”„íŠ¸ ìƒì„±
        prompt = self._build_prompt(query, relevant_examples, context)
        
        # 3. GPT-4o í˜¸ì¶œ
        response = self._call_gpt4o(prompt)
        
        # 4. ì‘ë‹µ íŒŒì‹±
        result = self._parse_response(response)
        
        # 5. ê²€ì¦
        validated = self._validate(result, query)
        
        return validated
    
    def _build_prompt(self, query: str, examples: list, context: Dict = None) -> str:
        """í”„ë¡¬í”„íŠ¸ êµ¬ì„±"""
        
        # ì˜ˆì‹œ í¬ë§¤íŒ…
        examples_text = "\n\n".join([
            self._format_example(ex) for ex in examples
        ])
        
        # ì»¨í…ìŠ¤íŠ¸ ì¶”ê°€
        context_text = ""
        if context:
            context_text = f"\n\ní˜„ì¬ í”„ë¡œì íŠ¸ ë§¥ë½:\n{json.dumps(context, ensure_ascii=False, indent=2)}\n"
        
        prompt = f"""{self.role}

ì°¸ê³  ì˜ˆì‹œ:

{examples_text}

---
{context_text}
ì´ì œ ë‹¤ìŒ ì§ˆë¬¸ì— ë‹µí•´ì£¼ì„¸ìš”:

ì§ˆë¬¸: {query}

{self.cot_template}
"""
        return prompt
    
    def _format_example(self, example: Dict) -> str:
        """ì˜ˆì‹œ í¬ë§¤íŒ…"""
        thinking_steps = "\n".join([
            f"{step}: {content}"
            for step, content in example.get('thinking', {}).items()
        ])
        
        answer = example.get('answer', {})
        
        return f"""ì˜ˆì‹œ: {example['query']}

ìƒê° ê³¼ì •:
{thinking_steps}

ë‹µë³€:
{json.dumps(answer, ensure_ascii=False, indent=2)}
"""
    
    def _select_examples(self, query: str, top_k: int = 3) -> list:
        """ì§ˆë¬¸ê³¼ ê´€ë ¨ëœ ì˜ˆì‹œ ì„ íƒ"""
        # ê°„ë‹¨ êµ¬í˜„: í‚¤ì›Œë“œ ë§¤ì¹­
        # í–¥í›„ ê°œì„ : Embedding ê¸°ë°˜ ìœ ì‚¬ë„
        
        scored_examples = []
        for example in self.examples:
            score = self._similarity(query, example['query'])
            scored_examples.append((score, example))
        
        scored_examples.sort(reverse=True, key=lambda x: x[0])
        return [ex for _, ex in scored_examples[:top_k]]
    
    def _similarity(self, q1: str, q2: str) -> float:
        """ê°„ë‹¨í•œ ìœ ì‚¬ë„ (í‚¤ì›Œë“œ ê¸°ë°˜)"""
        # TODO: Embedding ê¸°ë°˜ìœ¼ë¡œ ê°œì„ 
        words1 = set(q1.lower().split())
        words2 = set(q2.lower().split())
        
        intersection = words1 & words2
        union = words1 | words2
        
        return len(intersection) / len(union) if union else 0.0
    
    def _call_gpt4o(self, prompt: str) -> str:
        """GPT-4o API í˜¸ì¶œ"""
        from openai import OpenAI
        
        client = OpenAI()  # .envì—ì„œ ìë™ ë¡œë“œ
        
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "user", "content": prompt}
            ],
            temperature=0.2,  # ë‚®ì€ ì˜¨ë„ (ì¼ê´€ì„±)
            response_format={"type": "json_object"}  # JSON ê°•ì œ
        )
        
        return response.choices[0].message.content
    
    def _parse_response(self, response: str) -> Dict:
        """ì‘ë‹µ íŒŒì‹±"""
        try:
            data = json.loads(response)
            return data.get('answer', {})
        except json.JSONDecodeError:
            # Fallback: í…ìŠ¤íŠ¸ íŒŒì‹±
            return {
                'value': None,
                'confidence': 0.5,
                'error': 'JSON íŒŒì‹± ì‹¤íŒ¨'
            }
    
    def _validate(self, result: Dict, query: str) -> Dict:
        """ê²°ê³¼ ê²€ì¦"""
        # ê¸°ë³¸ ê²€ì¦
        if result.get('value') is None:
            result['warning'] = "ê°’ ì—†ìŒ"
        
        if result.get('value', 0) < 0:
            result['warning'] = "ìŒìˆ˜ ê°’ (ë¹„ì •ìƒ)"
        
        if result.get('confidence', 0) > 0.95 and result.get('phase') == 4:
            result['confidence'] = 0.75  # FermiëŠ” ê³¼ì‹  ë°©ì§€
        
        return result
```

---

## ğŸ“Š ìš”ì•½

### Claude â†’ GPT-4o ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œë“œë§µ

```yaml
Week 1 (í•„ìˆ˜):
  - CoT í”„ë¡¬í”„íŠ¸ í…œí”Œë¦¿
  - Few-shot ì˜ˆì‹œ 10ê°œ
  - êµ¬ì¡°í™”ëœ ì¶œë ¥
  
  íš¨ê³¼: 70-75% í’ˆì§ˆ
  ë¹„ìš©: ë™ì¼
  êµ¬í˜„: ì‰¬ì›€

Week 2 (ê¶Œì¥):
  - ì˜ì‚¬ê²°ì • íŠ¸ë¦¬ (10ê°œ í…œí”Œë¦¿)
  - ìë™ ê²€ì¦ ë ˆì´ì–´
  - Multi-pass ì „ëµ
  
  íš¨ê³¼: 80-85% í’ˆì§ˆ
  ë¹„ìš©: +20-30%
  êµ¬í˜„: ì¤‘ê°„

Week 3-4 (ì„ íƒ):
  - Ensemble
  - Meta-learner
  - Context-aware
  
  íš¨ê³¼: 90% í’ˆì§ˆ
  ë¹„ìš©: +40-50%
  êµ¬í˜„: ë³µì¡

1ê°œì›”+ (ì™„ë²½ì£¼ì˜):
  - Hybrid (GPT + Claude)
  - ì „ë¬¸ê°€ ì‹œìŠ¤í…œ
  
  íš¨ê³¼: 95%+ í’ˆì§ˆ
  ë¹„ìš©: ìµœì í™”
  êµ¬í˜„: ë§¤ìš° ë³µì¡
```

---

**ì‘ì„±ì**: AI Assistant  
**ì‘ì„±ì¼**: 2025-11-18  
**ëŒ€ìƒ**: Claude Sonnet 4.5 â†’ GPT-4o ë§ˆì´ê·¸ë ˆì´ì…˜  
**ëª©í‘œ**: ë™ë“± ì´ìƒ í’ˆì§ˆ, ë¹„ìš© íš¨ìœ¨  

---

*Thinking ëª¨ë¸ì˜ "ë§ˆë²•"ì€ ëª…ì‹œì  êµ¬ì¡°ì™€ ì˜ˆì‹œë¡œ ì¬í˜„ ê°€ëŠ¥í•©ë‹ˆë‹¤!*




