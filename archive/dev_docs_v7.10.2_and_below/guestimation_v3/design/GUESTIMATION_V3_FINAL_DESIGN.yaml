# Guestimation v3.0 최종 설계
# 피드백 반영 및 문제 해결

meta:
  version: "3.0-final"
  date: "2025-11-07"
  status: "design_complete"
  philosophy: "실용적 단순함"

---

# ═══════════════════════════════════════════════════════
# PART 1: 핵심 원칙 (재확인)
# ═══════════════════════════════════════════════════════

core_principles:
  
  원칙_1_물리법칙_엄격_정의:
    
    정의: "근본적 자연 법칙만"
    
    포함:
      - 엔트로피 증가 법칙
      - 광속 한계 (c = 300,000 km/s)
      - 시공간 제약 (동시 다지점 불가)
      - 에너지 보존
      - 질량 보존
    
    제외:
      - 생물학적 경향 ("8시간 집중")
      - 기술적 한계 (현재 인터넷 속도)
      - 사회적 규범 (근로시간)
    
    실용적_변환:
      
      광속_→_이동시간:
        물리: "광속 이상 불가"
        
        실용:
          "서울-샌프란시스코 거리 / 여객기 속도"
          = 9,000km / 900km/h
          = 10시간 (최소)
        
        boundary:
          type: "physical_derived"
          min_travel_time: 10시간
          confidence: 0.99 (날씨 등 변수)
      
      시공간_제약_→_사기_감지:
        물리: "동시 다지점 불가"
        
        실용:
          "서울 12:00 결제 → 부산 12:05 결제"
          
          이동_시간:
            서울-부산: 최소 2.5시간 (KTX)
          
          체크:
            5분 < 2.5시간 → 불가능!
          
          판단: "비정상 (사기/도용)" ✅
        
        활용:
          fraud_detection:
            물리법칙 기반 이상 감지
  
  원칙_2_충돌_시_사용자_질문:
    
    충돌_감지:
      제약_1: "예산 10억"
      제약_2: "고객당 100만원"
      제약_3: "고객 2만명"
      
      모순: 20,000 × 100만 = 200억 > 10억
    
    해결:
      
      사용자_대화:
        시스템: |
          모순을 발견했습니다:
          - 예산: 10억
          - 고객당 투자: 100만원
          - 고객 목표: 2만명
          → 필요 예산: 200억
          
          어떻게 조정할까요?
          1. 예산을 200억으로 수정
          2. 고객 목표를 1만명으로 수정
          3. 고객당 투자를 50만원으로 수정
        
        사용자: "2번, 고객 1만명으로"
        
        해결: ✅
    
    간단! ✅
  
  원칙_3_Soft는_Range_제시:
    
    법률_예시:
      최저임금: 9,860원
      
      Soft_Guide_출력:
        type: "legal_norm"
        
        range: [9860, 15000]  # 최저 ~ 일반적 상한
        
        confidence: 0.90
        
        exceptions:
          - condition: "수습"
            range: [8874, 15000]
          - condition: "특례업종"
            range: [7000, 15000]
      
      활용:
        IF 추정값 < 9,860:
          → 경고: "최저임금 미달 가능성"
          → 재확인
        
        IF 추정값 ∈ [9860, 15000]:
          → 합리적 ✅
    
    역할_명확: Range 제시 및 검증용 ✅
  
  원칙_4_통계_활용_유연화:
    
    통계_패턴_출력:
      
      기본_정보:
        type: "statistical_pattern"
        
        distribution:
          mean: 2500만원
          median: 2000만원
          std_dev: 1000만원
          
          percentiles:
            p10: 1000만원
            p25: 1500만원
            p50: 2000만원
            p75: 3000만원
            p90: 4500만원
        
        confidence: 0.65
      
      활용_방식:
        
        Soft_Guide로_사용:
          suggested_range: [p10, p90] = [1000, 4500]
          
          검증:
            IF value ∈ range:
              → 합리적
            ELSE:
              → 이상치 경고
        
        Value_Source로도_사용:
          IF 다른_Value_없음:
            → median 사용 (2000만원)
            → confidence 0.65
        
        유연_활용: ✅

---

# ═══════════════════════════════════════════════════════
# PART 2: 재설계된 Source 구조
# ═══════════════════════════════════════════════════════

redesigned_sources:
  
  Source_분류_최종:
    
    Type_1_Physical_Constraints:
      
      정의: "근본적 물리 법칙만"
      
      개수: "매우 적음 (Knock-out rules)" ✅
      
      Sources:
        
        1A_시공간_법칙:
          예시:
            - 광속 한계
            - 동시 다지점 불가
            - 시간 단방향 (과거→현재→미래)
          
          실용_변환:
            서울_샌프란시스코_최소_이동:
              거리: 9,000km
              여객기: 900km/h
              최소: 10시간
            
            서울_부산_최소_이동:
              거리: 400km
              KTX: 300km/h
              최소: 1.3시간
          
          출력:
            constraint:
              type: "spacetime"
              min_time: 10시간
              confidence: 0.99
              reasoning: "물리적 거리 / 교통수단 속도"
        
        1B_보존_법칙:
          예시:
            - 에너지 보존
            - 질량 보존
            - 입력 = 출력 + 손실
          
          실용_변환:
            매출_분해:
              매출 = 고객수 × 객단가 × 방문횟수
              
              IF 매출_알려짐 AND 고객수_알려짐:
                → 객단가×방문 <= 매출/고객수
          
          출력:
            constraint:
              type: "conservation"
              relationship: "part <= whole"
              confidence: 1.0
        
        1C_수학적_정의:
          예시:
            - 확률 ∈ [0, 1]
            - 백분율 ∈ [0, 100]
            - 음수 불가 (특정 지표)
          
          출력:
            constraint:
              type: "mathematical"
              range: [0, 1]
              confidence: 1.0
      
      활용_방법:
        
        Knock_out_Check:
          목적: "명백히 불가능한 것 배제"
          
          적용:
            IF value violates physical:
              → 즉시 거부 or 재계산
          
          빈도: 드물지만 치명적 (사기 감지 등)
      
      구현:
        
        물리엔진_활용_가능:
          게임_물리엔진:
            - Unity Physics
            - Unreal Engine Physics
            - Bullet Physics
          
          활용:
            - 거리/속도/시간 계산
            - 충돌 감지
            - 가능성 체크
          
          하지만:
            Guestimation에_과한가?
            → 간단한 공식으로 충분할 듯
        
        API_탐색:
          지리_API:
            - Google Maps Distance Matrix
            - OpenStreetMap
            → 최소 이동시간 계산
          
          물리_계산_API:
            - Wolfram Alpha
            → 복잡한 물리 계산
          
          실용성: 제한적 (비용, 복잡도)
        
        권장_구현:
          간단한_공식_라이브러리:
            - 거리/속도/시간
            - 기본 보존 법칙
            - 수학 정의
            
            코드: 100-200줄
            
            충분함! ✅
    
    Type_2_Soft_Constraints:
      
      정의: "경향성, 범위 제시용"
      
      Sources:
        
        2A_법률_규범:
          
          출력_형식:
            constraint:
              type: "legal_norm"
              
              base_rule:
                value: 9860원
                range: [9860, ∞]
              
              exceptions:
                - condition: "수습"
                  multiplier: 0.90
                  range: [8874, ∞]
                
                - condition: "장애인"
                  note: "감액 가능, 개별 협의"
              
              typical_range: [9860, 15000]
              
              confidence: 0.90
              applicability: "한국, 2024년, 정규직"
          
          활용:
            range_제시:
              - 기본: [9860, 15000]
              - 맥락에 따라 조정
            
            검증:
              IF value < 9860:
                → 경고 (예외 확인)
              
              IF value > 15000:
                → 이상치 가능성 (재확인)
        
        2B_행동경제학:
          
          문제_해결:
            정량화_어려움:
              - Loss Aversion → 숫자로?
              - Hyperbolic Discounting → 범위로?
            
            해결:
              정성적_설명만:
                output:
                  type: "behavioral_insight"
                  
                  pattern: "Loss Aversion"
                  
                  implication: |
                    - 가격 인상 시 Churn 증가 예상
                    - 손실 민감도 높음
                    - 보수적 추정 권장
                  
                  quantitative_hint:
                    direction: "upward"
                    magnitude: "moderate to high"
                  
                  confidence: 0.60
              
              활용:
                값_조정_아님:
                  - 정량적 사용 안 함
                
                해석_보조:
                  - "Churn이 높을 수 있음" (정성적)
                  - 다른 증거 해석 시 참고
                  - 불확실성 설명
              
              실용성: 제한적 (하지만 통찰 제공)
        
        2C_통계_패턴:
          
          출력_형식:
            pattern:
              type: "statistical"
              
              distribution:
                type: "normal | power_law | bimodal"
                
                central_tendency:
                  mean: 2500만원
                  median: 2000만원
                  mode: 1800만원
                
                dispersion:
                  std_dev: 1000만원
                  iqr: [1500, 3000]
                  range: [500, 5000]
                
                percentiles:
                  p10: 1000
                  p25: 1500
                  p50: 2000
                  p75: 3000
                  p90: 4500
              
              confidence: 0.65
              sample_size: 500
              data_year: 2024
          
          활용_방식:
            
            Soft_Guide로:
              suggested_range: [p10, p90]
                             = [1000, 4500]
              
              검증:
                IF value ∈ [1000, 4500]:
                  → 정상 범위
                ELSE:
                  → 이상치 (재확인)
            
            Value_Source로:
              조건: "다른 Value 없거나 적음"
              
              선택_기준:
                IF intent == "make_decision":
                  → p25 (보수적)
                
                IF intent == "understand_market":
                  → median
                
                IF distribution == "power_law":
                  → median (평균 부적합)
              
              confidence: 0.65 (낮음, 다른 증거 우선)
            
            유연_활용: ✅
    
    Type_3_Value_Sources:
      
      Sources:
        
        3A_확정_데이터:
          신뢰도: 0.95-1.0 (완전 확정 드묾)
        
        3B_LLM_추정:
          신뢰도: 0.60-0.90 (맥락 의존)
        
        3C_웹_검색:
          신뢰도: 0.70 (시의성 높음)
        
        3D_RAG_벤치마크:
          신뢰도: 0.50-0.80 (유사도)
        
        3E_통계_패턴:
          신뢰도: 0.65 (분산 고려)
          조건: "다른 Value 없을 때만" ⭐

---

# ═══════════════════════════════════════════════════════
# PART 3: 충돌 해결 프로토콜
# ═══════════════════════════════════════════════════════

conflict_resolution:
  
  충돌_유형_3가지:
    
    유형_1_제약끼리_충돌:
      
      예시:
        제약_A: "예산 10억"
        제약_B: "고객당 100만원"
        제약_C: "고객 2만명"
        
        모순: 20,000 × 100만 = 200억 > 10억
      
      해결:
        
        단계_1_감지:
          자동_논리_체크:
            - 제약들의 관계 파악
            - 수식 생성
            - 모순 계산
        
        단계_2_사용자_질문:
          메시지: |
            모순 발견:
            - 예산 10억
            - 고객당 100만원 × 2만명 = 200억 필요
            
            조정 방법:
            1. 예산 증액 (10억 → 200억)
            2. 고객 축소 (2만 → 1만명)
            3. 투자 감소 (100만 → 50만원)
          
          입력: 사용자 선택
        
        단계_3_재계산:
          선택_반영하여_다시_추정
      
      간단_명확! ✅
    
    유형_2_제약_vs_추정값_충돌:
      
      예시:
        Hard: "최소 197만원" (최저임금 × 200h)
        Value (웹): "평균 180만원"
        
        충돌: 180 < 197
      
      해결:
        
        단계_1_재확인:
          웹_데이터_재검토:
            - 다른 웹 소스 확인
            - 180만원 정말 맞나?
        
        단계_2_예외_체크:
          최저임금_예외:
            - 수습인가?
            - 특례인가?
            - 미준수 사례인가?
        
        단계_3_판단:
          
          IF 예외_해당:
            → 180만원 가능 ✅
          
          ELSE IF 웹_신뢰도_낮음:
            → Hard 우선 (197만원)
          
          ELSE:
            → 사용자_질문:
                "최저임금 미달 데이터 발견
                 1. 197만원 사용 (법정 기준)
                 2. 180만원 사용 (실제 평균)
                 3. 범위 제시 (180~197)"
    
    유형_3_Value끼리_불일치:
      
      예시:
        LLM: 11.5시간 (0.75)
        웹: 12시간 (0.70)
        RAG: 11시간 (0.65)
        
        차이: 작음 (±10%)
      
      해결:
        가중_평균: (현재 설계대로) ✅
      
      예시_2:
        LLM: 2,000만원 (0.70, 2023 데이터)
        웹: 5,000만원 (0.70, 2024 최신)
        
        차이: 큼! (150%)
      
      해결:
        
        시의성_고려:
          LLM_confidence_조정:
            기본: 0.70
            시의성_페널티: ×0.3 (1년 오래됨)
            최종: 0.21
          
          웹_confidence:
            기본: 0.70
            시의성: ×1.0 (최신)
            최종: 0.70
          
          가중치:
            LLM: 0.21 (낮음)
            웹: 0.70 (높음)
            
            웹_우선! ✅

---

# ═══════════════════════════════════════════════════════
# PART 4: 물리법칙 구현 방안
# ═══════════════════════════════════════════════════════

physical_law_implementation:
  
  구현_옵션:
    
    옵션_A_공식_라이브러리:
      
      내용:
        간단한_물리_공식들:
          - 거리/속도/시간
          - 기본 보존 법칙
          - 수학적 정의
        
        코드: 100-200줄
      
      예시:
        def check_travel_time(distance_km, speed_kmh):
          min_time = distance_km / speed_kmh
          return {"min": min_time, "confidence": 0.99}
        
        def check_probability(value):
          if 0 <= value <= 1:
            return {"valid": True}
          else:
            return {"valid": False, "reason": "확률 범위 위반"}
      
      장점:
        ✅ 간단
        ✅ 빠름
        ✅ 비용 없음
      
      단점:
        ❌ 제한적 (기본만)
    
    옵션_B_물리엔진:
      
      내용:
        - Unity Physics API
        - 물리 시뮬레이션
      
      활용:
        복잡한_물리_계산:
          - 충돌 감지
          - 경로 최적화
      
      장점:
        ✅ 강력함
      
      단점:
        ❌ 과한 복잡도
        ❌ Guestimation에 불필요
    
    옵션_C_외부_API:
      
      Google_Maps_Distance:
        활용: "서울-부산 최소 이동시간"
        비용: 유료
      
      Wolfram_Alpha:
        활용: "복잡한 물리 계산"
        비용: 유료
      
      장점:
        ✅ 정확함
      
      단점:
        ❌ 비용
        ❌ 의존성
    
    옵션_D_LLM_판단:
      
      방법:
        prompt: |
          물리법칙 기반 판단:
          
          "서울 12시 결제, 부산 12시 5분 결제"
          
          가능한가? 최소 이동시간은?
        
        LLM: "불가능, 최소 2.5시간 필요"
      
      장점:
        ✅ 유연함
        ✅ 구현 단순
      
      단점:
        ❌ 신뢰도 (99% → 95%)
        ❌ 비용 (Native는 $0)
    
    권장: "옵션_A (공식) + 옵션_D (LLM 보조)" ✅
      
      이유:
        - 기본 케이스: 공식 (빠름, 확실)
        - 복잡한 케이스: LLM (유연)
        - 비용 최소
        - 실용적

---

# ═══════════════════════════════════════════════════════
# PART 5: 통계 패턴 다양한 케이스
# ═══════════════════════════════════════════════════════

statistical_pattern_cases:
  
  Case_1_분산_작음:
    
    데이터:
      "SaaS Churn Rate"
      
      분포:
        mean: 6%
        std_dev: 1%
        range: [5%, 7%]
      
      분산: 작음 (CV = 1/6 = 17%)
    
    활용:
      
      Soft_Guide:
        range: [5%, 7%] (좁음!)
        confidence: 0.80 (높음)
      
      Value_Source:
        IF 다른_Value_없음:
          → mean 6% 사용
          → confidence 0.80
        
        ELSE:
          → Soft로만 (검증용)
    
    판단:
      분산_작으면:
        - Value로도 충분히 활용 가능
        - 신뢰도 높임
  
  Case_2_분산_큼:
    
    데이터:
      "음식점 월매출"
      
      분포:
        mean: 2500만원
        std_dev: 1500만원
        range: [500, 8000]
      
      분산: 큼 (CV = 1500/2500 = 60%)
    
    활용:
      
      Soft_Guide:
        range: [p10, p90] = [1000, 4500]
        confidence: 0.60
      
      Value_Source:
        사용_자제:
          - 분산 너무 큼
          - 대표성 낮음
          - median도 신뢰도 0.50
        
        IF 정말_없으면:
          → median 2000만원
          → confidence 0.50 (매우 낮음)
          → range [1000, 3000] 병행 제시
    
    판단:
      분산_크면:
        - Soft로만 (범위 제시)
        - Value 사용 자제
  
  Case_3_분포_복잡:
    
    데이터:
      "프리랜서 시급"
      
      분포:
        type: "bimodal" (이봉 분포)
        
        peak_1: 15,000원 (초급)
        peak_2: 50,000원 (고급)
        
        mean: 30,000원 (의미 없음!)
    
    활용:
      
      Soft_Guide:
        ranges:
          초급: [10000, 20000]
          고급: [40000, 80000]
        
        note: "세분화 필요"
      
      Value_Source:
        사용_불가:
          - mean 의미 없음
          - 세분화 없이 추정 불가
        
        대응:
          사용자_질문:
            "초급인가요, 고급인가요?"
          
          세분화_후_재추정
    
    판단:
      복잡한_분포:
        - Soft로 "세분화 필요" 신호
        - Value 사용 안 함
        - 맥락 추가 필요
  
  Case_4_데이터_풍부:
    
    데이터:
      "한국 인구"
      
      출처:
        통계청: 51,740,000명 (2024)
        
        분산: 거의 없음
        신뢰도: 0.95
    
    활용:
      
      Soft_Guide:
        필요_없음:
          - 확정값 있음
          - range 의미 없음
      
      Value_Source:
        직접_사용:
          value: 51,740,000
          confidence: 0.95
        
        Soft_불필요!
    
    판단:
      확정값_있으면:
        - Soft 생략
        - Value만
  
  종합_전략:
    
    결정_기준:
      
      통계_패턴_역할:
        
        IF 분산_작음 (<20%):
          → Soft + Value 둘 다
          → Value confidence 높임 (0.75-0.80)
        
        IF 분산_중간 (20-50%):
          → Soft (range)
          → Value (다른 것 없을 때만, confidence 0.60)
        
        IF 분산_큼 (>50%):
          → Soft만 (range)
          → Value 사용 자제
        
        IF 분포_복잡 (bimodal 등):
          → Soft ("세분화 필요" 신호)
          → Value 불가
        
        IF 확정값_있음:
          → Soft 생략
          → Value만
      
      유연_활용: ✅

---

# ═══════════════════════════════════════════════════════
# PART 6: 최종 Source 구조
# ═══════════════════════════════════════════════════════

final_source_structure:
  
  Source_리스트:
    
    Physical_Constraints:
      개수: 3개
      
      1. 시공간 법칙 (거리/시간)
      2. 보존 법칙 (입력=출력)
      3. 수학 정의 (확률 [0,1])
      
      역할: Knock-out (드물지만 치명적)
      
      구현: 공식 라이브러리 + LLM 보조
    
    Soft_Constraints:
      개수: 3개
      
      4. 법률/규범 (range + 예외)
      5. 행동경제학 (정성적 통찰)
      6. 통계 패턴 (분산 고려, 유연 활용)
      
      역할: Range 제시, 검증, 해석 보조
    
    Value_Sources:
      개수: 5개
      
      7. 확정 데이터 (0.95-1.0)
      8. LLM 추정 (0.60-0.90, 시의성 고려)
      9. 웹 검색 (0.70, 최신)
      10. RAG 벤치마크 (0.50-0.80)
      11. 통계 패턴 (0.50-0.65, 조건부) ⭐
      
      역할: 값 결정
    
    총: 11개 (통계가 Soft + Value 겸용)
  
  적용_흐름:
    
    순서:
      
      1_Physical_Check:
        목적: "명백히 불가능한 것 배제"
        
        실행:
          - 모든 Physical 수집
          - 교집합 계산
          - final_boundary
        
        결과:
          물리적_가능_범위: [0, 24] (예시)
      
      2_Value_Collection:
        목적: "가능 범위 내에서 값 수집"
        
        실행:
          - 확정 데이터 체크
          - LLM/웹/RAG 병렬 수집
          - boundary 힌트 전달
        
        결과:
          value_candidates: [
            {source: "llm", value: 11.5, conf: 0.75},
            {source: "web", value: 12, conf: 0.70}
          ]
      
      3_Soft_Validation:
        목적: "합리성 검증"
        
        실행:
          - 법률 range 체크
          - 통계 range 체크
          - 이상치 감지
        
        결과:
          모든_값_합리적: ✅
          OR
          경고: "범위 초과"
      
      4_Conflict_Resolution:
        목적: "충돌 해결"
        
        실행:
          - Physical 위반? → 거부 or 재계산
          - Soft 위반? → 경고 + 재확인
          - Value 불일치? → 가중 평균
        
        필요_시:
          → 사용자 질문
      
      5_Final_Judgment:
        목적: "최종 값 결정"
        
        실행:
          - 전략 선택
          - 가중 평균 or ...
          - Boundary 최종 체크
        
        결과:
          final_value: 11.4시간
          range: [11, 12]
          confidence: 0.73

---

# ═══════════════════════════════════════════════════════
# PART 7: 개선된 출력 형식
# ═══════════════════════════════════════════════════════

improved_output_format:
  
  모든_Source_통일_형식:
    
    Source_Output:
      
      source_id: "PHY-TIME-001"
      source_type: "physical | soft | value"
      source_name: "spacetime_constraint"
      
      role: "boundary | range | value | insight"
      
      output:
        
        IF role == "boundary":
          boundary:
            min: 0
            max: 24
            unit: "시간/일"
        
        IF role == "range":
          range:
            recommended: [8, 14]
            percentiles: {p10: 6, p90: 16}
        
        IF role == "value":
          value: 11.5
          uncertainty: 0.15
        
        IF role == "insight":
          insight: "Loss Aversion 고려 시 Churn 높을 수 있음"
          quantitative: null
      
      confidence: 0.0 ~ 1.0
      
      conditions:
        - "IF 한국"
        - "IF 2024년"
      
      exceptions:
        - {condition: "수습", modifier: 0.90}
      
      metadata:
        data_year: 2024
        sample_size: 500
        source_detail: "통계청"
  
  유연성:
    
    같은_정보_다중_역할:
      
      통계_패턴_출력:
        source_id: "STAT-FOOD-001"
        
        outputs:
          - role: "range"
            range: [1000, 4500]
            confidence: 0.65
          
          - role: "value"
            value: 2000 (median)
            confidence: 0.50
            use_condition: "다른 Value 없을 때만"
      
      활용:
        상황에_따라_선택:
          - Soft 필요 → range 사용
          - Value 필요 → value 사용

---

# ═══════════════════════════════════════════════════════
# PART 8: Edge Cases 해결 요약
# ═══════════════════════════════════════════════════════

edge_case_solutions:
  
  해결_1_물리법칙_엄격_정의:
    ✅ 근본 법칙만 (엔트로피, 광속, 시공간)
    ✅ 실용 변환 (이동시간, 사기감지)
    ✅ 구현: 공식 + LLM
  
  해결_2_충돌_사용자_질문:
    ✅ 모순 감지 → 자동
    ✅ 해결: 사용자 대화
    ✅ 간단 명확
  
  해결_3_법률_Range_제시:
    ✅ Soft Guide 활용
    ✅ 예외 명시
    ✅ 검증용
  
  해결_4_통계_유연_활용:
    ✅ 분산 고려
    ✅ Soft + Value 겸용 (조건부)
    ✅ 맥락 기반 선택
  
  해결_5_행동경제학_정성적:
    ✅ 정량화 포기
    ✅ 통찰 제공 (해석 보조)
    ✅ 실용성 인정

---

# ═══════════════════════════════════════════════════════
# PART 9: 최종 설계 (완성)
# ═══════════════════════════════════════════════════════

final_design_summary:
  
  Source_11개:
    
    Physical: 3개 (Knock-out)
    Soft: 3개 (Range + Insight)
    Value: 5개 (값 결정)
  
  적용_순서:
    1. Physical → boundary
    2. Value → 후보들
    3. Soft → 검증
    4. Conflict → 해결
    5. Final → 판단
  
  유연성:
    - 신뢰도 표시
    - 조건/예외 명시
    - 다중 역할 허용 (통계)
    - 충돌 처리
  
  실용성:
    - 간단한 구현 (공식 + LLM)
    - 사용자 대화 (충돌 시)
    - 맥락 고려
  
  완성도: 높음 ✅

---

# ═══════════════════════════════════════════════════════
# END - 최종 설계 완료
# ═══════════════════════════════════════════════════════

