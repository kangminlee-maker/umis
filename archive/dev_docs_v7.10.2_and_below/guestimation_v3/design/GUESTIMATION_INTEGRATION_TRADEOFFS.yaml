# Guestimation RAG Integration - Tradeoffs Analysis
# Canonical-Projected 통합 방식의 단점 분석

meta:
  version: "1.0"
  date: "2025-11-07"
  purpose: "통합 방식의 단점을 정직하게 분석하여 informed decision"

---

# ═══════════════════════════════════════════════════════
# PART 1: 정확한 상황 이해
# ═══════════════════════════════════════════════════════

clarification:
  
  Collection_수:
    Before: 13개
    After: 13개 (그대로)
    
    설명:
      - Collection 이름은 안 늘어남
      - 하지만 projected_index 안에 청크 증가
  
  청크_수:
    
    projected_index_현재:
      explorer: ~354개
      quantifier: ~130개
      validator: ~134개
      observer: ~80개
      총: ~700개
    
    projected_index_통합_후:
      기존: ~700개
      guestimation: 0 → 2,000개 (Year 1)
      총: ~2,700개 (3.8배 증가!)
    
    canonical_index:
      현재: ~100개
      통합_후: ~100개 + 0→500개 (학습 규칙)
      총: ~600개 (6배 증가!)
  
  실질적_영향:
    - Collection 수: 변화 없음
    - DB 크기: 3-6배 증가
    - 검색 대상: filter로 격리되므로 영향 적음

---

# ═══════════════════════════════════════════════════════
# PART 2: 단점 분석
# ═══════════════════════════════════════════════════════

disadvantages:
  
  단점_1_Canonical_스키마_복잡도:
    
    문제:
      현재_Canonical:
        필드:
          - chunk_id
          - chunk_type: "business_model_pattern | success_case"
          - content
          - sections: [observer, explorer, ...]
          - metadata: 20개 필드
      
      통합_후:
        필드:
          - chunk_type: +1개 ("learned_estimation_rule")
          - sections: +1개 ("guestimation")
          - metadata: +10개 필드 (guestimation 전용)
        
        복잡도: +30%
    
    영향:
      
      스키마_관리:
        - schema_registry.yaml 복잡해짐
        - 새 필드 이해 필요
        - 문서화 증가
      
      검증_로직:
        - Contract Tests 확장 필요
        - 검증 규칙 추가
      
      개발자_학습_곡선:
        - 새 필드 이해 시간 +1-2일
    
    완화_방법:
      
      네임스페이스_분리:
        모든_guestimation_필드:
          prefix: "guestimation_"
          
          예:
            - guestimation_question
            - guestimation_metric
            - guestimation_value
        
        효과:
          - 명확한 구분
          - 다른 Agent 혼동 없음
      
      선택적_필드:
        required: false
        
        기존_청크:
          - guestimation 필드 없어도 OK
        
        새_청크:
          - guestimation 필드 있음
  
  단점_2_Projected_Index_크기_증가:
    
    문제:
      
      현재:
        projected_index: ~700개 청크
        크기: ~50MB (청크 + 임베딩)
      
      Year_1_예상:
        projected_index: ~2,700개 청크
        크기: ~200MB
        
        증가: 4배!
    
    영향:
      
      메모리_사용:
        ChromaDB_메모리:
          현재: ~100MB
          예상: ~400MB
        
        영향:
          - 로컬 개발: 무시 가능
          - 프로덕션: 메모리 증가
      
      검색_성능:
        
        이론:
          ChromaDB는 청크 수에 비례하여 느려짐
          700개: ~0.1초
          2,700개: ~0.2-0.3초?
        
        실제:
          Filter 사용:
            filter={"agent_view": "guestimation"}
            → guestimation 청크만 검색 (2,000개)
            → 다른 Agent 청크 무시
          
          영향:
            - guestimation: 0.2-0.3초 (느려짐)
            - 다른 Agent: 변화 없음 (filter)
        
        평가:
          Tier_1_목표: <0.5초
          예상: 0.2-0.3초
          여유: 충분! ✅
      
      디스크_사용:
        현재: ~100MB
        예상: ~400MB
        증가: +300MB
        
        평가: 무시 가능 (현대 시스템)
    
    완화_방법:
      
      청크_크기_최적화:
        - page_content 간결하게
        - 메타데이터만 검색용
        - 상세 내용은 별도 저장
      
      주기적_정리:
        - 6개월 미사용 규칙 제거
        - 아카이브 이동
        - active 규칙만 유지
  
  단점_3_기존_Agent_영향_가능성:
    
    문제:
      
      Canonical_변경:
        - 새 필드 추가
        - 새 chunk_type 추가
      
      영향_가능성:
        - 기존 Agent가 새 필드 읽으려 시도?
        - 스키마 검증 실패?
        - Projection 로직 깨짐?
    
    실제_영향:
      
      Explorer:
        검색: filter={"agent_view": "explorer"}
        → guestimation 청크 무시
        영향: 없음 ✅
      
      Quantifier:
        검색: filter={"agent_view": "quantifier"}
        → guestimation 청크 무시
        영향: 없음 ✅
      
      Projection_Rules:
        guestimation_필드:
          agents: [guestimation]
          → 다른 Agent Projection 안 됨
        
        영향: 없음 ✅
    
    리스크:
      
      높음:
        - 스키마 검증 로직이 엄격하면
        - 새 필드 거부 가능성
      
      낮음:
        - 선택적 필드 (required: false)
        - 네임스페이스 분리 (guestimation_)
    
    완화:
      - Contract Tests 업데이트
      - 하위 호환성 보장
      - 점진적 배포
  
  단점_4_Projection_Rules_복잡도:
    
    문제:
      
      현재_Projection_Rules:
        field_rules: 30개 규칙
        복잡도: 중간
      
      Guestimation_추가:
        field_rules: +10개 규칙
        복잡도: +33%
    
    영향:
      
      개발자_이해:
        - projection_rules.yaml 이해 시간 증가
        - 디버깅 복잡
      
      LLM_판단_빈도:
        - 새 필드 → LLM 판단 증가
        - 비용 약간 증가
        - 학습 후 감소 (10% → 1%)
    
    완화:
      
      문서화:
        - Guestimation 전용 섹션
        - 예시 풍부하게
      
      자동_학습:
        - LLM 판단 빠르게 규칙화
        - 복잡도 자동 감소
  
  단점_5_마이그레이션_리스크:
    
    문제:
      
      기존_시스템_수정:
        - Canonical 스키마 변경
        - Projection Rules 변경
        - 기존 Agent 테스트 필요
      
      리스크:
        - 기존 기능 깨질 수 있음
        - 롤백 어려움
        - 테스트 범위 넓음
    
    완화:
      
      점진적_배포:
        1. 스키마만 추가 (기존 데이터 유지)
        2. Guestimation 데이터 추가 (기존 Agent 무시)
        3. 통합 테스트
        4. 프로덕션 배포
      
      Feature_Flag:
        config:
          guestimation:
            enabled: false  # 초기
        
        단계적_활성화:
          Week 1: enabled=false (개발만)
          Week 2: enabled=true (테스트)
          Week 3: enabled=true (프로덕션)
      
      롤백_계획:
        IF 문제_발생:
          1. enabled=false
          2. guestimation 필드 무시
          3. 기존 시스템 정상 작동
  
  단점_6_데이터_혼재:
    
    문제:
      
      Canonical_안에:
        - 비즈니스 패턴 (정적)
        - 성공 사례 (정적)
        - 학습된 규칙 (동적) ⭐
        - 사용자 기여 (동적) ⭐
      
      성격_다름:
        정적: 전문가 큐레이션, 드물게 업데이트
        동적: 자동 생성, 자주 업데이트
      
      혼란_가능성:
        - "이 청크는 어디서 왔나?"
        - "왜 자주 변경되나?"
    
    영향:
      
      관리:
        - 정적/동적 구분 필요
        - 업데이트 정책 다름
      
      품질_관리:
        - 정적: 전문가 검증
        - 동적: 자동 검증
        - 기준 다름
    
    완화:
      
      chunk_type_구분:
        정적:
          - "business_model_pattern"
          - "success_case"
        
        동적:
          - "learned_estimation_rule" ⭐
          - "user_contributed_fact" (선택)
      
      metadata_표시:
        provenance:
          data_type: "static | dynamic"
          source_type: "expert_curated | system_learned | user_contributed"
          update_frequency: "rarely | automatically"
      
      관리_분리:
        정적:
          - YAML 파일에서 관리
          - 수작업 검증
        
        동적:
          - 시스템 자동 추가
          - 자동 검증
          - 별도 정책

---

# ═══════════════════════════════════════════════════════
# PART 3: 성능 영향 분석
# ═══════════════════════════════════════════════════════

performance_impact:
  
  검색_성능:
    
    시나리오_A_Explorer_검색:
      
      Before:
        projected_index: 700개
        filter: {"agent_view": "explorer"}
        검색_대상: 354개
        시간: 0.1초
      
      After:
        projected_index: 2,700개
        filter: {"agent_view": "explorer"}
        검색_대상: 354개 (동일!) ✅
        시간: 0.1초 (동일!)
      
      영향: 없음!
      이유: filter 덕분
    
    시나리오_B_Guestimation_검색:
      
      Year_1:
        projected_index: 2,700개
        filter: {"agent_view": "guestimation"}
        검색_대상: 2,000개
        시간: 0.2-0.3초
      
      평가:
        목표: <0.5초 (Tier 1)
        실제: 0.2-0.3초
        여유: 충분 ✅
    
    시나리오_C_Filter_없는_검색:
      
      Before:
        전체_검색: 700개 대상
        시간: 0.15초
      
      After:
        전체_검색: 2,700개 대상
        시간: 0.3-0.5초 (느려짐!)
      
      영향:
        IF filter_사용:
          → 영향 없음 ✅
        
        IF filter_미사용:
          → 2-3배 느려짐 ❌
      
      완화:
        - filter 필수 사용
        - API 설계 시 강제
  
  메모리_사용:
    
    ChromaDB_메모리:
      
      현재:
        청크: 700개 × 2KB = 1.4MB
        임베딩: 700개 × 12KB = 8.4MB
        인덱스: ~20MB
        총: ~30MB
      
      Year_1:
        청크: 2,700개 × 2KB = 5.4MB
        임베딩: 2,700개 × 12KB = 32.4MB
        인덱스: ~80MB
        총: ~120MB
      
      증가: +90MB
      
      평가:
        현대_시스템: 무시 가능 ✅
        제약_환경: 고려 필요
    
    완화:
      - 오래된 규칙 아카이브
      - 압축 옵션
      - 필요 시 디스크 페이징
  
  디스크_사용:
    
    Canonical:
      현재: ~10MB
      Year_1: ~50MB
      증가: +40MB
    
    Projected:
      현재: ~30MB
      Year_1: ~120MB
      증가: +90MB
    
    총_증가: +130MB
    
    평가: 완전 무시 가능 ✅

---

# ═══════════════════════════════════════════════════════
# PART 4: 복잡도 증가
# ═══════════════════════════════════════════════════════

complexity_increase:
  
  코드_복잡도:
    
    수정_필요_파일:
      
      config/schema_registry.yaml:
        변경: "필드 정의 추가"
        줄_수: +50줄
        난이도: "낮음"
      
      config/projection_rules.yaml:
        변경: "guestimation 규칙 추가"
        줄_수: +100줄
        난이도: "중간"
      
      scripts/build_canonical_index.py:
        변경: "새 chunk_type 처리"
        줄_수: +30줄
        난이도: "낮음"
      
      scripts/build_projected_index.py:
        변경: "guestimation view 생성"
        줄_수: +50줄
        난이도: "중간"
      
      테스트:
        신규: "guestimation 통합 테스트"
        줄_수: +200줄
        난이도: "중간"
    
    총_코드_증가: ~430줄
    
    vs_별도_Collection: ~300줄
    
    차이: +130줄 (43% 증가)
  
  개념_복잡도:
    
    Before:
      개념:
        - Canonical: 패턴/사례 저장
        - Projected: Agent 뷰
        - 명확!
      
      개발자_이해:
        - "Canonical에 패턴 추가"
        - "Projected에서 검색"
        - 단순!
    
    After:
      개념:
        - Canonical: 패턴/사례 + 학습 규칙 ⭐
        - Projected: Agent 뷰 + Guestimation 뷰 ⭐
      
      개발자_이해:
        - "패턴과 학습 규칙 차이는?"
        - "왜 Canonical에 추정 결과를?"
        - 설명 필요!
      
      혼란_가능성: 중간
    
    완화:
      
      문서화:
        - 명확한 구분 설명
        - 용도별 가이드
        - 예시 풍부
      
      네이밍:
        - chunk_type 명확히
        - "learned_estimation_rule"
        - "pattern_based_data"
  
  유지보수_복잡도:
    
    Before:
      관리_포인트:
        1. Canonical (패턴/사례 업데이트)
        2. Projection Rules (드물게)
      
      업데이트_빈도:
        - Canonical: 월 1회
        - Rules: 분기 1회
    
    After:
      관리_포인트:
        1. Canonical (패턴/사례 + 학습 규칙) ⭐
        2. Projection Rules (Guestimation 포함)
        3. 학습 규칙 검증 ⭐
        4. 사용자 기여 검증 ⭐
      
      업데이트_빈도:
        - 정적 데이터: 월 1회
        - 학습 규칙: 실시간 ⭐
        - 사용자 기여: 실시간 ⭐
      
      복잡도: +100%
    
    완화:
      
      자동화:
        - 학습 규칙 자동 추가
        - 검증 자동화
        - 정리 자동화
      
      모니터링:
        - 규칙 추가 알림
        - 품질 자동 체크
        - 이상 감지

---

# ═══════════════════════════════════════════════════════
# PART 5: 리스크 분석
# ═══════════════════════════════════════════════════════

risks:
  
  리스크_1_기존_기능_영향:
    
    확률: "중간"
    
    시나리오:
      - Canonical 스키마 변경
      - 기존 Agent 읽기 실패
      - Explorer 검색 깨짐
    
    완화:
      - 하위 호환성 테스트
      - 선택적 필드 (required: false)
      - 점진적 배포
    
    잔여_리스크: "낮음"
  
  리스크_2_성능_저하:
    
    확률: "낮음"
    
    시나리오:
      - Projected Index 커짐 (2,700개)
      - 검색 느려짐
      - Tier 1 목표 달성 실패
    
    분석:
      - Filter 사용 시: 영향 없음
      - Filter 없으면: 2-3배 느림
    
    완화:
      - Filter 필수화
      - 성능 모니터링
      - 임계값 초과 시 최적화
    
    잔여_리스크: "매우 낮음"
  
  리스크_3_데이터_품질:
    
    확률: "중간"
    
    시나리오:
      - 학습 규칙 자동 추가
      - 품질 낮은 규칙 혼입
      - Tier 1 정확도 하락
    
    완화:
      - 엄격한 편입 기준 (confidence >0.85)
      - 자동 검증
      - 주기적 재검증
    
    잔여_리스크: "낮음"
  
  리스크_4_스키마_충돌:
    
    확률: "낮음"
    
    시나리오:
      - 다른 Agent도 비슷한 필드 추가 원함
      - 필드명 충돌
      - 스키마 혼란
    
    완화:
      - 네임스페이스 (guestimation_)
      - 스키마 거버넌스
      - 필드 등록 제도
    
    잔여_리스크: "매우 낮음"

---

# ═══════════════════════════════════════════════════════
# PART 6: 별도 Collection과 최종 비교
# ═══════════════════════════════════════════════════════

final_comparison:
  
  종합_평가:
    
    방식_A_별도_Collection:
      
      장점:
        ✅ 독립성 (영향 없음)
        ✅ 빠른 구현 (2-3일)
        ✅ 리스크 낮음
      
      단점:
        ❌ Collection +1개
        ❌ 아키텍처 불일치
        ❌ 데이터 중복 가능
        ❌ 장기 유지보수 복잡
      
      점수:
        독립성: 10/10
        일관성: 4/10 ⭐ 치명적
        구현: 8/10
        유지보수: 6/10
    
    방식_B_Canonical_Projected_통합:
      
      장점:
        ✅ 아키텍처 일관성 (핵심!)
        ✅ 중복 없음
        ✅ 메커니즘 재사용
        ✅ 장기 유지보수 쉬움
      
      단점:
        ❌ 스키마 복잡도 +30%
        ❌ 기존 시스템 수정 (리스크)
        ❌ 구현 +1일
        ❌ Projected Index 크기 4배
      
      점수:
        독립성: 6/10
        일관성: 10/10 ⭐ 핵심
        구현: 7/10
        유지보수: 9/10
  
  정량_비교:
    
    구현_시간:
      A: 2-3일
      B: 3-4일
      차이: +1일 (25%)
    
    코드_증가:
      A: 300줄
      B: 430줄
      차이: +130줄 (43%)
    
    리스크:
      A: 낮음 (독립)
      B: 중간 (통합, 하지만 완화 가능)
    
    장기_비용:
      A: 높음 (관리 포인트 많음)
      B: 낮음 (통합 관리)
  
  의사결정_매트릭스:
    
    단기_관점:
      - 빠른 구현 필요
      - 리스크 회피
      → 방식_A 유리
    
    장기_관점:
      - 아키텍처 일관성
      - 유지보수성
      - 확장성
      → 방식_B 유리 ⭐
    
    UMIS_철학:
      - 품질 > 속도
      - 일관성 > 편의성
      - 장기 > 단기
      → 방식_B 선택! ✅

---

# ═══════════════════════════════════════════════════════
# PART 7: 감수 가능한 단점
# ═══════════════════════════════════════════════════════

acceptable_tradeoffs:
  
  감수_가능:
    
    1_구현_시간_+1일:
      단점: "3일 → 4일"
      완화: "충분한 테스트로 품질 보장"
      가치: "장기 유지보수 ↓↓"
      판단: ✅ 감수 가능
    
    2_스키마_복잡도_+30%:
      단점: "필드 30% 증가"
      완화: "네임스페이스 분리, 문서화"
      가치: "통합 관리, 중복 없음"
      판단: ✅ 감수 가능
    
    3_코드_+130줄:
      단점: "430줄 vs 300줄"
      완화: "재사용 가능한 코드"
      가치: "아키텍처 일관성"
      판단: ✅ 감수 가능
    
    4_마이그레이션_리스크:
      단점: "기존 시스템 수정"
      완화: "점진적 배포, Feature Flag, 롤백 계획"
      가치: "장기적 안정성"
      판단: ✅ 감수 가능 (완화 강력)
  
  감수_어려움:
    
    5_Projected_크기_4배:
      단점: "700개 → 2,700개"
      완화: "필터 사용, 정리 자동화"
      
      평가:
        검색_성능: 영향 없음 (filter)
        메모리: +90MB (무시 가능)
        디스크: +130MB (무시 가능)
      
      판단: ⚠️ 모니터링 필요
      
      대응:
        IF 성능_저하_발생:
          → Collection 분리 고려
          → 하지만 가능성 낮음
    
    6_개념_복잡도:
      단점: "정적/동적 데이터 혼재"
      완화: "chunk_type 명확히, 문서화"
      
      평가:
        혼란_가능성: 중간
        설명_가능성: 높음
      
      판단: ⚠️ 문서화 필수
      
      대응:
        - 명확한 가이드 작성
        - 예시 풍부
        - 온보딩 자료

---

# ═══════════════════════════════════════════════════════
# PART 8: 최종 권장사항
# ═══════════════════════════════════════════════════════

final_recommendation:
  
  권장: "Canonical-Projected 통합" ✅
  
  핵심_이유:
    
    1_아키텍처_일관성:
      중요도: "최고"
      
      장기적_가치:
        - 시스템 이해도 ↑
        - 예측 가능성 ↑
        - 확장성 ↑
      
      일관성_없으면:
        - 기술 부채 누적
        - 리팩토링 필요
        - 비용 ↑↑
    
    2_단점_대부분_완화_가능:
      
      완화_불가능_단점: 없음!
      
      완화_가능_단점:
        - 구현 시간: +1일 (투자 가치)
        - 복잡도: 문서화
        - 성능: 모니터링
        - 리스크: 점진적 배포
      
      잔여_리스크: "낮음"
    
    3_장기_효익_압도적:
      
      1년_후:
        방식_A:
          - Collection 관리: 2곳
          - 중복 데이터: 가능성
          - 동기화 이슈: 발생 가능
          - 리팩토링: 필요할 수 있음
        
        방식_B:
          - Collection 관리: 1곳
          - 중복: 불가능
          - 동기화: 자동
          - 리팩토링: 불필요
      
      비용_차이: 방식_B가 훨씬 유리
  
  단_유의사항:
    
    1_점진적_배포_필수:
      - Feature Flag
      - 단계적 활성화
      - 모니터링
    
    2_문서화_필수:
      - 스키마 변경 설명
      - 사용 가이드
      - 예시
    
    3_성능_모니터링:
      - 검색 속도
      - 메모리 사용
      - 임계값 설정
    
    4_롤백_계획:
      - 문제 시 즉시 비활성
      - 기존 시스템 정상 작동 보장

---

# ═══════════════════════════════════════════════════════
# PART 9: 의사결정 요약
# ═══════════════════════════════════════════════════════

decision_summary:
  
  질문: "별도 Collection vs Canonical-Projected 통합?"
  
  답변: "Canonical-Projected 통합" ✅
  
  감수하는_단점:
    - 구현 시간 +1일
    - 스키마 복잡도 +30%
    - 코드 +130줄
    - Projected 크기 4배
    - 개념 복잡도 증가
  
  얻는_장점:
    - 아키텍처 일관성 (핵심!)
    - 중복 없음
    - 메커니즘 재사용
    - 장기 유지보수 ↓↓
    - 확장성 ↑
  
  완화_가능:
    대부분의 단점은 완화 가능
    잔여 리스크: 낮음
  
  결론:
    장점 >> 단점
    
    특히:
      아키텍처_일관성 가치 >> 모든 단점
    
    UMIS 철학:
      품질 > 속도
      장기 > 단기
      
      → 방식_B 선택이 맞음!

---

# ═══════════════════════════════════════════════════════
# END - 정직한 단점 분석 완료
# ═══════════════════════════════════════════════════════

