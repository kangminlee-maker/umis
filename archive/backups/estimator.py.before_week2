"""
Estimator (Fermi) RAG Agent

6ë²ˆì§¸ Agent - ê°’ ì¶”ì • ë° ì§€ëŠ¥ì  íŒë‹¨ ì „ë¬¸ê°€ (v7.6.2 ì¬ì„¤ê³„)

ì£¼ìš” ë³€ê²½ (v7.6.0 â†’ v7.6.2):
- v7.6.0: 5-Phase ì¬ì„¤ê³„, Validator ìš°ì„  ê²€ìƒ‰, Built-in ì œê±°
- v7.6.1: ë‹¨ìœ„ ìë™ ë³€í™˜, Relevance ê²€ì¦
- v7.6.2: Boundary ê²€ì¦, í•˜ë“œì½”ë”© ì œê±°, Web Search ì¶”ê°€
"""

from typing import Optional, Dict, Any
import asyncio
from pathlib import Path

from langchain_openai import OpenAIEmbeddings
from langchain_community.vectorstores import Chroma

import sys
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

from umis_rag.core.config import settings
from umis_rag.utils.logger import logger

from .phase1_direct_rag import Phase1DirectRAG
from .phase3_guestimation import Phase3Guestimation
from .learning_writer import LearningWriter, UserContribution
from .models import Context, EstimationResult, GuardrailCollector


class EstimatorRAG:
    """
    Estimator (Fermi) RAG Agent (v7.6.0 ì¬ì„¤ê³„)
    
    ì—­í• :
    -----
    - ê°’ ì¶”ì • ì „ë¬¸ (Single Source of Truth for Estimation)
    - ë°ì´í„° ì—†ì„ ë•Œ ì°½ì˜ì  ì¶”ì •
    - Validator ìš°ì„  ê²€ìƒ‰ â†’ ì—†ìœ¼ë©´ ì¶”ì •
    - í•™ìŠµí•˜ëŠ” ì‹œìŠ¤í…œ (ì‚¬ìš©í• ìˆ˜ë¡ ë¹¨ë¼ì§)
    
    âš ï¸  ì—­í•  ëª…í™•í™”:
    - Estimator: ê°’ ì¶”ì •ë§Œ ë‹´ë‹¹ (ì˜ˆ: "B2B SaaS ARPUëŠ”?" â†’ 80,000ì›)
    - Quantifier: ê³„ì‚° ê³µì‹ ì†Œìœ  (ì˜ˆ: LTV = ARPU / Churn)
    - Validator: í™•ì • ë°ì´í„° ê²€ìƒ‰ (ì¶”ì • ì „ í•„ìˆ˜!)
    
    5-Phase ì•„í‚¤í…ì²˜ (v7.7.0):
    ---------------------------------
    - Phase 0: Literal (í”„ë¡œì íŠ¸ ë°ì´í„°, <0.1ì´ˆ, confidence 1.0)
    - Phase 1: Direct RAG (í•™ìŠµ ê·œì¹™, <0.5ì´ˆ, 0.95+)
    - Phase 2: Validator (í™•ì • ë°ì´í„° ê²€ìƒ‰, <1ì´ˆ, 1.0) â­ 85% ì²˜ë¦¬!
    - Phase 3: Guestimation (ì¶”ì •, 3-8ì´ˆ, 0.80+)
    - Phase 4: Fermi Decomposition (ë¶„í•´, 10-30ì´ˆ) ğŸ’
        â””â”€ Step 1-4: ìŠ¤ìº” â†’ ëª¨í˜• ìƒì„± â†’ ì²´í¬ â†’ ì‹¤í–‰
    
    í˜‘ì—… (ëª¨ë“  Agent):
    ------------------
    - Quantifier: í•„ìš”í•œ ê°’ ìš”ì²­ (ì˜ˆ: "ARPUëŠ”?", "Churnì€?")
    - Observer: ë¹„ìœ¨ ì¶”ì • (ê°€ì¹˜ì‚¬ìŠ¬ ë§ˆì§„, ì‹œì¥ ì§‘ì¤‘ë„)
    - Explorer: ì‹œì¥ í¬ê¸° ê° ì¡ê¸° (Order of Magnitude)
    - Validator: ì¶”ì •ì¹˜ êµì°¨ ê²€ì¦
    - Guardian: í”„ë¡œì íŠ¸ ë¦¬ì†ŒìŠ¤ ì¶”ì •
    
    Usage:
        >>> from umis_rag.agents.estimator import EstimatorRAG
        >>> estimator = EstimatorRAG()
        
        >>> # Phase 1-3 (ëŒ€ë¶€ë¶„ - ì¦ê±° ê¸°ë°˜)
        >>> result = estimator.estimate("B2B SaaS Churn RateëŠ”?", domain="B2B_SaaS")
        >>> print(f"{result.value} (Phase {result.phase})")
        
        >>> # Phase 4 (Fermi ë¶„í•´)
        >>> result = estimator.estimate("ì„œìš¸ ìŒì‹ì  ìˆ˜ëŠ”?")
        >>> # â†’ Fermi ë¶„í•´: ì¸êµ¬ Ã— ìŒì‹ì  ë°€ë„
        
        >>> # ë¹„ì¦ˆë‹ˆìŠ¤ ì§€í‘œëŠ” Quantifierê°€ ì²˜ë¦¬ (v7.5.0)
        >>> from umis_rag.agents.quantifier import get_quantifier_rag
        >>> quantifier = get_quantifier_rag()
        >>> ltv = quantifier.calculate_ltv(...)  # Quantifierê°€ LTV ê³„ì‚°
    """
    
    def __init__(self):
        """Estimator RAG Agent ì´ˆê¸°í™” (v7.9.0)"""
        logger.info("[Estimator] Fermi Agent ì´ˆê¸°í™”")
        
        # v7.9.0: llm_modeë¥¼ Propertyë¡œ ë³€ê²½ (ë™ì  ì½ê¸°)
        # self.llm_mode ì œê±° â†’ @propertyë¡œ ëŒ€ì²´
        logger.info(f"  ğŸ“Œ LLM Mode: {self.llm_mode}")
        
        # Phase 1: Direct RAG
        self.phase1 = Phase1DirectRAG()
        logger.info("  âœ… Phase 1 (Direct RAG)")
        
        # Validator: í™•ì • ë°ì´í„° ê²€ìƒ‰ (v7.6.0 ì¶”ê°€, Phase 2)
        self.validator = None  # Lazy ì´ˆê¸°í™”
        
        # Phase 2 Enhanced: ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ê²€ìƒ‰ (v7.9.0 ì¶”ê°€)
        self.phase2_enhanced = None  # Lazy ì´ˆê¸°í™”
        
        # Phase 3: Guestimation (Lazy ì´ˆê¸°í™”)
        self.phase3 = None
        self.learning_writer = None
        
        # Phase 4: Fermi Decomposition (Lazy ì´ˆê¸°í™”)
        self.phase4 = None
        
        # RAG Collections (Lazy)
        self.canonical_store = None
        self.projected_store = None
        
        logger.info("  âœ… Estimator Agent ì¤€ë¹„ ì™„ë£Œ")
    
    @property
    def llm_mode(self) -> str:
        """
        LLM ëª¨ë“œ ë™ì  ì½ê¸° (v7.9.0)
        
        Property íŒ¨í„´ìœ¼ë¡œ êµ¬í˜„í•˜ì—¬ settings ë³€ê²½ ì‹œ ì¦‰ì‹œ ë°˜ì˜
        
        Returns:
            í˜„ì¬ ì„¤ì •ëœ LLM ëª¨ë“œ (cursor, gpt-4o-mini, o1-mini ë“±)
        """
        return settings.llm_mode
    
    def estimate(
        self,
        question: str,
        context: Optional[Context] = None,
        domain: Optional[str] = None,
        region: Optional[str] = None,
        time_period: Optional[str] = None,
        project_data: Optional[Dict] = None
    ) -> Optional[EstimationResult]:
        """
        í†µí•© ì¶”ì • ë©”ì„œë“œ (v7.6.0 ì¬ì„¤ê³„)
        
        5-Phase í”„ë¡œì„¸ìŠ¤ (v7.7.0):
        - Phase 0: Literal (í”„ë¡œì íŠ¸ ë°ì´í„°, ì¦‰ì‹œ, confidence 1.0)
        - Phase 1: Direct RAG (í•™ìŠµ, <0.5ì´ˆ, 0.95+)
        - Phase 2: Validator (í™•ì • ë°ì´í„°, <1ì´ˆ, 1.0) â­ 85% ì²˜ë¦¬!
        - Phase 3: Guestimation (ì¶”ì •, 3-8ì´ˆ, 0.80+)
        - Phase 4: Fermi Decomposition (ë¶„í•´, 10-30ì´ˆ) ğŸ’
            â””â”€ Step 1: ì´ˆê¸° ìŠ¤ìº”
            â””â”€ Step 2: ëª¨í˜• ìƒì„±
            â””â”€ Step 3: ì‹¤í–‰ ê°€ëŠ¥ì„± ì²´í¬
            â””â”€ Step 4: ëª¨í˜• ì‹¤í–‰ (Backtracking)
        
        âš ï¸  v7.7.0 ìš©ì–´ ë³€ê²½:
        - 3-Tier â†’ 5-Phase (Estimator ì „ì²´)
        - Fermi ë‚´ë¶€: Step 1-4 (ëª…í™•ì„± í–¥ìƒ)
        
        Args:
            question: ì§ˆë¬¸ (êµ¬ì²´ì ì¼ìˆ˜ë¡ ì¢‹ìŒ!)
                ì˜ˆ: "B2B SaaS í•œêµ­ ì‹œì¥ ARPUëŠ”?" (âœ…)
                ì˜ˆ: "ARPUëŠ”?" (âŒ ë„ˆë¬´ ì• ë§¤)
            context: Context ê°ì²´ (ì„ íƒ)
            domain: ë„ë©”ì¸ (ì˜ˆ: "B2B_SaaS", "Food_Service")
            region: ì§€ì—­ (ì˜ˆ: "í•œêµ­", "ì„œìš¸")
            time_period: ì‹œì  (ì˜ˆ: "2024")
            project_data: í”„ë¡œì íŠ¸ í™•ì • ë°ì´í„°
        
        Returns:
            EstimationResult or None
        
        Example:
            >>> estimator = EstimatorRAG()
            
            >>> # Phase 1-3 (ì¦ê±° ê¸°ë°˜ ì¶”ì •)
            >>> result = estimator.estimate(
            ...     "B2B SaaS Churn RateëŠ”?",
            ...     domain="B2B_SaaS",
            ...     region="í•œêµ­"
            ... )
            >>> print(f"ê°’: {result.value}%, Phase: {result.phase}")
            
            >>> # Phase 4 (Fermi ë¶„í•´)
            >>> result = estimator.estimate("ì„œìš¸ ìŒì‹ì  ìˆ˜ëŠ”?")
            >>> # â†’ Fermi: ì¸êµ¬ Ã— ìŒì‹ì  ë°€ë„
            >>> # â†’ ì¬ê·€ ì¶”ì •ìœ¼ë¡œ í•˜ìœ„ ë³€ìˆ˜ ì±„ìš°ê¸°
            
            >>> # Context ëª…ì‹œ
            >>> from umis_rag.agents.estimator.models import Context
            >>> ctx = Context(domain="B2B_SaaS", region="í•œêµ­")
            >>> result = estimator.estimate("ARPUëŠ”?", context=ctx)
        """
        # Context ìƒì„±
        if context is None:
            context = Context(
                domain=domain or "General",
                region=region,
                time_period=time_period or "2024",
                project_data=project_data or {}
            )
        
        logger.info(f"[Estimator] ì¶”ì •: {question}")
        
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Phase 0: Project Data (v7.6.0)
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        if project_data:
            result = self._check_project_data(question, project_data, context)
            if result:
                logger.info(f"  âœ… Phase 0 (Project Data): {result.value}")
                return result
        
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Phase 1: Direct RAG (í•™ìŠµ ê·œì¹™, v7.7.0)
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        result = self.phase1.estimate(question, context)
        
        if result:
            logger.info(f"  âš¡ Phase 1 (Direct RAG) ì„±ê³µ: {result.value} ({result.execution_time:.2f}ì´ˆ)")
            return result
        
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Phase 2: Validator ê²€ìƒ‰ (v7.6.0) â­
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # ì¶”ì •í•˜ê¸° ì „ ë§ˆì§€ë§‰ í™•ì¸!
        # í™•ì • ë°ì´í„°ê°€ ì •ë§ ì—†ëŠ”ì§€ Validatorì—ê²Œ í™•ì¸
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        result = self._search_validator(question, context)
        if result:
            logger.info(f"  âœ… Phase 2 (Validator) ë°œê²¬: {result.value} ({result.execution_time:.2f}ì´ˆ)")
            return result
        
        logger.info("  â†’ Validatorì—ë„ ì—†ìŒ â†’ ì¶”ì • ì‹œì‘")
        
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # v7.9.0: Cursor ëª¨ë“œ ìë™ Fallback
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Phase 3-4ëŠ” LLM API í˜¸ì¶œ í•„ìš”
        # Cursor ëª¨ë“œëŠ” ëŒ€í™”í˜•ì´ë¯€ë¡œ ìë™ ì¶”ì • ë¶ˆê°€
        # â†’ gpt-4o-minië¡œ ìë™ Fallback
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        cursor_fallback_active = False
        if self.llm_mode == "cursor":
            logger.info("  ğŸ”„ Cursor ëª¨ë“œ â†’ API ëª¨ë“œ ìë™ Fallback")
            logger.info("     Phase 3-4ëŠ” LLM API í•„ìš” â†’ gpt-4o-mini ì‚¬ìš©")
            
            # settings ì„ì‹œ ë³€ê²½
            from umis_rag.core.config import settings
            original_mode = settings.llm_mode
            settings.llm_mode = "gpt-4o-mini"
            cursor_fallback_active = True
        
        try:
            # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            # Phase 3: Guestimation (ì¶”ì • ì‹œì‘, v7.7.0)
            # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            self._ensure_phase3_initialized()
            result = self.phase3.estimate(question, context)
            
            if result:
                logger.info(f"  ğŸ§  Phase 3 ì™„ë£Œ: {result.value} ({result.execution_time:.2f}ì´ˆ)")
                
                if result.should_learn:
                    logger.info(f"  ğŸ“š í•™ìŠµë¨ (ë‹¤ìŒì—” Phase 1ë¡œ ë¹ ë¦„!)")
                
                return result
        
        finally:
            # Cursor Fallback ë³µì›
            if cursor_fallback_active:
                settings.llm_mode = original_mode
                logger.debug(f"  Cursor ëª¨ë“œ ë³µì›: {original_mode}")
        
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Phase 4: Fermi Decomposition (v7.7.0)
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # ğŸ’ ê°€ì¥ ê°€ì¹˜ìˆëŠ” ì‘ì—…!
        # ì—†ëŠ” ìˆ«ìë¥¼ ë§Œë“œëŠ” ì°½ì¡°ì  ì¶”ì •
        # ì‹œê°„(10-30ì´ˆ), ë¹„ìš©($0) íˆ¬ì ì •ë‹¹í™”ë¨
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        
        # v7.9.0: Cursor Fallback (Phase 4ë„ ë™ì¼)
        if self.llm_mode == "cursor" and not cursor_fallback_active:
            logger.info("  ğŸ”„ Cursor ëª¨ë“œ â†’ API ëª¨ë“œ ìë™ Fallback (Phase 4)")
            from umis_rag.core.config import settings
            original_mode = settings.llm_mode
            settings.llm_mode = "gpt-4o-mini"
            cursor_fallback_active = True
        
        try:
            self._ensure_phase4_initialized()
            
            logger.info("  ğŸ’ Phase 4 ì‹œë„: ê°€ì¹˜ìˆëŠ” ì‘ì—…!")
            result = self.phase4.estimate(question, context, project_data, depth=0)
            
            if result:
                logger.info(f"  ğŸ§© Phase 4 ì™„ë£Œ: {result.value} ({result.execution_time:.2f}ì´ˆ)")
                if result.decomposition:
                    logger.info(f"     ëª¨í˜•: {result.decomposition.formula}")
                    logger.info(f"     Depth: {result.decomposition.depth}")
                return result
        
        finally:
            # Cursor Fallback ë³µì›
            if cursor_fallback_active:
                settings.llm_mode = original_mode
                logger.debug(f"  Cursor ëª¨ë“œ ë³µì›: {original_mode}")
        
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # ëª¨ë“  Phase ì‹¤íŒ¨ â†’ ì‹¤íŒ¨ ê²°ê³¼ ë°˜í™˜ (v7.9.0)
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        logger.warning("  âŒ ëª¨ë“  Phase ì‹¤íŒ¨")
        
        # v7.9.0: None ëŒ€ì‹  ì‹¤íŒ¨ ê²°ê³¼ ë°˜í™˜
        return EstimationResult(
            question=question,
            phase=-1,
            value=None,
            confidence=0.0,
            error="ëª¨ë“  Phase(0-4)ì—ì„œ ì¶”ì • ì‹¤íŒ¨",
            failed_phases=[0, 1, 2, 3, 4],
            reasoning="ì¶”ì • ë¶ˆê°€: í”„ë¡œì íŠ¸ ë°ì´í„°, í•™ìŠµ ê·œì¹™, Validator, Guestimation, Fermi ëª¨ë‘ ì‹¤íŒ¨",
            context=context,
            execution_time=0.0
        )
    
    def _ensure_phase3_initialized(self):
        """Phase 3 Lazy ì´ˆê¸°í™” (v7.9.0)"""
        if self.phase3 is None:
            # llm_mode=Noneìœ¼ë¡œ ì „ë‹¬ â†’ Phase 3ì´ ë™ì ìœ¼ë¡œ settings ì½ìŒ
            self.phase3 = Phase3Guestimation(
                llm_mode=None,  # v7.9.0: ë™ì  ì½ê¸°
                learning_writer=self.learning_writer
            )
            logger.info("  âœ… Phase 3 (Guestimation) ë¡œë“œ")
    
    def _ensure_phase4_initialized(self):
        """Phase 4 Lazy ì´ˆê¸°í™”"""
        if self.phase4 is None:
            from .phase4_fermi import Phase4FermiDecomposition
            self.phase4 = Phase4FermiDecomposition()
            logger.info("  âœ… Phase 4 (Fermi Decomposition) ë¡œë“œ")
    
    def contribute(
        self,
        question: str,
        value: float,
        unit: str = "",
        context: Optional[Context] = None,
        contribution_type: str = "definite_fact"
    ) -> str:
        """
        ì‚¬ìš©ì ê¸°ì—¬ (í™•ì • ì‚¬ì‹¤, ì—…ê³„ ìƒì‹ ë“±)
        
        Args:
            question: ì§ˆë¬¸
            value: ê°’
            unit: ë‹¨ìœ„
            context: ë§¥ë½
            contribution_type: ê¸°ì—¬ íƒ€ì…
                - "definite_fact": í™•ì • ì‚¬ì‹¤ (confidence=1.0)
                - "domain_knowledge": ì—…ê³„ ìƒì‹ (confidence=0.90)
                - "personal_experience": ê°œì¸ ê²½í—˜ (confidence=0.40)
        
        Returns:
            rule_id: ì €ì¥ëœ ê·œì¹™ ID
        
        Example:
            >>> estimator = EstimatorRAG()
            >>> rule_id = estimator.contribute(
            ...     question="ìš°ë¦¬ íšŒì‚¬ ì§ì› ìˆ˜ëŠ”?",
            ...     value=150,
            ...     unit="ëª…"
            ... )
            >>> # ì¦‰ì‹œ ì‚¬ìš© ê°€ëŠ¥!
            >>> result = estimator.estimate("ìš°ë¦¬ íšŒì‚¬ ì§ì› ìˆ˜ëŠ”?")
            >>> # â†’ Phase 1ì—ì„œ ì¦‰ì‹œ ë¦¬í„´ (<0.5ì´ˆ)
        """
        self._ensure_tier2_initialized()
        
        contribution = UserContribution(self.learning_writer)
        
        if contribution_type == "definite_fact":
            return contribution.add_definite_fact(
                question=question,
                value=value,
                unit=unit,
                context=context
            )
        elif contribution_type == "domain_knowledge":
            return contribution.add_domain_knowledge(
                question=question,
                value=value,
                context=context or Context()
            )
        elif contribution_type == "personal_experience":
            return contribution.add_personal_experience(
                question=question,
                value=value,
                context_description=str(context) if context else ""
            )
        else:
            raise ValueError(f"Unknown contribution_type: {contribution_type}")
    
    def get_learning_stats(self) -> Dict[str, Any]:
        """
        í•™ìŠµ í†µê³„ ì¡°íšŒ
        
        Returns:
            {
                'total_rules': int,
                'by_domain': dict,
                'avg_confidence': float
            }
        """
        if self.learning_writer:
            return self.learning_writer.get_learning_stats()
        return {
            'total_rules': 0,
            'by_domain': {},
            'avg_confidence': 0.0
        }
    
    def _check_project_data(
        self,
        question: str,
        project_data: Dict,
        context: Context
    ) -> Optional[EstimationResult]:
        """
        Phase 0: í”„ë¡œì íŠ¸ í™•ì • ë°ì´í„° í™•ì¸ (v7.6.0)
        
        í”„ë¡œì íŠ¸ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ì œê³µí•œ ë°ì´í„° ìš°ì„  í™•ì¸
        
        Args:
            question: ì§ˆë¬¸
            project_data: í”„ë¡œì íŠ¸ ë°ì´í„°
            context: ë§¥ë½
        
        Returns:
            EstimationResult or None
        
        Example:
            >>> project_data = {
            ...     "total_users": 10000,
            ...     "churn_rate": 0.05
            ... }
            >>> result = estimator._check_project_data(
            ...     "ì´íƒˆë¥ ì€?", project_data, context
            ... )
            >>> # â†’ 0.05 (ì¦‰ì‹œ)
        """
        import time
        start_time = time.time()
        
        # ì§ˆë¬¸ì—ì„œ í‚¤ì›Œë“œ ì¶”ì¶œ
        question_lower = question.lower()
        
        # í‚¤ì›Œë“œ ë§¤í•‘
        keyword_map = {
            'churn': ['churn_rate', 'monthly_churn', 'annual_churn'],
            'ì´íƒˆ': ['churn_rate', 'monthly_churn'],
            'í•´ì§€': ['churn_rate'],
            'arpu': ['arpu', 'average_revenue'],
            'í‰ê· ë§¤ì¶œ': ['arpu', 'average_revenue'],
            'ë§¤ì¶œ': ['arpu', 'revenue', 'average_revenue'],
            'user': ['total_users', 'active_users'],
            'ì‚¬ìš©ì': ['total_users', 'active_users', 'users'],
            'ê³ ê°': ['total_users', 'customers'],
            'ltv': ['ltv', 'lifetime_value'],
            'cac': ['cac', 'customer_acquisition_cost'],
            'íšë“ë¹„ìš©': ['cac']
        }
        
        # ë§¤ì¹­ ì‹œë„
        for keyword, possible_keys in keyword_map.items():
            if keyword in question_lower:
                for key in possible_keys:
                    if key in project_data:
                        value = project_data[key]
                        execution_time = time.time() - start_time
                        
                        return EstimationResult(
                            question=question,
                            value=value,
                            confidence=1.0,
                            phase=0,
                            context=context,
                            reasoning=f"í”„ë¡œì íŠ¸ í™•ì • ë°ì´í„°: {key}",
                            reasoning_detail={
                                'method': 'project_data',
                                'key': key,
                                'why_this_method': 'í”„ë¡œì íŠ¸ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ ì œê³µí•œ í™•ì • ê°’'
                            },
                            execution_time=execution_time
                        )
        
        return None
    
    def _search_validator(
        self,
        question: str,
        context: Context
    ) -> Optional[EstimationResult]:
        """
        Phase 2: Validator í™•ì • ë°ì´í„° ê²€ìƒ‰ (v7.9.0 Enhanced)
        
        ì¶”ì •í•˜ê¸° ì „ í™•ì • ë°ì´í„° ì¡´ì¬ ì—¬ë¶€ í™•ì¸
        
        v7.9.0 ê°œì„ :
        - Phase 2 Enhanced (ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜) ìš°ì„  ì‹œë„
        - 100ê°œ ë²¤ì¹˜ë§ˆí¬ í™œìš©
        - ì‚°ì—…/ê·œëª¨/ëª¨ë¸ë³„ ì¡°ì •
        
        Args:
            question: ì§ˆë¬¸
            context: ë§¥ë½
        
        Returns:
            EstimationResult(phase=2) or None
        """
        import time
        start_time = time.time()
        
        # Validator Lazy ì´ˆê¸°í™”
        if self.validator is None:
            from umis_rag.agents.validator import get_validator_rag
            self.validator = get_validator_rag()
            logger.info("  âœ… Validator ì—°ê²°")
        
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Phase 2 Enhanced ì‹œë„ (v7.9.0)
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Contextì— ì‚°ì—… ì •ë³´ê°€ ìˆìœ¼ë©´ Enhanced ì‚¬ìš©
        if context and context.project_data:
            context_dict = context.project_data
            
            # í•„ìˆ˜ ì •ë³´ í™•ì¸ (industry)
            if 'industry' in context_dict:
                # Phase2Enhanced Lazy ì´ˆê¸°í™”
                if self.phase2_enhanced is None:
                    try:
                        from .phase2_validator_search_enhanced import Phase2ValidatorSearchEnhanced
                        self.phase2_enhanced = Phase2ValidatorSearchEnhanced(
                            validator_rag=self.validator
                        )
                        # Benchmark store ì´ˆê¸°í™”
                        self.phase2_enhanced.initialize_benchmark_store()
                        logger.info("  âœ… Phase 2 Enhanced ì´ˆê¸°í™”")
                    except Exception as e:
                        logger.warning(f"  Phase 2 Enhanced ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                        self.phase2_enhanced = None
                
                # Phase2Enhanced ê²€ìƒ‰ ì‹œë„
                if self.phase2_enhanced:
                    try:
                        enhanced_result = self.phase2_enhanced.search_with_context(
                            query=question,
                            context=context_dict
                        )
                        
                        if enhanced_result and enhanced_result.confidence >= 0.75:
                            execution_time = time.time() - start_time
                            enhanced_result.execution_time = execution_time
                            logger.info(f"  âœ… Phase 2 Enhanced ì„±ê³µ: {enhanced_result.value:.1%} (Confidence: {enhanced_result.confidence:.2f})")
                            return enhanced_result
                        
                    except Exception as e:
                        logger.warning(f"  Phase 2 Enhanced ì˜¤ë¥˜: {e}")
        
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Phase 2 Basic (ê¸°ì¡´)
        # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
        # Validator ê²€ìƒ‰
        validator_result = self.validator.search_definite_data(question, context)
        
        if validator_result:
            execution_time = time.time() - start_time
            
            return EstimationResult(
                question=question,
                value=validator_result['value'],
                unit=validator_result.get('unit', ''),
                confidence=1.0,
                phase=2,
                context=context,
                reasoning=f"í™•ì • ë°ì´í„° (Validator): {validator_result['source']}",
                reasoning_detail={
                    'method': 'validator_search',
                    'source': validator_result['source'],
                    'definition': validator_result.get('definition', ''),
                    'last_updated': validator_result.get('last_updated', ''),
                    'reliability': validator_result.get('reliability', 'high'),
                    'why_this_method': 'Validatorê°€ ê³µì‹ í†µê³„/ë²¤ì¹˜ë§ˆí¬ì—ì„œ í™•ì • ë°ì´í„° ë°œê²¬'
                },
                logic_steps=[
                    f"1. Phase 1 í•™ìŠµ ê·œì¹™ ì—†ìŒ",
                    f"2. Validator ê²€ìƒ‰ ì‹œì‘",
                    f"3. ì¶œì²˜: {validator_result['source']}",
                    f"4. ê°’: {validator_result['value']}",
                    f"5. ì‹ ë¢°ë„: 1.0 (í™•ì • ë°ì´í„°)"
                ],
                execution_time=execution_time
            )
        
        return None
    
    def _ensure_tier2_initialized(self):
        """Phase 3 Lazy ì´ˆê¸°í™” (í˜¸í™˜ì„± ìœ ì§€)"""
        if self.phase3 is not None:
            return
        
        # Learning Writer ì´ˆê¸°í™”
        if self.learning_writer is None:
            # Canonical Collection ë¡œë“œ (Lazy)
            try:
                embeddings = OpenAIEmbeddings(
                    model=settings.embedding_model,
                    openai_api_key=settings.openai_api_key
                )
                
                canonical_store = Chroma(
                    collection_name="canonical_index",
                    embedding_function=embeddings,
                    persist_directory=str(settings.chroma_persist_dir)
                )
                
                self.learning_writer = LearningWriter(
                    canonical_collection=canonical_store._collection
                )
                logger.info("  âœ… Learning Writer ì´ˆê¸°í™”")
                
            except Exception as e:
                logger.warning(f"  âš ï¸  Learning Writer ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                self.learning_writer = None
        
        # Phase 3 ì´ˆê¸°í™”
        self.phase3 = Phase3Guestimation(
            learning_writer=self.learning_writer
        )
        logger.info("  âœ… Phase 3 ì´ˆê¸°í™”")


# ================================================================
# ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤
# ================================================================

_estimator_rag_instance = None


def get_estimator_rag() -> EstimatorRAG:
    """
    Estimator RAG ì‹±ê¸€í†¤ ì¸ìŠ¤í„´ìŠ¤ ë°˜í™˜
    
    Returns:
        EstimatorRAG ì¸ìŠ¤í„´ìŠ¤
    
    Example:
        >>> estimator = get_estimator_rag()
        >>> result = estimator.estimate("Churn RateëŠ”?")
    """
    global _estimator_rag_instance
    if _estimator_rag_instance is None:
        _estimator_rag_instance = EstimatorRAG()
    return _estimator_rag_instance



    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        # v7.10.0: Hybrid Architecture (3-Stage Pipeline)
        # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
        async def _stage1_collect(
            self,
            question: str,
            context: Context
        ) -> GuardrailCollector:
            """
            Stage 1: Tiered Collection (v7.10.0)
        
            Phase 0-2ë¥¼ ì‹¤í–‰í•˜ì—¬ í™•ì •ê°’ê³¼ ê°€ë“œë ˆì¼ ìˆ˜ì§‘
            - Phase 0: Sync (Ultra-fast <0.001s)
            - Phase 1-2: Parallel (<1s)
        
            Args:
                question: ì§ˆë¬¸
                context: ë§¥ë½
        
            Returns:
                GuardrailCollector (definite_values, hard/soft_guardrails)
            """
            from .models import Guardrail, GuardrailType
        
            collector = GuardrailCollector()
        
            # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            # Phase 0: Project Data (Sync, Ultra-fast)
            # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            phase0_result = self._check_project_data(question, context.project_data, context)
            if phase0_result:
                collector.add_definite(phase0_result)
                logger.info(f"  [Stage 1] Phase 0: í™•ì •ê°’ ë°œê²¬ (Fast Path!)")
        
            # Fast Path ì¡°ê±´: Phase 0ì—ì„œ í™•ì •ê°’ ë°œê²¬ ì‹œ ì¦‰ì‹œ ë°˜í™˜
            if collector.has_definite_value():
                logger.info(f"  âš¡ Fast Path ë°œë™! Stage 2-3 ìŠ¤í‚µ")
                return collector
        
            # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            # Phase 1-2: Parallel Execution
            # â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
            logger.info(f"  [Stage 1] Phase 1-2 ë³‘ë ¬ ì‹¤í–‰ ì‹œì‘...")
        
            phase1_result, phase2_result = await asyncio.gather(
                self._run_phase1(question, context),
                self._run_phase2(question, context),
                return_exceptions=True
            )
        
            # Phase 1 ê²°ê³¼ ì²˜ë¦¬
            if isinstance(phase1_result, EstimationResult):
                if phase1_result.confidence >= 0.90:
                    collector.add_definite(phase1_result)
                    logger.info(f"  [Stage 1] Phase 1: í™•ì •ê°’ (conf={phase1_result.confidence:.2f})")
                else:
                    # ë‚®ì€ ì‹ ë¢°ë„ â†’ Soft Guardrail
                    guard = Guardrail(
                        type=GuardrailType.SOFT_UPPER if phase1_result.value else GuardrailType.EXPECTED_RANGE,
                        value=phase1_result.value or 0.0,
                        confidence=phase1_result.confidence,
                        is_hard=False,
                        reasoning=f"Phase 1 ìœ ì‚¬ ê²°ê³¼ (conf={phase1_result.confidence:.2f})",
                        source="Phase1"
                    )
                    collector.add_guardrail(guard)
        
            # Phase 2 (Validator) ê²°ê³¼ ì²˜ë¦¬
            if isinstance(phase2_result, EstimationResult):
                if phase2_result.confidence == 1.0:
                    collector.add_definite(phase2_result)
                    logger.info(f"  [Stage 1] Phase 2: í™•ì •ê°’ (Validator)")
                else:
                    # êµ¬ì¡°ì  ì œì•½ â†’ Hard Guardrail
                    guard = Guardrail(
                        type=GuardrailType.HARD_UPPER,
                        value=phase2_result.value or 0.0,
                        confidence=phase2_result.confidence,
                        is_hard=True,
                        reasoning=f"Validator êµ¬ì¡°ì  ì œì•½ (conf={phase2_result.confidence:.2f})",
                        source="Validator"
                    )
                    collector.add_guardrail(guard)
        
            logger.info(f"  [Stage 1] ì™„ë£Œ: {collector.summary()}")
        
            return collector
    
        async def _run_phase1(self, question: str, context: Context) -> Optional[EstimationResult]:
            """Phase 1 ì‹¤í–‰ (ë¹„ë™ê¸° ë˜í¼)"""
            try:
                return self.phase1.estimate(question, context)
            except Exception as e:
                logger.error(f"  âŒ Phase 1 ì‹¤íŒ¨: {e}")
                return None
    
        async def _run_phase2(self, question: str, context: Context) -> Optional[EstimationResult]:
            """Phase 2 ì‹¤í–‰ (ë¹„ë™ê¸° ë˜í¼)"""
            try:
                return self._search_validator(question, context)
            except Exception as e:
                logger.error(f"  âŒ Phase 2 ì‹¤íŒ¨: {e}")
                return None
    
        async def _stage2_estimate(
            self,
            question: str,
            context: Context,
            collector: GuardrailCollector
        ) -> tuple[Optional[EstimationResult], Optional[EstimationResult]]:
            """
            Stage 2: Parallel Estimation (v7.10.0)
        
            Phase 3 (Range) + Phase 4 (Point) ë³‘ë ¬ ì‹¤í–‰
        
            Args:
                question: ì§ˆë¬¸
                context: ë§¥ë½
                collector: Stage 1 GuardrailCollector
        
            Returns:
                (phase3_result, phase4_result)
            """
            logger.info(f"  [Stage 2] Phase 3-4 ë³‘ë ¬ ì‹¤í–‰ ì‹œì‘...")
        
            # Phase 3-4 ë³‘ë ¬ ì‹¤í–‰
            phase3_result, phase4_result = await asyncio.gather(
                self._run_phase3_range(question, context, collector),
                self._run_phase4_fermi(question, context),
                return_exceptions=True
            )
        
            # ì˜ˆì™¸ ì²˜ë¦¬
            if isinstance(phase3_result, Exception):
                logger.error(f"  âŒ Phase 3 ì‹¤íŒ¨: {phase3_result}")
                phase3_result = None
        
            if isinstance(phase4_result, Exception):
                logger.error(f"  âŒ Phase 4 ì‹¤íŒ¨: {phase4_result}")
                phase4_result = None
        
            logger.info(f"  [Stage 2] ì™„ë£Œ")
            logger.info(f"    - Phase 3: {phase3_result.value_range if phase3_result else None}")
            logger.info(f"    - Phase 4: {phase4_result.value if phase4_result else None}")
        
            return phase3_result, phase4_result
    
        async def _run_phase3_range(
            self,
            question: str,
            context: Context,
            collector: GuardrailCollector
        ) -> Optional[EstimationResult]:
            """Phase 3 Range Engine ì‹¤í–‰"""
            try:
                # Phase 3 Range Engine (v7.10.0)
                from .phase3_range_engine import Phase3GuardrailRangeEngine
            
                if not hasattr(self, 'phase3_range_engine'):
                    self.phase3_range_engine = Phase3GuardrailRangeEngine()
            
                return await self.phase3_range_engine.calculate_range(question, context, collector)
        
            except Exception as e:
                logger.error(f"  âŒ Phase 3 Range ì‹¤íŒ¨: {e}")
                return None
    
        async def _run_phase4_fermi(
            self,
            question: str,
            context: Context
        ) -> Optional[EstimationResult]:
            """Phase 4 Fermi ì‹¤í–‰ (ë¹„ë™ê¸° ë˜í¼)"""
            try:
                # Phase 4 Lazy ì´ˆê¸°í™”
                if self.phase4 is None:
                    from .phase4_fermi import Phase4FermiDecomposition
                    self.phase4 = Phase4FermiDecomposition()
            
                return self.phase4.estimate(question, context)
        
            except Exception as e:
                logger.error(f"  âŒ Phase 4 Fermi ì‹¤íŒ¨: {e}")
                return None
    
        def _stage3_synthesis(
            self,
            phase3_result: Optional[EstimationResult],
            phase4_result: Optional[EstimationResult],
            collector: GuardrailCollector
        ) -> EstimationResult:
            """
            Stage 3: Synthesis (v7.10.0)
        
            Phase 3 Range + Phase 4 Point í†µí•©í•˜ì—¬ ìµœì¢… EstimationResult ìƒì„±
            - Cross-Validation (Range âˆ‹ Point?)
            - Weighted Fusion
            - Guardrail Validation
        
            Args:
                phase3_result: Phase 3 Range ê²°ê³¼
                phase4_result: Phase 4 Point ê²°ê³¼
                collector: GuardrailCollector
        
            Returns:
                EstimationResult (ìµœì¢…)
            """
            logger.info(f"  [Stage 3] Synthesis ì‹œì‘...")
        
            # Step 1: definite_values ìš°ì„  ë°˜í™˜ (Fast Path)
            if collector.has_definite_value():
                best = collector.get_best_definite()
                logger.info(f"  âš¡ Definite Value ë°˜í™˜: {best.value} (Phase {best.phase})")
                return best
        
            # Step 2: Phase 3, 4 ëª¨ë‘ ì‹¤íŒ¨ ì‹œ
            if not phase3_result and not phase4_result:
                logger.warning(f"  âš ï¸ Phase 3-4 ëª¨ë‘ ì‹¤íŒ¨")
                return EstimationResult(
                    question="",
                    value=None,
                    confidence=0.0,
                    phase=-1,
                    error="All phases failed"
                )
        
            # Step 3: Phase 3ë§Œ ì„±ê³µ (Rangeë§Œ)
            if phase3_result and not phase4_result:
                logger.info(f"  [Synthesis] Phase 3 Rangeë§Œ ì‚¬ìš©")
                return phase3_result
        
            # Step 4: Phase 4ë§Œ ì„±ê³µ (Pointë§Œ)
            if phase4_result and not phase3_result:
                logger.info(f"  [Synthesis] Phase 4 Pointë§Œ ì‚¬ìš©")
                return phase4_result
        
            # Step 5: Phase 3 + 4 ëª¨ë‘ ì„±ê³µ â†’ Cross-Validation
            logger.info(f"  [Synthesis] Cross-Validation ì‹œì‘...")
        
            # Cross-Validation: Phase 4 Point âˆˆ Phase 3 Range?
            if phase3_result.value_range and phase4_result.value:
                min_val, max_val = phase3_result.value_range
                point = phase4_result.value
            
                if min_val <= point <= max_val:
                    # Agreement: Confidence Boost (+15%)
                    logger.info(f"  âœ… Agreement: Point {point:.0f} âˆˆ Range [{min_val:.0f}, {max_val:.0f}]")
                
                    final_confidence = min(1.0, (phase3_result.confidence + phase4_result.confidence) / 2 + 0.15)
                
                    # Range Narrowing: Intersection(Range, PointÂ±10%)
                    narrow_range = (
                        max(min_val, point * 0.9),
                        min(max_val, point * 1.1)
                    )
                
                    return EstimationResult(
                        question=phase4_result.question,
                        value=point,
                        value_range=narrow_range,
                        confidence=final_confidence,
                        phase=4,  # API í˜¸í™˜ (ë‚´ë¶€: Synthesis)
                        reasoning_detail={
                            "synthesis": "cross_validation_success",
                            "confidence_boost": "+15%",
                            "range_narrowing": narrow_range
                        },
                        sources_used=phase3_result.sources_used + phase4_result.sources_used
                    )
            
                else:
                    # Disagreement: Confidence Penalty (-10%)
                    logger.warning(f"  âš ï¸ Disagreement: Point {point:.0f} âˆ‰ Range [{min_val:.0f}, {max_val:.0f}]")
                
                    final_confidence = max(0.5, (phase3_result.confidence + phase4_result.confidence) / 2 - 0.10)
                
                    # Range Expansion: Union(Range, PointÂ±20%)
                    expand_range = (
                        min(min_val, point * 0.8),
                        max(max_val, point * 1.2)
                    )
                
                    return EstimationResult(
                        question=phase4_result.question,
                        value=point,
                        value_range=expand_range,
                        confidence=final_confidence,
                        phase=4,
                        reasoning_detail={
                            "synthesis": "cross_validation_failure",
                            "confidence_penalty": "-10%",
                            "range_expansion": expand_range,
                            "warning": "Phase 3-4 ë¶ˆì¼ì¹˜"
                        },
                        sources_used=phase3_result.sources_used + phase4_result.sources_used
                    )
        
            # Fallback: Phase 4 ìš°ì„ 
            logger.info(f"  [Synthesis] Fallback: Phase 4 Point ì‚¬ìš©")
            return phase4_result

